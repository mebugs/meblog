/*
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 50733
 Source Host           : localhost:3306
 Source Schema         : mebugs_blog

 Target Server Type    : MySQL
 Target Server Version : 50733
 File Encoding         : 65001

 Date: 04/03/2022 16:35:33
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '分类ID',
  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '分类名称',
  `url` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '静态URL',
  `icon` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '分类图标地址',
  `remark` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '分类描述',
  `num` int(11) NOT NULL DEFAULT 0 COMMENT '文章数',
  `sorts` int(11) NULL DEFAULT NULL COMMENT '排序',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 17 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES (1, 'JAVA', 'java', '/static/img/team/java.svg', '世间万事万物皆对象', 19, 1);
INSERT INTO `category` VALUES (2, 'Golang', 'go', '/static/img/team/go.svg', '优势融合为并发而生', 0, 2);
INSERT INTO `category` VALUES (3, '概念', 'conn', '/static/img/team/conn.svg', '传输协议及概念原理', 0, 10);
INSERT INTO `category` VALUES (4, 'PHP', 'php', '/static/img/team/php.svg', '超文本脚本预处理器', 2, 3);
INSERT INTO `category` VALUES (5, 'Linux', 'linux', '/static/img/team/linux.svg', '开源服务器操作系统', 6, 5);
INSERT INTO `category` VALUES (6, 'WEB', 'web', '/static/img/team/page.svg', '网页前端视图与渲染', 12, 4);
INSERT INTO `category` VALUES (7, '数据库', 'db', '/static/img/team/db.svg', '存储管理数据的仓库', 7, 6);
INSERT INTO `category` VALUES (8, '移动端', 'app', '/static/img/team/mbi.svg', '原生应用与混合开发', 2, 7);
INSERT INTO `category` VALUES (9, '数据', 'run', '/static/img/team/lilia.svg', '结构算法与存储传输', 0, 9);
INSERT INTO `category` VALUES (10, '中间件', 'net', '/static/img/team/net.svg', '互联网应用服务相关', 1, 8);
INSERT INTO `category` VALUES (11, '架构', 'plat', '/static/img/team/plat.svg', '系统与业务架构设计', 2, 12);
INSERT INTO `category` VALUES (12, '运维', 'well', '/static/img/team/ywei.svg', '环境配置运行与维护', 4, 11);
INSERT INTO `category` VALUES (13, '开源', 'open', '/static/img/team/code.svg', '非商业个人开源项目', 2, 14);
INSERT INTO `category` VALUES (14, '安全', 'security', '/static/img/team/mid.svg', '网络应用与系统安全', 0, 13);
INSERT INTO `category` VALUES (15, '杂谈', 'box', '/static/img/team/demo.svg', '杂七杂八的随笔盒子', 0, 16);
INSERT INTO `category` VALUES (16, '工具', 'tool', '/static/img/team/tools.svg', '实用工具或教程分享', 4, 15);

-- ----------------------------
-- Table structure for comms
-- ----------------------------
DROP TABLE IF EXISTS `comms`;
CREATE TABLE `comms`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '评论ID',
  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `email` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `qq` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'QQ',
  `url` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '博客URL',
  `avt` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '头像路径',
  `pid` bigint(20) NULL DEFAULT NULL COMMENT '文章ID',
  `fid` bigint(20) NULL DEFAULT NULL COMMENT '父级评论ID',
  `level` smallint(1) NULL DEFAULT NULL COMMENT '评论等级',
  `coms` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '评论内容',
  `send_time` datetime(0) NULL DEFAULT NULL COMMENT '评论时间',
  `status` smallint(1) NOT NULL DEFAULT 0 COMMENT '评论状态',
  `admin` smallint(1) NOT NULL DEFAULT 0 COMMENT '是否管理员回复',
  `gid` bigint(20) NULL DEFAULT NULL COMMENT '评论分组ID',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `文章iD`(`pid`, `gid`, `level`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '评论表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comms
-- ----------------------------

-- ----------------------------
-- Table structure for friend
-- ----------------------------
DROP TABLE IF EXISTS `friend`;
CREATE TABLE `friend`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '数据ID',
  `furl` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '友链地址',
  `fname` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '友链站点名称',
  `fdesc` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '友链描述',
  `ficon` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '友链图标',
  `status` smallint(1) NULL DEFAULT NULL COMMENT '处理状态',
  `reson` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '拒绝原因',
  `findex` smallint(1) NOT NULL DEFAULT 0 COMMENT '是否申请首页友链',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '友链' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of friend
-- ----------------------------

-- ----------------------------
-- Table structure for post_info
-- ----------------------------
DROP TABLE IF EXISTS `post_info`;
CREATE TABLE `post_info`  (
  `pid` bigint(20) NOT NULL COMMENT '文章ID',
  `md` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT 'MD文本',
  `html` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT 'HTML文本',
  `menu` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '目录文本',
  PRIMARY KEY (`pid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of post_info
-- ----------------------------
INSERT INTO `post_info` VALUES (1, '# 关于本站\n\n## 域名与站名\n\n本站是一本个人修炼手册，用于记录个人学习历程、整理问题处理经验、分享工作心得体会、自我充电进步提升！\n\n- Me：我。\n- Bug：虫、程序漏洞、问题。\n- S：复数。\n\nMeBugS：我的与我所遇到的问题。\n\n域名的意义与本站的核心思想完全符合，这就是本站域名的由来。\n\n至于站名为啥叫米虫？总不能叫【我的问题集】吧。某种意义上的谐音，就叫米虫了。\n\n个人还是比较羡慕米虫这种生物，成为一个米虫，是我人生的终极目标！发一听...\n\n## 本站构建技术栈\n\n本站是一个独立的个人博客，并没有提供太多社交属性的相关功能。\n\n在早期，米虫折腾过很多开源的建站程序，如：Wordpress、Dedecms、Discuz！、Typecho、PhpWind、Ecshop等。\n\n这其过程中个人从非 IT 行业人士到转行进入 IT 行业，某种意义上转行 IT 也是对 WEB 应用充满了浓烈的兴趣。\n\n在不断折腾下，从一无所知开始自学HTML、CSS、JS到能够快速编写静态网页，基于开源程序使用过或自行修改过不少网站模板，也会扒一些国外的代码研究。\n\n但是无论是多精简和轻便的开源程序始终对于个人而言会存在冗余的功能，在初期访问速度很快，一旦数据量增多之后执行效率就大打折扣。\n\n于是米虫萌生了放弃使用开源建站程序的念头，因此本站并未使用任何开源建站程序。\n\n本站服务端的构建基于 PHP 7.4，数据库使用 MySql 5.7，整体结构为前后端分离形式。\n\n虽然服务端采用了 PHP，但实际所访问的页面都是静态 HTML，并不是简单的伪静态规则或者 Nginx 转发规则。\n\n下图以发布文章举例：\n\n![/static/upload/post/1646380414200.jpg](/static/upload/post/1646380414200.jpg)\n\n本站前端界面未采用任何UI框架包括 Jquery，JS 交互均采用原生的方式编写，CSS 尽量进行了公共抽离，减少冗余的代码。\n\n- 本站前端的动画特效均使用 CSS3 特性完成，意味着对于 IE 9 以下的浏览器兼容性不佳。\n- 本站前端实现了自适应，能够有好的支持平台和移动终端的访问。\n- 本站前端采用 PHP 生成的静态 HTML 提供访问，网页关键信息均生成在 HTML 中确保 SEO 效果。\n\n由于所有访问均为静态 HTML，不涉及服务端和数据库交互，这将具备更高的性能和更多的访问压力。\n\n本站管理端引入了Jquery、Vue、Marked 等核心插件，由于管理端不对外开放，在细节性能等方面就相对粗犷。\n\n这里也不再赘述。\n\n## 关于本站内容\n\n米虫自认为有比较良好的工作学习习惯，在通信期间，米虫整理的 TD-SCDMA 入门到晋阶也给不少同行带来很大的帮助。\n\n转行后，米虫有三四个笔记本已经写满了各种经验/教训/小结，小到 SQL 的语法格式，大到框架融合。\n\n有时候自己寻找查询并不方便，于是这样的个人博客应运而生。\n\n本站主要作用是米虫个人学习整理、经验小结的独立博客。\n\n内容主要涉猎于 IT 行业技术学习总结、问题整理记录、思考分析归纳。\n\n目前主要包含 Java、Go、Python、PHP 四门编程语言。\n\n包含数据库、服务端运维、前端、架构、数据、网络、移动端、分布式的等多个维度。\n\n此外包含个人的一些开源项目、在线案例分享、工具教程和分享等。\n\n具体您可以查看分类中心，希望您能有所收获。\n\n# 早期博客剪影\n\n早期的博客有很多没留下痕迹，少许还能复原，留个记忆。\n\n![/static/upload/post/1642036381271.jpg](/static/upload/post/1642036381271.jpg)\n\n![/static/upload/post/1642036426538.jpg](/static/upload/post/1642036426538.jpg)\n\n![/static/upload/post/1642638288879.png](/static/upload/post/1642638288879.png)\n\n![/static/upload/post/1642036391693.jpg](/static/upload/post/1642036391693.jpg)\n\n# 关于个人\n\n## 个人经历概述\n\n米虫，一个九流大专院校毕业的普通学生，所学专业移动通信技术，既不是学生会干部，也不是学霸。\n\n大二那年一家国营通信服务公司到学校搞校企合作顺带招人，老师让我们这些对于未来感到迷茫的小伙伴们也去感受一下。\n\n机缘巧合之下，米虫被选去体验实习两个月，勤恳、积极、主动的工作学习态度受到上级的认可后来被提前录用。\n\n于是米虫放荡不羁的大学生活被提前终止，并走上了通信网络优化这条不归路。\n\n对于比较看重毕业生就业率的大专院校而言，通通绿灯，后续的课程我都没有参与，当然学费还是要正常缴。\n\n由于工作性质原因，接下来的 4 年米虫跑遍了大江南北，在 28 个城市驻留工作，短则两个月，长则一年。\n\n每年除了年会可有可无的在公司总部冒个泡之外，一年 365 天有 360 天在外出差。\n\n这听起来是个很不错的差事，薪水也足够丰厚，但实际上出差工作与外出旅游完全是两个不同的概念。\n\n2014 年，亲人濒临故去，连夜从内蒙古包头做飞机赶往上海，深夜抵达上海市接到撒手人寰的噩耗时，那种撕心裂肺的痛楚令我无法忘怀。\n\n于是个人开始谋求改变，从远途出差申请调动到江浙沪一代，接收降薪降维，工作和未来变得一片迷茫。\n\n2015 年，我申请到家乡工作，被派往邻县，薪水已经折半，工作性质更是降维到无法忍受的地步，我做出了人生中最重要的决定。\n\n跳出舒适圈，重头再来，凭借兴趣选择一条全新的道路，这里也要非常感谢父母的鼓励与支持。\n\n工资再次大幅度缩水，甚至不到原本的四分之一，面对全新的事物，很艰难，但始终有股力量在支撑着我不断前进。\n\n时光如水，恍然优势多年，从萌新到一个九流程序员，说难似乎也没有那么难。\n\n安居一城的米虫不再彷徨，不再东奔西走，爱上一个人，拥有一个家，还有个可爱的闺女，简单的生活，平凡的人生。\n\n此前的种种，偶尔会想起，无论有快乐还是悲伤总是慢慢被藏起，埋在记忆的深处。\n\n无论未来怎么样，我始终坚信：\n\n一切都是最好的选择！\n\n## 一些寄语\n\n分享米虫的经历给大家，是希望大家都能找到自己的路，一时的迷茫不要灰心，总有拨云见日的时候。\n\n- 给自己一个目标，正确认知自我，努力拼，才会赢。\n- 如果年轻不能让自己满意，那余生只会为遗憾而懊悔。\n- 正确认知自己的兴趣，让工作与兴趣做更好的融合，你会更加快乐！\n\n本站如果能让您有所收获，亦我所愿！\n\n感谢您的阅读！\n\n- 愿你可以寻找到适合自己的路！\n- 愿你可以寻找到适合自己的人！\n- 愿你往后余生，每天快乐幸福！\n\n\n\n', '<h1 id=\"menu_1\">关于本站</h1><h2 id=\"menu_2\">域名与站名</h2><p>本站是一本个人修炼手册，用于记录个人学习历程、整理问题处理经验、分享工作心得体会、自我充电进步提升！</p>\n<ul>\n<li>Me：我。</li>\n<li>Bug：虫、程序漏洞、问题。</li>\n<li>S：复数。</li>\n</ul>\n<p>MeBugS：我的与我所遇到的问题。</p>\n<p>域名的意义与本站的核心思想完全符合，这就是本站域名的由来。</p>\n<p>至于站名为啥叫米虫？总不能叫【我的问题集】吧。某种意义上的谐音，就叫米虫了。</p>\n<p>个人还是比较羡慕米虫这种生物，成为一个米虫，是我人生的终极目标！发一听...</p>\n<h2 id=\"menu_3\">本站构建技术栈</h2><p>本站是一个独立的个人博客，并没有提供太多社交属性的相关功能。</p>\n<p>在早期，米虫折腾过很多开源的建站程序，如：Wordpress、Dedecms、Discuz！、Typecho、PhpWind、Ecshop等。</p>\n<p>这其过程中个人从非 IT 行业人士到转行进入 IT 行业，某种意义上转行 IT 也是对 WEB 应用充满了浓烈的兴趣。</p>\n<p>在不断折腾下，从一无所知开始自学HTML、CSS、JS到能够快速编写静态网页，基于开源程序使用过或自行修改过不少网站模板，也会扒一些国外的代码研究。</p>\n<p>但是无论是多精简和轻便的开源程序始终对于个人而言会存在冗余的功能，在初期访问速度很快，一旦数据量增多之后执行效率就大打折扣。</p>\n<p>于是米虫萌生了放弃使用开源建站程序的念头，因此本站并未使用任何开源建站程序。</p>\n<p>本站服务端的构建基于 PHP 7.4，数据库使用 MySql 5.7，整体结构为前后端分离形式。</p>\n<p>虽然服务端采用了 PHP，但实际所访问的页面都是静态 HTML，并不是简单的伪静态规则或者 Nginx 转发规则。</p>\n<p>下图以发布文章举例：</p>\n<p><img src=\"/static/upload/post/1646380414200.jpg\" alt=\"/static/upload/post/1646380414200.jpg\"/></p>\n<p>本站前端界面未采用任何UI框架包括 Jquery，JS 交互均采用原生的方式编写，CSS 尽量进行了公共抽离，减少冗余的代码。</p>\n<ul>\n<li>本站前端的动画特效均使用 CSS3 特性完成，意味着对于 IE 9 以下的浏览器兼容性不佳。</li>\n<li>本站前端实现了自适应，能够有好的支持平台和移动终端的访问。</li>\n<li>本站前端采用 PHP 生成的静态 HTML 提供访问，网页关键信息均生成在 HTML 中确保 SEO 效果。</li>\n</ul>\n<p>由于所有访问均为静态 HTML，不涉及服务端和数据库交互，这将具备更高的性能和更多的访问压力。</p>\n<p>本站管理端引入了Jquery、Vue、Marked 等核心插件，由于管理端不对外开放，在细节性能等方面就相对粗犷。</p>\n<p>这里也不再赘述。</p>\n<h2 id=\"menu_4\">关于本站内容</h2><p>米虫自认为有比较良好的工作学习习惯，在通信期间，米虫整理的 TD-SCDMA 入门到晋阶也给不少同行带来很大的帮助。</p>\n<p>转行后，米虫有三四个笔记本已经写满了各种经验/教训/小结，小到 SQL 的语法格式，大到框架融合。</p>\n<p>有时候自己寻找查询并不方便，于是这样的个人博客应运而生。</p>\n<p>本站主要作用是米虫个人学习整理、经验小结的独立博客。</p>\n<p>内容主要涉猎于 IT 行业技术学习总结、问题整理记录、思考分析归纳。</p>\n<p>目前主要包含 Java、Go、Python、PHP 四门编程语言。</p>\n<p>包含数据库、服务端运维、前端、架构、数据、网络、移动端、分布式的等多个维度。</p>\n<p>此外包含个人的一些开源项目、在线案例分享、工具教程和分享等。</p>\n<p>具体您可以查看分类中心，希望您能有所收获。</p>\n<h1 id=\"menu_5\">早期博客剪影</h1><p>早期的博客有很多没留下痕迹，少许还能复原，留个记忆。</p>\n<p><img src=\"/static/upload/post/1642036381271.jpg\" alt=\"/static/upload/post/1642036381271.jpg\"/></p>\n<p><img src=\"/static/upload/post/1642036426538.jpg\" alt=\"/static/upload/post/1642036426538.jpg\"/></p>\n<p><img src=\"/static/upload/post/1642638288879.png\" alt=\"/static/upload/post/1642638288879.png\"/></p>\n<p><img src=\"/static/upload/post/1642036391693.jpg\" alt=\"/static/upload/post/1642036391693.jpg\"/></p>\n<h1 id=\"menu_6\">关于个人</h1><h2 id=\"menu_7\">个人经历概述</h2><p>米虫，一个九流大专院校毕业的普通学生，所学专业移动通信技术，既不是学生会干部，也不是学霸。</p>\n<p>大二那年一家国营通信服务公司到学校搞校企合作顺带招人，老师让我们这些对于未来感到迷茫的小伙伴们也去感受一下。</p>\n<p>机缘巧合之下，米虫被选去体验实习两个月，勤恳、积极、主动的工作学习态度受到上级的认可后来被提前录用。</p>\n<p>于是米虫放荡不羁的大学生活被提前终止，并走上了通信网络优化这条不归路。</p>\n<p>对于比较看重毕业生就业率的大专院校而言，通通绿灯，后续的课程我都没有参与，当然学费还是要正常缴。</p>\n<p>由于工作性质原因，接下来的 4 年米虫跑遍了大江南北，在 28 个城市驻留工作，短则两个月，长则一年。</p>\n<p>每年除了年会可有可无的在公司总部冒个泡之外，一年 365 天有 360 天在外出差。</p>\n<p>这听起来是个很不错的差事，薪水也足够丰厚，但实际上出差工作与外出旅游完全是两个不同的概念。</p>\n<p>2014 年，亲人濒临故去，连夜从内蒙古包头做飞机赶往上海，深夜抵达上海市接到撒手人寰的噩耗时，那种撕心裂肺的痛楚令我无法忘怀。</p>\n<p>于是个人开始谋求改变，从远途出差申请调动到江浙沪一代，接收降薪降维，工作和未来变得一片迷茫。</p>\n<p>2015 年，我申请到家乡工作，被派往邻县，薪水已经折半，工作性质更是降维到无法忍受的地步，我做出了人生中最重要的决定。</p>\n<p>跳出舒适圈，重头再来，凭借兴趣选择一条全新的道路，这里也要非常感谢父母的鼓励与支持。</p>\n<p>工资再次大幅度缩水，甚至不到原本的四分之一，面对全新的事物，很艰难，但始终有股力量在支撑着我不断前进。</p>\n<p>时光如水，恍然优势多年，从萌新到一个九流程序员，说难似乎也没有那么难。</p>\n<p>安居一城的米虫不再彷徨，不再东奔西走，爱上一个人，拥有一个家，还有个可爱的闺女，简单的生活，平凡的人生。</p>\n<p>此前的种种，偶尔会想起，无论有快乐还是悲伤总是慢慢被藏起，埋在记忆的深处。</p>\n<p>无论未来怎么样，我始终坚信：</p>\n<p>一切都是最好的选择！</p>\n<h2 id=\"menu_8\">一些寄语</h2><p>分享米虫的经历给大家，是希望大家都能找到自己的路，一时的迷茫不要灰心，总有拨云见日的时候。</p>\n<ul>\n<li>给自己一个目标，正确认知自我，努力拼，才会赢。</li>\n<li>如果年轻不能让自己满意，那余生只会为遗憾而懊悔。</li>\n<li>正确认知自己的兴趣，让工作与兴趣做更好的融合，你会更加快乐！</li>\n</ul>\n<p>本站如果能让您有所收获，亦我所愿！</p>\n<p>感谢您的阅读！</p>\n<ul>\n<li>愿你可以寻找到适合自己的路！</li>\n<li>愿你可以寻找到适合自己的人！</li>\n<li>愿你往后余生，每天快乐幸福！</li>\n</ul>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">关于本站</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">域名与站名</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">本站构建技术栈</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">关于本站内容</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">早期博客剪影</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl1\">关于个人</a> <ul><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">个人经历概述</a> <!----></li><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl2\">一些寄语</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (2, '# 审核说明\n\n为了保证本站文明，您提交的评论需要经过人工审核后方会展示。\n\n一般来说正常发表意见、建议、讨论均可审核通过。\n\n博主会认真阅读所有留言，审核并及时回复。\n\n如您提交了邮箱，可能会受到回复提醒（本站不会对外公布您的邮箱地址）。\n\n本站可提交您的链接（并且可展示在评论列表上），如果网站不合规，审核时可能会移除您提交的网站链接。\n\n共建文明网络环境，你我一起努力！\n\n# 留言须知\n\n请阅读以下留下须知，如您的留言违规，将会被审核拒绝（审核拒绝的留言不再另行通知）。\n\n本站建立了黑名单机制，如果您多次违规，相关邮箱、网址会被加入黑名单列表。\n\n黑名单将自动阻断留言请求，无法发现留言的提交。\n\n---\n\n╔ 请勿提交散播或制造任何与事实不符的言论。\n\n╠ 请勿因观点或立场发表嘲笑、讽刺、漫骂等人身攻击言论。\n\n╠ 请勿提交违反国家法律法规的内容。\n\n╠ 请勿提交恶意广告。\n\n╠ 请勿提交含露骨性描写、不含蓄的文字内容。\n\n╠ 请勿提交政治、种族、肤色、性取向、宗教、民族、地域歧视内容。\n\n╚ 请勿提交重复内容。\n\n---\n\n', '<h1 id=\"menu_1\">审核说明</h1><p>为了保证本站文明，您提交的评论需要经过人工审核后方会展示。</p>\n<p>一般来说正常发表意见、建议、讨论均可审核通过。</p>\n<p>博主会认真阅读所有留言，审核并及时回复。</p>\n<p>如您提交了邮箱，可能会受到回复提醒（本站不会对外公布您的邮箱地址）。</p>\n<p>本站可提交您的链接（并且可展示在评论列表上），如果网站不合规，审核时可能会移除您提交的网站链接。</p>\n<p>共建文明网络环境，你我一起努力！</p>\n<h1 id=\"menu_2\">留言须知</h1><p>请阅读以下留下须知，如您的留言违规，将会被审核拒绝（审核拒绝的留言不再另行通知）。</p>\n<p>本站建立了黑名单机制，如果您多次违规，相关邮箱、网址会被加入黑名单列表。</p>\n<p>黑名单将自动阻断留言请求，无法发现留言的提交。</p>\n<hr/>\n<p>╔ 请勿提交散播或制造任何与事实不符的言论。</p>\n<p>╠ 请勿因观点或立场发表嘲笑、讽刺、漫骂等人身攻击言论。</p>\n<p>╠ 请勿提交违反国家法律法规的内容。</p>\n<p>╠ 请勿提交恶意广告。</p>\n<p>╠ 请勿提交含露骨性描写、不含蓄的文字内容。</p>\n<p>╠ 请勿提交政治、种族、肤色、性取向、宗教、民族、地域歧视内容。</p>\n<p>╚ 请勿提交重复内容。</p>\n<hr/>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">审核说明</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">留言须知</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1000, '# 前言\n\n最为JAVA开发者，无时无刻不在与JAVA对象打交道。\n我们在日常工作中常常将创建（实例化）对象的任务交给依赖框架，如Spring。\n但依旧需要了解JAVA实例化对象的比较常见的一些形式，他们分别是：\n\n1. 使用**new**关键字（构造函数会被调用）\n2. 使用**Class**类的newInstance()（构造函数会被调用）\n3. 使用**Constructor**类的newInstance()（构造函数会被调用）\n4. 使用**clone**方法（无构造函数调用）\n5. 使用**deserialization**（无构造函数调用）\n\n# 相关实例\n\n## new关键字\n\n最通用、常见、普遍、简单的实例化方式，默认调用无参构造，支持调用有参构造。\n\n```java\n/**无参构造创建对象*/\nUser jack= new User();\n/**有参构造创建对象 有参构造的入参与自定义的构造函数一致*/\nUser tom = new User(\"mebugs\",\"man\");\n```\n\n## Class类的newInstance()\n\n使用反射的Class类的newInstance()来实例化对象，newInstance()方法将调用无参构造方法去实例化一个对象。\n\n```java\n//方法将调用类的无参构造\nUser classIns = User.class.newInstance();\n```\n\n## Constructor类的newInstance()\n\n使用反射的Constructor类的newInstance()方法，与Class类中的newInstance()方法相似。\n\nConstructor类的newInstance()方法我们能够调用有参构造函数和私有构造函数。\n\n```java\n//默认调用形式\nUser consIns = User.class.getConstructor().newInstance();\n//调用有参构造\nUser consInsTom = User.class.getConstructor().newInstance(\"mebugs\",\"man\");\n//调用私有无参构造\nUser consInsPrive = User.class.getDeclaredConstructor().newInstance();\n```\n\n## clone()\n\n调用对象的clone()方法时，JVM都会为我们创建一个新对象，并将前一个对象的所有内容复制到其中。\n\n使用clone()方法创建对象不会调用任何构造函数，但对象的类需要实现Cloneable接口并定义clone()方法。\n\nclone()方法是比较有争议的话题，确实有它的缺点，但其是创建任何对象副本的最流行和最简单的方法。\n\n```java\n//默认调用形式\nUser jack = tom.clone();\n```\n\n## deserialization\n\n使用反序列化创建对象的前提是已经进行序列化操作。\n\n当进行序列化和反序列化对象时，JVM会为我们创建了一个独立的对象。\n\n在反序列化过程中，JVM不使用任何构造函数来创建对象，需要在类中实现Serializable接口。\n\n```java\n//序列化\nUser tom = new User(\"mebugs\",\"man\");\nObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"com.mebugs\"));\nout.writeObject(tom);\nout.close();\n//反序列化\nObjectInputStream in = new ObjectInputStream(new FileInputStream(\"com.mebugs\"));\nUser tomBack = (User) in.readObject();\nin.close();\n```\n\n# 其他说明\n\n## 反射方法\n\nClass类的newInstance()方法和Constructor类的newInstance()方法都被称为创建对象的反射方法。\n\n实际上，Class类的newInstance()方法内部使用Constructor类的newInstance()方法。\n\n这就是为什么后者更受欢迎，并且也被Spring、Hibernate等不同的经典框架所使用的原因。\n\n## Constructor类的获得\n\n上文中我们提到getConstructor()和getDeclaredConstructor()来获取Constructor类。\n\n- getDeclaredConstructor()返回指定参数类型、所有声明的（包括private）构造函数\n- getConstructor()返回指定参数类型、具有public访问权限的构造函数\n\n因此getConstructor()是getDeclaredConstructor()的子集。', '<h1 id=\"menu_1\">前言</h1><p>最为JAVA开发者，无时无刻不在与JAVA对象打交道。<br/>我们在日常工作中常常将创建（实例化）对象的任务交给依赖框架，如Spring。<br/>但依旧需要了解JAVA实例化对象的比较常见的一些形式，他们分别是：</p>\n<ol>\n<li>使用<strong>new</strong>关键字（构造函数会被调用）</li>\n<li>使用<strong>Class</strong>类的newInstance()（构造函数会被调用）</li>\n<li>使用<strong>Constructor</strong>类的newInstance()（构造函数会被调用）</li>\n<li>使用<strong>clone</strong>方法（无构造函数调用）</li>\n<li>使用<strong>deserialization</strong>（无构造函数调用）</li>\n</ol>\n<h1 id=\"menu_2\">相关实例</h1><h2 id=\"menu_3\">new关键字</h2><p>最通用、常见、普遍、简单的实例化方式，默认调用无参构造，支持调用有参构造。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">/**无参构造创建对象*/</span>\n<span class=\"hljs-keyword\">User</span> jack<span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">User</span>();\n<span class=\"hljs-comment\">/**有参构造创建对象 有参构造的入参与自定义的构造函数一致*/</span>\n<span class=\"hljs-keyword\">User</span> tom <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">User</span>(&quot;mebugs&quot;,&quot;man&quot;);\n</code></pre>\n<h2 id=\"menu_4\">Class类的newInstance()</h2><p>使用反射的Class类的newInstance()来实例化对象，newInstance()方法将调用无参构造方法去实例化一个对象。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//方法将调用类的无参构造</span>\n<span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">classIns</span> <span class=\"hljs-operator\">=</span> User.class.newInstance();\n</code></pre>\n<h2 id=\"menu_5\">Constructor类的newInstance()</h2><p>使用反射的Constructor类的newInstance()方法，与Class类中的newInstance()方法相似。</p>\n<p>Constructor类的newInstance()方法我们能够调用有参构造函数和私有构造函数。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//默认调用形式</span>\n<span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">consIns</span> <span class=\"hljs-operator\">=</span> User.class.getConstructor().newInstance();\n<span class=\"hljs-comment\">//调用有参构造</span>\n<span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">consInsTom</span> <span class=\"hljs-operator\">=</span> User.class.getConstructor().newInstance(<span class=\"hljs-string\">&quot;mebugs&quot;</span>,<span class=\"hljs-string\">&quot;man&quot;</span>);\n<span class=\"hljs-comment\">//调用私有无参构造</span>\n<span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">consInsPrive</span> <span class=\"hljs-operator\">=</span> User.class.getDeclaredConstructor().newInstance();\n</code></pre>\n<h2 id=\"menu_6\">clone()</h2><p>调用对象的clone()方法时，JVM都会为我们创建一个新对象，并将前一个对象的所有内容复制到其中。</p>\n<p>使用clone()方法创建对象不会调用任何构造函数，但对象的类需要实现Cloneable接口并定义clone()方法。</p>\n<p>clone()方法是比较有争议的话题，确实有它的缺点，但其是创建任何对象副本的最流行和最简单的方法。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//默认调用形式</span>\n<span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">jack</span> <span class=\"hljs-operator\">=</span> tom.clone();\n</code></pre>\n<h2 id=\"menu_7\">deserialization</h2><p>使用反序列化创建对象的前提是已经进行序列化操作。</p>\n<p>当进行序列化和反序列化对象时，JVM会为我们创建了一个独立的对象。</p>\n<p>在反序列化过程中，JVM不使用任何构造函数来创建对象，需要在类中实现Serializable接口。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//序列化</span>\n<span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">tom</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>(<span class=\"hljs-string\">&quot;mebugs&quot;</span>,<span class=\"hljs-string\">&quot;man&quot;</span>);\n<span class=\"hljs-type\">ObjectOutputStream</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectOutputStream</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileOutputStream</span>(<span class=\"hljs-string\">&quot;com.mebugs&quot;</span>));\nout.writeObject(tom);\nout.close();\n<span class=\"hljs-comment\">//反序列化</span>\n<span class=\"hljs-type\">ObjectInputStream</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectInputStream</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileInputStream</span>(<span class=\"hljs-string\">&quot;com.mebugs&quot;</span>));\n<span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">tomBack</span> <span class=\"hljs-operator\">=</span> (User) in.readObject();\nin.close();\n</code></pre>\n<h1 id=\"menu_8\">其他说明</h1><h2 id=\"menu_9\">反射方法</h2><p>Class类的newInstance()方法和Constructor类的newInstance()方法都被称为创建对象的反射方法。</p>\n<p>实际上，Class类的newInstance()方法内部使用Constructor类的newInstance()方法。</p>\n<p>这就是为什么后者更受欢迎，并且也被Spring、Hibernate等不同的经典框架所使用的原因。</p>\n<h2 id=\"menu_10\">Constructor类的获得</h2><p>上文中我们提到getConstructor()和getDeclaredConstructor()来获取Constructor类。</p>\n<ul>\n<li>getDeclaredConstructor()返回指定参数类型、所有声明的（包括private）构造函数</li>\n<li>getConstructor()返回指定参数类型、具有public访问权限的构造函数</li>\n</ul>\n<p>因此getConstructor()是getDeclaredConstructor()的子集。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">前言</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">相关实例</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">new关键字</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">Class类的newInstance()</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">Constructor类的newInstance()</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">clone()</a> <!----></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">deserialization</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl1\">其他说明</a> <ul><li><a href=\"javascript:runTo(\'menu_9\')\" class=\"pl2\">反射方法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_10\')\" class=\"pl2\">Constructor类的获得</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1001, '# expect\n\nexpect是一种可以用于交互式操作的脚本，来完成比如频繁远程登录&远程下载&定时日志提取等操作。\n\nexpect脚本由一系列expect-send对组成。\n\nexpect等待输出中输出特定的字符，通常是一个提示符，然后发送特定的响应。\n\n使用expect脚本前需要检查一下环境中是否有expect，直接输入:expect 检查\n\n```shell\nexpect1.1>\n```\n\n## 编写方式\n\n梳理正常执行某些操作所需要的命令、步骤、顺序、以及可能产生分支判断。\n\n将命令逐一添加到脚本中，通过控制台反馈内容来判定走向哪个分支。\n\n# 书写习惯\n\nLinux中exp脚本有两种主流书写样式：\n\n1. 直接写在sh中\n2. 独立写在exp文件\n\n个人推荐直接exp文件格式脚本，避免出现不同sh版本间的兼容问题。\n\n两种方式的实际书写风格一致。\n\n# 脚本实例\n\n## shell脚本调用exp文件\n\nexp脚本可以在shell脚本中调用\n\n```shell\n./sendResetPwd.exp ${ip} ${pwd}\n```\n\n## 远程上传一键密码更新脚本\n\n如果我们有多个环境需要一键更新密码的时候：\n\n1. 在一个操作环境上配置好所有远程环境的账号密码（可以从文件读取）\n2. 循环调用本实例exp脚本完成全部改密脚本的上传\n3. 建立一个类似的exp脚本主要通过ssh远程执行resetPsw.sh\n\n以下实现远程上传一个一键改密Shell脚本（resetPsw.sh)）作为示例&说明：\n\n(实例中的中文注释是为了方便阅读，实际linux环境中不建议出现中文字符）\n\n```shell\n#指定头文件\n#!/usr/bin/expect\n#接受脚本入参 IP和需要修改后的密码\nset  reip       [lindex $argv 0]\nset  rootpsw    [lindex $argv 1]\n#上传一键改密脚本至远程服务器\n#实际需要进行捕获的命令（scp -r resetPsw.sh root@${reip}:./），开始捕获\nspawn scp -r resetPsw.sh root@${reip}:./\n#设定循环flag\nset done 0 \n#设置超时时间30s\nset timeout 30 \n    #循环捕获入口\n    while {!$done} { \n        expect {\n            #捕获写到Password的字符串\n            \"Password*\"  \n            #输入传入的root密码\n            {send \"${rootpsw}r\"} \n            #捕获出现失败的字符串\n            \"*failures*\" \n            #直接退出，返回1\n            {exit 1} \n            #捕获到上传成功\n            \"resetPsw*\" \n            #停止循环\n            {set done 1} \n            #超时场景\n            Timeout  \n            {exit 1}\n        }\n}\n#正常退出 异常退出1已在上方退出\nexit 0   \n```\n\n# 补充优化\n\n类似这种远程批量行为，为了避免脚本执行异常，建议互相添加白名单实现免密访问，无需配置密码文件，可以大大提交执行效率。\n\n同理，互相添加白名单也可以通过expect实现，远程互相拷贝公钥。', '<h1 id=\"menu_1\">expect</h1><p>expect是一种可以用于交互式操作的脚本，来完成比如频繁远程登录&amp;远程下载&amp;定时日志提取等操作。</p>\n<p>expect脚本由一系列expect-send对组成。</p>\n<p>expect等待输出中输出特定的字符，通常是一个提示符，然后发送特定的响应。</p>\n<p>使用expect脚本前需要检查一下环境中是否有expect，直接输入:expect 检查</p>\n<pre><code class=\"hljs language-shell\">expect1.1&gt;\n</code></pre>\n<h2 id=\"menu_2\">编写方式</h2><p>梳理正常执行某些操作所需要的命令、步骤、顺序、以及可能产生分支判断。</p>\n<p>将命令逐一添加到脚本中，通过控制台反馈内容来判定走向哪个分支。</p>\n<h1 id=\"menu_3\">书写习惯</h1><p>Linux中exp脚本有两种主流书写样式：</p>\n<ol>\n<li>直接写在sh中</li>\n<li>独立写在exp文件</li>\n</ol>\n<p>个人推荐直接exp文件格式脚本，避免出现不同sh版本间的兼容问题。</p>\n<p>两种方式的实际书写风格一致。</p>\n<h1 id=\"menu_4\">脚本实例</h1><h2 id=\"menu_5\">shell脚本调用exp文件</h2><p>exp脚本可以在shell脚本中调用</p>\n<pre><code class=\"hljs language-shell\">./sendResetPwd.exp <span class=\"hljs-variable\">${</span>ip} <span class=\"hljs-variable\">${</span>pwd}\n</code></pre>\n<h2 id=\"menu_6\">远程上传一键密码更新脚本</h2><p>如果我们有多个环境需要一键更新密码的时候：</p>\n<ol>\n<li>在一个操作环境上配置好所有远程环境的账号密码（可以从文件读取）</li>\n<li>循环调用本实例exp脚本完成全部改密脚本的上传</li>\n<li>建立一个类似的exp脚本主要通过ssh远程执行resetPsw.sh</li>\n</ol>\n<p>以下实现远程上传一个一键改密Shell脚本（resetPsw.sh)）作为示例&amp;说明：</p>\n<p>(实例中的中文注释是为了方便阅读，实际linux环境中不建议出现中文字符）</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-comment\">#指定头文件</span>\n<span class=\"hljs-comment\">#!/usr/bin/expect</span>\n<span class=\"hljs-comment\">#接受脚本入参 IP和需要修改后的密码</span>\n<span class=\"hljs-built_in\">set</span>  reip       [lindex <span class=\"hljs-variable\">$argv</span> 0]\n<span class=\"hljs-built_in\">set</span>  rootpsw    [lindex <span class=\"hljs-variable\">$argv</span> 1]\n<span class=\"hljs-comment\">#上传一键改密脚本至远程服务器</span>\n<span class=\"hljs-comment\">#实际需要进行捕获的命令（scp -r resetPsw.sh root@${reip}:./），开始捕获</span>\nspawn scp -r resetPsw.sh root@<span class=\"hljs-variable\">${reip}</span>:./\n<span class=\"hljs-comment\">#设定循环flag</span>\n<span class=\"hljs-built_in\">set</span> <span class=\"hljs-keyword\">done</span> 0 \n<span class=\"hljs-comment\">#设置超时时间30s</span>\n<span class=\"hljs-built_in\">set</span> timeout 30 \n    <span class=\"hljs-comment\">#循环捕获入口</span>\n    <span class=\"hljs-keyword\">while</span> {!<span class=\"hljs-variable\">$done</span>} { \n        expect {\n            <span class=\"hljs-comment\">#捕获写到Password的字符串</span>\n            <span class=\"hljs-string\">&quot;Password*&quot;</span>  \n            <span class=\"hljs-comment\">#输入传入的root密码</span>\n            {send <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">${rootpsw}</span>r&quot;</span>} \n            <span class=\"hljs-comment\">#捕获出现失败的字符串</span>\n            <span class=\"hljs-string\">&quot;*failures*&quot;</span> \n            <span class=\"hljs-comment\">#直接退出，返回1</span>\n            {<span class=\"hljs-built_in\">exit</span> 1} \n            <span class=\"hljs-comment\">#捕获到上传成功</span>\n            <span class=\"hljs-string\">&quot;resetPsw*&quot;</span> \n            <span class=\"hljs-comment\">#停止循环</span>\n            {<span class=\"hljs-built_in\">set</span> <span class=\"hljs-keyword\">done</span> 1} \n            <span class=\"hljs-comment\">#超时场景</span>\n            Timeout  \n            {<span class=\"hljs-built_in\">exit</span> 1}\n        }\n}\n<span class=\"hljs-comment\">#正常退出 异常退出1已在上方退出</span>\n<span class=\"hljs-built_in\">exit</span> 0   \n</code></pre>\n<h1 id=\"menu_7\">补充优化</h1><p>类似这种远程批量行为，为了避免脚本执行异常，建议互相添加白名单实现免密访问，无需配置密码文件，可以大大提交执行效率。</p>\n<p>同理，互相添加白名单也可以通过expect实现，远程互相拷贝公钥。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">expect</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">编写方式</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">书写习惯</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">脚本实例</a> <ul><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">shell脚本调用exp文件</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">远程上传一键密码更新脚本</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl1\">补充优化</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1002, '# 问题说明\n\n在前端界面中涉及到多个勾选框级联的时候，一开始采用Jquery常见的.attr()方法。\n\n实际开发自测过程中发现有时候无法生效，或需要多次触发才会生效。\n\n而在Jquery1.8官方文档中的举同样例子的时候使用的是.prop()方法。\n\n# 方法介绍\n\n## prop()方法\n\nprop()方法：设置或返回被选元素的属性和值。\n\n - 当该方法用于返回属性值，则返回第一个匹配元素的值\n - 当该方法用于设置属性值，则为匹配元素设置一个或多个属性/值对\n - 方法操作radio（checkbox）之类的控件，让其选中的时候，其控件选中的值也会随之改变，即既可以控制其选中，也能控制其取消选中\n\n## attr()方法\n\nattr()方法：设置或返回被选元素的属性和值。\n\n - 当该方法用于返回属性值时，则返回第一个匹配元素的值\n - 当该方法用于设置属性值时，则为匹配元素集合设置一个或多个属性/值对\n - 方法操作adio（checkbox）之类的控件，让其选中的时候，其控件选中的值不会随之改变，即只能控制其选中，不能控制其取消选中\n\n## 原因分析\n\n从官方文档的描述来看，attr()应当也能够正常触发选择框的选中，实际应用发现有可能无效。\n\n1. 添加属性名称该属性就会生效应该使用prop()\n2. 特别是true,false两个属性使用prop()（如checked、selected、disabled等）\n3. 其他则使用attr()如自定义的一些属性（如data-val等）\n\n# 替换案例\n\n```javascript\n//勾选\n//旧写法\n$(\"#ID\").attr(\"checked\",\"checked\");\n//新写法\n$(\"#ID\").prop(\"checked\",\"true\");\n\n//去勾选\n//旧写法\n$(\"#ID\").attr(\"checked\",false);\n//新写法\n$(\"#ID\").removeAttr(\"checked\");\n\n//获取checkbox的选中状态\n//旧写法\n//返回结果始终是undefined \n$(\".check\").attr(\"checked\")\n//新写法\n//这两个语法的任意一个均获取到是否选中的结果true/false \n$(\".check\").prop(\"checked\")\n$(\".check\").is(\":checked\")\n```', '<h1 id=\"menu_1\">问题说明</h1><p>在前端界面中涉及到多个勾选框级联的时候，一开始采用Jquery常见的.attr()方法。</p>\n<p>实际开发自测过程中发现有时候无法生效，或需要多次触发才会生效。</p>\n<p>而在Jquery1.8官方文档中的举同样例子的时候使用的是.prop()方法。</p>\n<h1 id=\"menu_2\">方法介绍</h1><h2 id=\"menu_3\">prop()方法</h2><p>prop()方法：设置或返回被选元素的属性和值。</p>\n<ul>\n<li>当该方法用于返回属性值，则返回第一个匹配元素的值</li>\n<li>当该方法用于设置属性值，则为匹配元素设置一个或多个属性/值对</li>\n<li>方法操作radio（checkbox）之类的控件，让其选中的时候，其控件选中的值也会随之改变，即既可以控制其选中，也能控制其取消选中</li>\n</ul>\n<h2 id=\"menu_4\">attr()方法</h2><p>attr()方法：设置或返回被选元素的属性和值。</p>\n<ul>\n<li>当该方法用于返回属性值时，则返回第一个匹配元素的值</li>\n<li>当该方法用于设置属性值时，则为匹配元素集合设置一个或多个属性/值对</li>\n<li>方法操作adio（checkbox）之类的控件，让其选中的时候，其控件选中的值不会随之改变，即只能控制其选中，不能控制其取消选中</li>\n</ul>\n<h2 id=\"menu_5\">原因分析</h2><p>从官方文档的描述来看，attr()应当也能够正常触发选择框的选中，实际应用发现有可能无效。</p>\n<ol>\n<li>添加属性名称该属性就会生效应该使用prop()</li>\n<li>特别是true,false两个属性使用prop()（如checked、selected、disabled等）</li>\n<li>其他则使用attr()如自定义的一些属性（如data-val等）</li>\n</ol>\n<h1 id=\"menu_6\">替换案例</h1><pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">//勾选</span>\n<span class=\"hljs-comment\">//旧写法</span>\n$(<span class=\"hljs-string\">&quot;#ID&quot;</span>).<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;checked&quot;</span>,<span class=\"hljs-string\">&quot;checked&quot;</span>);\n<span class=\"hljs-comment\">//新写法</span>\n$(<span class=\"hljs-string\">&quot;#ID&quot;</span>).<span class=\"hljs-title function_\">prop</span>(<span class=\"hljs-string\">&quot;checked&quot;</span>,<span class=\"hljs-string\">&quot;true&quot;</span>);\n\n<span class=\"hljs-comment\">//去勾选</span>\n<span class=\"hljs-comment\">//旧写法</span>\n$(<span class=\"hljs-string\">&quot;#ID&quot;</span>).<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;checked&quot;</span>,<span class=\"hljs-literal\">false</span>);\n<span class=\"hljs-comment\">//新写法</span>\n$(<span class=\"hljs-string\">&quot;#ID&quot;</span>).<span class=\"hljs-title function_\">removeAttr</span>(<span class=\"hljs-string\">&quot;checked&quot;</span>);\n\n<span class=\"hljs-comment\">//获取checkbox的选中状态</span>\n<span class=\"hljs-comment\">//旧写法</span>\n<span class=\"hljs-comment\">//返回结果始终是undefined </span>\n$(<span class=\"hljs-string\">&quot;.check&quot;</span>).<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;checked&quot;</span>)\n<span class=\"hljs-comment\">//新写法</span>\n<span class=\"hljs-comment\">//这两个语法的任意一个均获取到是否选中的结果true/false </span>\n$(<span class=\"hljs-string\">&quot;.check&quot;</span>).<span class=\"hljs-title function_\">prop</span>(<span class=\"hljs-string\">&quot;checked&quot;</span>)\n$(<span class=\"hljs-string\">&quot;.check&quot;</span>).<span class=\"hljs-title function_\">is</span>(<span class=\"hljs-string\">&quot;:checked&quot;</span>)\n</code></pre>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">问题说明</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">方法介绍</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">prop()方法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">attr()方法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">原因分析</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl1\">替换案例</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1003, '# 磁盘挂载说明\n\nLinux系统下会比较习惯将大储存的磁盘挂载在/home路径下。\n\n那磁盘挂载到底是怎么回事呢？\n\n相信大家会经常接触Windows操作系统，里面会有C盘D盘或者更多。\n\n一般C盘是系统盘，大家常常会讲尽量不要再C盘安装太多东西，很多安全管家都有系统盘搬家工具。\n\nLinux系统实际也是区分系统盘和硬盘的，只不过首次启动的时候它并不会自己去加载磁盘。\n\n简单来说就是，只有C盘（系统盘），其他的暂时是看不到的。\n\n如果这个时候就开始安装软件的话，后期你会悲剧的发现硬盘根本不够用（因为一般系统盘不会特别大，40-50G左右）。\n\n一般系统盘是没有办法扩充，如果装完软件后再添加挂载极有可能会对现有的目录造成冲突。\n\n所以，首次拿到Linux环境，一定要先看下有没有挂载盘，先挂载起来，再愉快的玩耍。\n\n在Linux环境中的磁盘与Windows系统最大的差别就是可以自由挂载。\n\n可以将磁盘理解为即插即用的U盘或者移动硬盘，只不过每次拔插需要进行一定的配置才能使用。\n\n# 实例说明\n\n```bash\n#挂载之前如果对硬盘扩容了，系统是不识别新磁盘需要进行分区划分\nfdisk /dev/sda\n```\n\n下文中是中文版的CentOS的操作提示：\n\n```bash\n欢迎使用 fdisk (util-linux 2.23.2)。\n更改将停留在内存中，直到您决定将更改写入磁盘。\n使用写入命令前请三思。\n命令(输入 m 获取帮助)：m\n命令操作\n   a   toggle a bootable flag\n   b   edit bsd disklabel\n   c   toggle the dos compatibility flag\n   d   delete a partition\n   g   create a new empty GPT partition table\n   G   create an IRIX (SGI) partition table\n   l   list known partition types\n   m   print this menu\n   n   add a new partition\n   o   create a new empty DOS partition table\n   p   print the partition table\n   q   quit without saving changes\n   s   create a new empty Sun disklabel\n   t   change a partition\'s system id\n   u   change display/entry units\n   v   verify the partition table\n   w   write table to disk and exit\n   x   extra functionality (experts only)\n\n命令(输入 m 获取帮助)：n\nPartition type:\n   p   primary (2 primary, 0 extended, 2 free)\n   e   extended\nSelect (default p): p\n分区号 (3,4，默认 3)：3\n起始 扇区 (167772160-419430399，默认为 167772160)：\n将使用默认值 167772160\nLast 扇区, +扇区 or +size{K,M,G} (167772160-419430399，默认为 419430399)：\n将使用默认值 419430399\n分区 3 已设置为 Linux 类型，大小设为 120 GiB\n```\n\n## 完整操作流程\n\n```shell\n#检查所有磁盘分区\n#主要用于查新准备用来进行挂载的盘符\n#这里是/dev/xvde ：Disk /dev/xvde doesn\'t contain a valid partition table\n#表示这个磁盘没有挂载\nfdisk -l\n#新建这个盘符的挂载（与上方盘符名一致）\nfdisk /dev/xvde  \n#按顺序执行\nm\nn\np\n1\n回车\n回车\np\nw\n#完成挂载盘的对接\n#重启环境用于生效\nreboot \n#挂载/dev/xvde盘\nmkfs.ext3 /dev/xvde \n#为磁盘指定相应的目录\nmount /dev/xvde /home \n#将挂载目录结构保存下来，之后如果重启时，可以自动加载挂载的磁盘\n#>>表示将\"/dev/xvde /home ext3 defaults 0 0\"追加写入搭配/etc/fstab文件\necho \"/dev/xvde /home ext3 defaults 0 0\" >>/etc/fstab \n```\n\n# 设置自动加载\n\n务必将挂载配置写入**/etc/fstab**文件中，这样reboot（重启）系统后才能够自动加载挂载的磁盘进来。', '<h1 id=\"menu_1\">磁盘挂载说明</h1><p>Linux系统下会比较习惯将大储存的磁盘挂载在/home路径下。</p>\n<p>那磁盘挂载到底是怎么回事呢？</p>\n<p>相信大家会经常接触Windows操作系统，里面会有C盘D盘或者更多。</p>\n<p>一般C盘是系统盘，大家常常会讲尽量不要再C盘安装太多东西，很多安全管家都有系统盘搬家工具。</p>\n<p>Linux系统实际也是区分系统盘和硬盘的，只不过首次启动的时候它并不会自己去加载磁盘。</p>\n<p>简单来说就是，只有C盘（系统盘），其他的暂时是看不到的。</p>\n<p>如果这个时候就开始安装软件的话，后期你会悲剧的发现硬盘根本不够用（因为一般系统盘不会特别大，40-50G左右）。</p>\n<p>一般系统盘是没有办法扩充，如果装完软件后再添加挂载极有可能会对现有的目录造成冲突。</p>\n<p>所以，首次拿到Linux环境，一定要先看下有没有挂载盘，先挂载起来，再愉快的玩耍。</p>\n<p>在Linux环境中的磁盘与Windows系统最大的差别就是可以自由挂载。</p>\n<p>可以将磁盘理解为即插即用的U盘或者移动硬盘，只不过每次拔插需要进行一定的配置才能使用。</p>\n<h1 id=\"menu_2\">实例说明</h1><pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\">#挂载之前如果对硬盘扩容了，系统是不识别新磁盘需要进行分区划分</span>\nfdisk /dev/sda\n</code></pre>\n<p>下文中是中文版的CentOS的操作提示：</p>\n<pre><code class=\"hljs language-bash\">欢迎使用 fdisk (util<span class=\"hljs-operator\">-</span>linux <span class=\"hljs-number\">2.23</span><span class=\"hljs-number\">.2</span>)。\n更改将停留在内存中，直到您决定将更改写入磁盘。\n使用写入命令前请三思。\n命令(输入 m 获取帮助)：m\n命令操作\n   a   toggle a bootable flag\n   b   edit bsd disklabel\n   c   toggle the dos compatibility flag\n   d   <span class=\"hljs-keyword\">delete</span> a <span class=\"hljs-keyword\">partition</span>\n   g   <span class=\"hljs-keyword\">create</span> a <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">empty</span> GPT <span class=\"hljs-keyword\">partition</span> <span class=\"hljs-keyword\">table</span>\n   G   <span class=\"hljs-keyword\">create</span> an IRIX (SGI) <span class=\"hljs-keyword\">partition</span> <span class=\"hljs-keyword\">table</span>\n   l   list known <span class=\"hljs-keyword\">partition</span> types\n   m   print this menu\n   n   <span class=\"hljs-keyword\">add</span> a <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">partition</span>\n   o   <span class=\"hljs-keyword\">create</span> a <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">empty</span> DOS <span class=\"hljs-keyword\">partition</span> <span class=\"hljs-keyword\">table</span>\n   p   print the <span class=\"hljs-keyword\">partition</span> <span class=\"hljs-keyword\">table</span>\n   q   quit <span class=\"hljs-keyword\">without</span> saving changes\n   s   <span class=\"hljs-keyword\">create</span> a <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">empty</span> Sun disklabel\n   t   change a <span class=\"hljs-keyword\">partition</span><span class=\"hljs-string\">&#x27;s system id\n   u   change display/entry units\n   v   verify the partition table\n   w   write table to disk and exit\n   x   extra functionality (experts only)\n\n命令(输入 m 获取帮助)：n\nPartition type:\n   p   primary (2 primary, 0 extended, 2 free)\n   e   extended\nSelect (default p): p\n分区号 (3,4，默认 3)：3\n起始 扇区 (167772160-419430399，默认为 167772160)：\n将使用默认值 167772160\nLast 扇区, +扇区 or +size{K,M,G} (167772160-419430399，默认为 419430399)：\n将使用默认值 419430399\n分区 3 已设置为 Linux 类型，大小设为 120 GiB</span>\n</code></pre>\n<h2 id=\"menu_3\">完整操作流程</h2><pre><code class=\"hljs language-shell\"><span class=\"hljs-comment\">#检查所有磁盘分区</span>\n<span class=\"hljs-comment\">#主要用于查新准备用来进行挂载的盘符</span>\n<span class=\"hljs-comment\">#这里是/dev/xvde ：Disk /dev/xvde doesn&#x27;t contain a valid partition table</span>\n<span class=\"hljs-comment\">#表示这个磁盘没有挂载</span>\nfdisk -l\n<span class=\"hljs-comment\">#新建这个盘符的挂载（与上方盘符名一致）</span>\nfdisk /dev/xvde  \n<span class=\"hljs-comment\">#按顺序执行</span>\nm\nn\np\n<span class=\"hljs-number\">1</span>\n回车\n回车\np\nw\n<span class=\"hljs-comment\">#完成挂载盘的对接</span>\n<span class=\"hljs-comment\">#重启环境用于生效</span>\nreboot \n<span class=\"hljs-comment\">#挂载/dev/xvde盘</span>\nmkfs.ext3 /dev/xvde \n<span class=\"hljs-comment\">#为磁盘指定相应的目录</span>\nmount /dev/xvde /home \n<span class=\"hljs-comment\">#将挂载目录结构保存下来，之后如果重启时，可以自动加载挂载的磁盘</span>\n<span class=\"hljs-comment\">#&gt;&gt;表示将&quot;/dev/xvde /home ext3 defaults 0 0&quot;追加写入搭配/etc/fstab文件</span>\necho <span class=\"hljs-string\">&quot;/dev/xvde /home ext3 defaults 0 0&quot;</span> &gt;&gt;<span class=\"hljs-regexp\">/etc/fstab</span> \n</code></pre>\n<h1 id=\"menu_4\">设置自动加载</h1><p>务必将挂载配置写入**/etc/fstab**文件中，这样reboot（重启）系统后才能够自动加载挂载的磁盘进来。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">磁盘挂载说明</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">实例说明</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">完整操作流程</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">设置自动加载</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1004, '# 需求描述\n\n开发或测试环境一般会打开DEBUG调试模式，程序会产生大量的DEBUG_LOG，一周时间（甚至更短）就能把环境磁盘塞满。\n\n人为手动删除日志的话，环境过多（工作量大），任务繁忙（遗忘），给环境使用带来影响。\n\nLinux系统是否有与Windows类似的定时任务的程式呢？有的。\n\nCrontab实现自动任务就是在/etc/crontab文件中按照规则配置自动任务，系统会按照配置进行任务调度。\n\n其功能是在**指定时间**或**指定时间间隔调度**命令或脚本或拉起程序。\n\n# 命令配置语法格式\n\n```bash\nminute hour day-of-month month-of-year day-of-week commands\n# minute 分钟(0-59)\n# hour 小时(0-23)\n# day-of-month 日(01-31)\n# month-of-year 月(01-12)\n# day-of-week 周(0-6)\n# commands 执行命令\n```\n\n参数除了填写数字还可以写特殊符号：\n\n1. *:所有数字组合（也可以认为不限制）\n2. /:每（一般*/5表示每5个单位时间）\n3. -:范围数字组合 \n4. ,:多条件组合\n\n# 编写简单的执行脚本\n\n比如清理Oracle垃圾数据（先写一个清理的脚本clear.sh）：\n\n```shell\n#!/bin/bash\nrm -rf /*/oracle/diag/rdbms/trace/*\nrm -rf /*/oracle/diag/rdbms/alert/*\n```\n\n# 配置命令\n\nCrontab命令的配置是写在/etc/crontab文件中\n\n**vi /etc/crontab**\n\n可以看到里面或许已存在一些已有任务。\n\nCrontab命令简单实例：\n\n```bash\n#以下实例基本涵盖了大部分使用场景\n#早上6点执行清理\n0 6 * * * sh /home/oracle/task/clear.sh \n#每8小时执行清理\n0 */8 * * * sh /home/oracle/task/clear.sh\n#晚11至早6点每两小时执行清理以及早六点执行清理\n0 23-5/2,6 * * * sh /home/oracle/task/clear.sh\n#周三/周日早六点执行清理\n0 6 * * 3,0 sh /home/oracle/task/clear.sh \n```\n\n# 生效方式\n\n在**/etc/crontab**中正确配置保存后即可生效。', '<h1 id=\"menu_1\">需求描述</h1><p>开发或测试环境一般会打开DEBUG调试模式，程序会产生大量的DEBUG_LOG，一周时间（甚至更短）就能把环境磁盘塞满。</p>\n<p>人为手动删除日志的话，环境过多（工作量大），任务繁忙（遗忘），给环境使用带来影响。</p>\n<p>Linux系统是否有与Windows类似的定时任务的程式呢？有的。</p>\n<p>Crontab实现自动任务就是在/etc/crontab文件中按照规则配置自动任务，系统会按照配置进行任务调度。</p>\n<p>其功能是在<strong>指定时间</strong>或<strong>指定时间间隔调度</strong>命令或脚本或拉起程序。</p>\n<h1 id=\"menu_2\">命令配置语法格式</h1><pre><code class=\"hljs language-bash\"><span class=\"hljs-keyword\">minute</span> <span class=\"hljs-keyword\">hour</span> <span class=\"hljs-keyword\">day</span><span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">of</span><span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">month</span> <span class=\"hljs-keyword\">month</span><span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">of</span><span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">year</span> <span class=\"hljs-keyword\">day</span><span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">of</span><span class=\"hljs-operator\">-</span>week commands\n# <span class=\"hljs-keyword\">minute</span> 分钟(<span class=\"hljs-number\">0</span><span class=\"hljs-number\">-59</span>)\n# <span class=\"hljs-keyword\">hour</span> 小时(<span class=\"hljs-number\">0</span><span class=\"hljs-number\">-23</span>)\n# <span class=\"hljs-keyword\">day</span><span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">of</span><span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">month</span> 日(<span class=\"hljs-number\">01</span><span class=\"hljs-number\">-31</span>)\n# <span class=\"hljs-keyword\">month</span><span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">of</span><span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">year</span> 月(<span class=\"hljs-number\">01</span><span class=\"hljs-number\">-12</span>)\n# <span class=\"hljs-keyword\">day</span><span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">of</span><span class=\"hljs-operator\">-</span>week 周(<span class=\"hljs-number\">0</span><span class=\"hljs-number\">-6</span>)\n# commands 执行命令\n</code></pre>\n<p>参数除了填写数字还可以写特殊符号：</p>\n<ol>\n<li>*:所有数字组合（也可以认为不限制）</li>\n<li>/:每（一般*/5表示每5个单位时间）</li>\n<li>-:范围数字组合 </li>\n<li>,:多条件组合</li>\n</ol>\n<h1 id=\"menu_3\">编写简单的执行脚本</h1><p>比如清理Oracle垃圾数据（先写一个清理的脚本clear.sh）：</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\">#!/bin/bash</span>\nrm -rf /*/oracle/diag/rdbms/trace/*\nrm -rf /*/oracle/diag/rdbms/alert/*\n</code></pre>\n<h1 id=\"menu_4\">配置命令</h1><p>Crontab命令的配置是写在/etc/crontab文件中</p>\n<p><strong>vi /etc/crontab</strong></p>\n<p>可以看到里面或许已存在一些已有任务。</p>\n<p>Crontab命令简单实例：</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-section\">#以下实例基本涵盖了大部分使用场景</span>\n<span class=\"hljs-section\">#早上6点执行清理</span>\n0 6 <span class=\"hljs-emphasis\">* *</span> <span class=\"hljs-emphasis\">* sh /home/oracle/task/clear.sh \n#每8小时执行清理\n0 *</span>/8 <span class=\"hljs-emphasis\">* *</span> <span class=\"hljs-emphasis\">* sh /home/oracle/task/clear.sh\n#晚11至早6点每两小时执行清理以及早六点执行清理\n0 23-5/2,6 *</span> <span class=\"hljs-emphasis\">* *</span> sh /home/oracle/task/clear.sh\n<span class=\"hljs-section\">#周三/周日早六点执行清理</span>\n0 6 <span class=\"hljs-emphasis\">* *</span> 3,0 sh /home/oracle/task/clear.sh \n</code></pre>\n<h1 id=\"menu_5\">生效方式</h1><p>在**/etc/crontab**中正确配置保存后即可生效。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">需求描述</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">命令配置语法格式</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">编写简单的执行脚本</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">配置命令</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">生效方式</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1005, '# 为什么要使用渐变色\n\n当今越来越注重UI交互的互联网时代，用户体验越来越被重视。\n\n网页设计中，使用渐变得设计效果不仅仅可以达到醒目的效果，同时可以增强网页的质感。\n\n如下图按钮的对比：\n\n\n![/static/upload/post/1645053284471.jpg](/static/upload/post/1645053284471.jpg)\n\n\n# 渐变背景实现\n\nCSS3中可以通过渐变（gradients属性）实现两个或多个指定的颜色之间平滑过渡。\n\nCSS3以前，你需要通过配置一个渐变得背景图像来实现这些效果。\n\n使用渐变效果的元素在放大时看起来效果不会有任何失真，因为渐变（gradient）是由浏览器生成的。\n\n最重要的是，如果需要调整背景效果可以直接修改CSS样式，而不是更改图片那样麻烦。\n\n# gradients属性\n\ngradients属性有两种主要的配置：\n\n - linear-gradient（线性渐变）：向下/向上/向左/向右/对角方向（可以指定角度）\n - radial-gradient（径向渐变）：由中心向周围\n\n拓展属性：\n\n- repeating-linear-gradient：重复的线性渐变\n- repeating-radial-gradient：重复的径向渐变\n\n# gradients语法\n\n```css\n/*gradients可以配置在background-image也可以配置在background*/\n/*background: linear-gradient(direction, color1, color2, ...);*/\n/*一般推荐配置在background-image，当有多个样式重叠，默认覆盖background*/\nbackground-image: linear-gradient(direction/angle, color1, color2, ...);\n```\n\n- direction/angle：选用，可以是关键词，也可以是角度\n- color：支持快捷色（如：red）、16进制色号、RGB和RGBA（透明色）\n\n## 基本语法\n\n```css\n/*默认自上向下的渐变*/\nbackground-image: linear-gradient(red , yellow);\n/*配置自左向右的渐变*/\nbackground-image: linear-gradient(to right, red , yellow);\n/*配置对角线渐变*/\nbackground-image: linear-gradient(to bottom right, red, yellow,blue);\n/*配置角度的渐变色*/\n/*角度范围：-90到90*/\nbackground-image: linear-gradient(45deg, red, yellow);\n/*配置一个彩虹渐变*/\n/*理论上来说可以支持无限个颜色*/\nbackground-image: linear-gradient(to right,red,orange,yellow,green,blue,indigo,violet);\n/*透明渐变色，制作一个透明渐变遮罩*/\nbackground-image: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0.8));\n```\n\n## 增强语法配置\n\n```css\n/*控制颜色显示的范围*/\n/*这里颜色的百分比之和不规定是100%*/\nbackground-image: linear-gradient(red 5%, yellow 5%, green 20%,blue 70%);\n/*如果颜色范围超出100%，表示颜色产生重叠，重叠部分可能会失去渐变过渡*/\n/*直接是两种颜色分割的效果，类似：斑马线*/\nbackground-image: linear-gradient(red 15%, yellow 15%, green 30%,blue 90%);\n/*可以只配置某些具体的颜色范围*/\nbackground-image: linear-gradient(red , yellow 15%, green 20%,blue);\n```\n\n## radial-gradient特定语法\n\nlinear-gradient的所有语法都适用于radial-gradient。\n\n但radial-gradient有一个特定的语法用于定义中心点的位置。\n\n - cover：覆盖\n - contain：包含\n - closest-side：最近端\n - farthest-side：最远的端\n - closest-corner：最近的角\n - farthest-corner：最远的角落\n\n```css\n/*通过调整%自由修改径向渐变得中心点位置*/\nbackground-image: radial-gradient(closest-side at 50% 50%, red, yellow);\n```', '<h1 id=\"menu_1\">为什么要使用渐变色</h1><p>当今越来越注重UI交互的互联网时代，用户体验越来越被重视。</p>\n<p>网页设计中，使用渐变得设计效果不仅仅可以达到醒目的效果，同时可以增强网页的质感。</p>\n<p>如下图按钮的对比：</p>\n<p><img src=\"/static/upload/post/1645053284471.jpg\" alt=\"/static/upload/post/1645053284471.jpg\"/></p>\n<h1 id=\"menu_2\">渐变背景实现</h1><p>CSS3中可以通过渐变（gradients属性）实现两个或多个指定的颜色之间平滑过渡。</p>\n<p>CSS3以前，你需要通过配置一个渐变得背景图像来实现这些效果。</p>\n<p>使用渐变效果的元素在放大时看起来效果不会有任何失真，因为渐变（gradient）是由浏览器生成的。</p>\n<p>最重要的是，如果需要调整背景效果可以直接修改CSS样式，而不是更改图片那样麻烦。</p>\n<h1 id=\"menu_3\">gradients属性</h1><p>gradients属性有两种主要的配置：</p>\n<ul>\n<li>linear-gradient（线性渐变）：向下/向上/向左/向右/对角方向（可以指定角度）</li>\n<li>radial-gradient（径向渐变）：由中心向周围</li>\n</ul>\n<p>拓展属性：</p>\n<ul>\n<li>repeating-linear-gradient：重复的线性渐变</li>\n<li>repeating-radial-gradient：重复的径向渐变</li>\n</ul>\n<h1 id=\"menu_4\">gradients语法</h1><pre><code class=\"hljs language-css\"><span class=\"hljs-comment\">/*gradients可以配置在background-image也可以配置在background*/</span>\n<span class=\"hljs-comment\">/*background: linear-gradient(direction, color1, color2, ...);*/</span>\n<span class=\"hljs-comment\">/*一般推荐配置在background-image，当有多个样式重叠，默认覆盖background*/</span>\n<span class=\"hljs-attribute\">background-image</span>: linear-gradient(direction/angle, <span class=\"hljs-attribute\">color</span>1, <span class=\"hljs-attribute\">color</span>2, ...);\n</code></pre>\n<ul>\n<li>direction/angle：选用，可以是关键词，也可以是角度</li>\n<li>color：支持快捷色（如：red）、16进制色号、RGB和RGBA（透明色）</li>\n</ul>\n<h2 id=\"menu_5\">基本语法</h2><pre><code class=\"hljs language-css\"><span class=\"hljs-comment\">/*默认自上向下的渐变*/</span>\n<span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">linear-gradient</span>(red , yellow);\n<span class=\"hljs-comment\">/*配置自左向右的渐变*/</span>\n<span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">linear-gradient</span>(to right, red , yellow);\n<span class=\"hljs-comment\">/*配置对角线渐变*/</span>\n<span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">linear-gradient</span>(to bottom right, red, yellow,blue);\n<span class=\"hljs-comment\">/*配置角度的渐变色*/</span>\n<span class=\"hljs-comment\">/*角度范围：-90到90*/</span>\n<span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">linear-gradient</span>(<span class=\"hljs-number\">45deg</span>, red, yellow);\n<span class=\"hljs-comment\">/*配置一个彩虹渐变*/</span>\n<span class=\"hljs-comment\">/*理论上来说可以支持无限个颜色*/</span>\n<span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">linear-gradient</span>(to right,red,orange,yellow,green,blue,indigo,violet);\n<span class=\"hljs-comment\">/*透明渐变色，制作一个透明渐变遮罩*/</span>\n<span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">linear-gradient</span>(<span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0.8</span>));\n</code></pre>\n<h2 id=\"menu_6\">增强语法配置</h2><pre><code class=\"hljs language-css\"><span class=\"hljs-comment\">/*控制颜色显示的范围*/</span>\n<span class=\"hljs-comment\">/*这里颜色的百分比之和不规定是100%*/</span>\n<span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">linear-gradient</span>(red <span class=\"hljs-number\">5%</span>, yellow <span class=\"hljs-number\">5%</span>, green <span class=\"hljs-number\">20%</span>,blue <span class=\"hljs-number\">70%</span>);\n<span class=\"hljs-comment\">/*如果颜色范围超出100%，表示颜色产生重叠，重叠部分可能会失去渐变过渡*/</span>\n<span class=\"hljs-comment\">/*直接是两种颜色分割的效果，类似：斑马线*/</span>\n<span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">linear-gradient</span>(red <span class=\"hljs-number\">15%</span>, yellow <span class=\"hljs-number\">15%</span>, green <span class=\"hljs-number\">30%</span>,blue <span class=\"hljs-number\">90%</span>);\n<span class=\"hljs-comment\">/*可以只配置某些具体的颜色范围*/</span>\n<span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">linear-gradient</span>(red , yellow <span class=\"hljs-number\">15%</span>, green <span class=\"hljs-number\">20%</span>,blue);\n</code></pre>\n<h2 id=\"menu_7\">radial-gradient特定语法</h2><p>linear-gradient的所有语法都适用于radial-gradient。</p>\n<p>但radial-gradient有一个特定的语法用于定义中心点的位置。</p>\n<ul>\n<li>cover：覆盖</li>\n<li>contain：包含</li>\n<li>closest-side：最近端</li>\n<li>farthest-side：最远的端</li>\n<li>closest-corner：最近的角</li>\n<li>farthest-corner：最远的角落</li>\n</ul>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-comment\">/*通过调整%自由修改径向渐变得中心点位置*/</span>\n<span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">radial-gradient</span>(closest-side at <span class=\"hljs-number\">50%</span> <span class=\"hljs-number\">50%</span>, red, yellow);\n</code></pre>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">为什么要使用渐变色</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">渐变背景实现</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">gradients属性</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">gradients语法</a> <ul><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">基本语法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">增强语法配置</a> <!----></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">radial-gradient特定语法</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1006, '# 关于Beyond Compare\n\n懂的都懂\n\n文件/文件夹对比神器，超专业的对比工具\n\n - 支持任意格式的文件互相对比\n - 支持任意目录互相对比\n - 支持多种规则的对比（二进制、规则对比）\n - 支持快速互相替换和拷贝\n - 等......总之很好用的一款工具\n\n唯一的缺点么？商用收费软件。\n\n# 默认试用\n\nBeyond Compare默认提供30天评估试用期，这里的30天不是日期的30天。\n\n而是某一天打开了算1天，比如1号、3号、5号这三天打开用过，只算3天。\n\n30天评估试用期过后，如果一直不够买授权，将在15天过后无法打开。\n\n所以整体来说是：30次/天+15天。\n\n![/static/upload/post/1645055892736.png](/static/upload/post/1645055892736.png)\n\n![/static/upload/post/1645055897010.png](/static/upload/post/1645055897010.png)\n\n\n# 继续使用的办法\n\n## 重新安装（不推荐）\n\n卸载再安装，似乎会重新开始试用。\n\n这个问题不知道在新的版本会不会被修复。\n\n无论是否会被修复，终归是很麻烦的事情。\n\n## 修改BCUnrar.dll（续期30天）\n\n修改安装路径下的BCUnrar.dll文件，只需要改个名字即可，像下图：\n\n\n![/static/upload/post/1645055944822.png](/static/upload/post/1645055944822.png)\n\n\n这样修改后只是增加30天的评估期，依旧会进入倒计时。\n\n但是在第二次修改的时候可能会不生效。\n\n## 修改注册表\n\n1. 在搜索栏中（win+R 键）输入 regedit ，打开注册表\n2. HKEY_CURRENT_USERSoftwareScooter SoftwareBeyond Compare 4\n3. 删掉CacheId\n\n\n![/static/upload/post/1645055958080.png](/static/upload/post/1645055958080.png)\n\n\n依旧提示运行在评估版本，但是不再提示确认了，可以继续使用。\n\n\n![/static/upload/post/1645055966869.png](/static/upload/post/1645055966869.png)\n\n\n', '<h1 id=\"menu_1\">关于Beyond Compare</h1><p>懂的都懂</p>\n<p>文件/文件夹对比神器，超专业的对比工具</p>\n<ul>\n<li>支持任意格式的文件互相对比</li>\n<li>支持任意目录互相对比</li>\n<li>支持多种规则的对比（二进制、规则对比）</li>\n<li>支持快速互相替换和拷贝</li>\n<li>等......总之很好用的一款工具</li>\n</ul>\n<p>唯一的缺点么？商用收费软件。</p>\n<h1 id=\"menu_2\">默认试用</h1><p>Beyond Compare默认提供30天评估试用期，这里的30天不是日期的30天。</p>\n<p>而是某一天打开了算1天，比如1号、3号、5号这三天打开用过，只算3天。</p>\n<p>30天评估试用期过后，如果一直不够买授权，将在15天过后无法打开。</p>\n<p>所以整体来说是：30次/天+15天。</p>\n<p><img src=\"/static/upload/post/1645055892736.png\" alt=\"/static/upload/post/1645055892736.png\"/></p>\n<p><img src=\"/static/upload/post/1645055897010.png\" alt=\"/static/upload/post/1645055897010.png\"/></p>\n<h1 id=\"menu_3\">继续使用的办法</h1><h2 id=\"menu_4\">重新安装（不推荐）</h2><p>卸载再安装，似乎会重新开始试用。</p>\n<p>这个问题不知道在新的版本会不会被修复。</p>\n<p>无论是否会被修复，终归是很麻烦的事情。</p>\n<h2 id=\"menu_5\">修改BCUnrar.dll（续期30天）</h2><p>修改安装路径下的BCUnrar.dll文件，只需要改个名字即可，像下图：</p>\n<p><img src=\"/static/upload/post/1645055944822.png\" alt=\"/static/upload/post/1645055944822.png\"/></p>\n<p>这样修改后只是增加30天的评估期，依旧会进入倒计时。</p>\n<p>但是在第二次修改的时候可能会不生效。</p>\n<h2 id=\"menu_6\">修改注册表</h2><ol>\n<li>在搜索栏中（win+R 键）输入 regedit ，打开注册表</li>\n<li>HKEY_CURRENT_USERSoftwareScooter SoftwareBeyond Compare 4</li>\n<li>删掉CacheId</li>\n</ol>\n<p><img src=\"/static/upload/post/1645055958080.png\" alt=\"/static/upload/post/1645055958080.png\"/></p>\n<p>依旧提示运行在评估版本，但是不再提示确认了，可以继续使用。</p>\n<p><img src=\"/static/upload/post/1645055966869.png\" alt=\"/static/upload/post/1645055966869.png\"/></p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">关于Beyond Compare</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">默认试用</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">继续使用的办法</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">重新安装（不推荐）</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">修改BCUnrar.dll（续期30天）</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">修改注册表</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1007, '# 关于Servlet\n\nJAVA Servlet 是运行在 Web 服务器或应用服务器上的程序。\n\nServlet 是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。\n\nServlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。\n\n但是相比于 CGI，Servlet 有以下几点优势：\n\n - 性能明显更好。\n - 在Web服务器的地址空间内执行，无需创建进程来处理每个客户端请求\n - 独立于平台的， JAVA编写的。\n - 安全可信的， 安全管理器执行了一系列限制，以保护服务器计算机上的资源\n - JAVA类库的全部功能对 Servlet 来说都是可用的。\n\n# 关于生命周期\n\n一个Java对象从最初被创建，到最后被销毁，所经历的完整过程，认为是其的生命周期。\n\n生命周期大致分为三个阶段：初始化阶段、运行时阶段、销毁阶段。\n\nServlet对象从最初的创建，方法的调用，以及对象的销毁，都是由web容器（Web Container）管理的（如Tomcat）。\n\n默认情况下，Servlet对象在web服务器启动阶段中不会被实例化，若需要启动时实例化，则需要特殊的配置（如：load-on-startup）\n\n## 初始化阶段\n\n1. Servlet容器会加载Servlet类，把它的.class文件中的数据加载到内存储中\n2. Servlet容器会创建ServletConfig对象，该对象包含了特点的Servlet的初始化配置信息\n3. Servlet容器创建Servlet对象，然后容器调用该对象的init(ServletConfig config) 方法\n4. 每个Servlet对象都有一个与之关联的ServletConfig类对象，ServletConfig对象都会与当前Java web应用的ServletContext对象关联\n5. 每个Servlet对象的init(ServletConfig config) 方法,在其生命周期内只会被调用一次\n\n### init()\n\n - Servlet的生命周期中，仅执行一次init()方法\n - 在服务器装入Servlet时执行的，负责初始化Servlet对象\n - 可以配置服务器，在启动服务器或客户机首次访问Servlet时装入Servlet\n - 无论多少客户访问Servlet，都不会重复执行init()\n\n## 运行时阶段\n\n1. Servlet容器接收到客户端要求访问特定的Servlet时，Servlet容器会针对该请求创建ServletRequest对象和ServletResponse对象\n2. 调用相关的Servlet对象的service()方法，当一个请求被接收/处理，再通过ServletResponse对象将响应结果返回给客户端\n3. 对应的ServletResponse对象和ServletRequest对象便会被Servlet容器销毁\n\n### service()\n\n - Servlet的核心，负责响应客户的请求\n - 当请求一个HttpServlet对象，该对象的Service()方法就要调用，而且传递给这个方法ServletRequest对象和ServletResponse对象作为参数\n - HttpServlet中已存在Service()方法，默认的服务功能是调用与HTTP请求的方法相应的do功能\n\n## 销毁阶段\n\n1. 当Java web应用被终止时，Servlet容器会调用所有Servlet对象的destroy()方法（释放Servlet对象所占用的资源）\n2. 再销毁这些Servlet对象以及和它关联的ServletConfig对象\n\n### destroy()\n\n - 仅执行一次，在服务器端停止且卸载Servlet时执行该方法\n - Servlet对象退出生命周期时，负责释放占用的资源\n - 一个Servlet在运行service()方法时可能会产生其他的线程，因此需要确认在调用destroy()方法时，这些线程已经终止或完成\n\n# 概述Servlet对象生命周期\n\n1. 用户在浏览器地址栏输入URL\n2. web容器截取请求路径（容器上下文中寻找请求路径）\n3. 通过web.xml文件中的相关配置信息找到请求路径\n4. 通过反射机制，调用servlet的无参构造方法完成servlet对象的实例化\n5. web容器调用servlet的init()方法完成初始化操作\n6. web容器调用servlet的service()方法提供服务\n7. 找到对应的servlet对象\n8. web容器直接调用servlet的service()方法提供服务\n9. web容器关闭的时候、webapp重新部署的时候、servlet对象长时间无用户再次访问时，web容器会将该servlet对象销毁\n10. 销毁前，web容器会调用servlet的destroy()方法，完成销毁之前的准备\n\n# 自定义Servlet注意事项\n\n当客户发送一个请求，Servlet是调用service()方法对请求进行响应的。\n\n通过源代码可见，service()方法中对请求的方式进行了匹配，选择调用doGet、doPost等这些方法。\n\n再进入对应的方法中调用逻辑层的方法，实现对客户的响应。\n\n在Servlet接口和GenericServlet中是没有doGet()、doPost()等这些方法的，HttpServlet中定义了这些方法，但是都是返回error信息。\n\n所以我们自定义Servlet的时候，**都必须实现doGet()、doPost()等这些方法**。\n\n自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是上文提到的init(),service(),destroy()方法。\n\n - GenericServlet是一个通用的，不特定于任何协议的Servlet,它实现了Servlet接口\n - HttpServlet继承GenericServlet，因此HttpServlet也实现了Servlet接口\n \n所以一般自定义Servlet的时候只需要继承HttpServlet即可。\n\nServlet接口和GenericServlet是不特定于任何协议的，而HttpServlet是特定于HTTP协议的类。\n\n所以HttpServlet中实现了service()方法，并将请求ServletRequest、ServletResponse强转为HttpRequest、HttpResponse。\n\n# Tomcat与Servlet是如何工作\n\n与上方过程基本一致：\n\n1. Web Client向Servlet容器（Tomcat）发出Http请求\n2. Servlet容器接收Web Client的请求\n3. Servlet容器创建一个HttpRequest对象并将Web Client请求的信息封装到这个对象中\n4. Servlet容器创建一个HttpResponse对象\n5. Servlet容器调用HttpServlet对象的service方法，把HttpRequest对象与HttpResponse对象作为参数传给HttpServlet对象\n6. HttpServlet调用HttpRequest对象的有关方法（doGet()、doPost()等），获取Http请求信息\n7. HttpServlet调用HttpResponse对象的有关方法（doGet()、doPost()等），生成响应数据\n8. Servlet容器把HttpServlet的响应结果传给Web Client', '<h1 id=\"menu_1\">关于Servlet</h1><p>JAVA Servlet 是运行在 Web 服务器或应用服务器上的程序。</p>\n<p>Servlet 是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p>\n<p>Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。</p>\n<p>但是相比于 CGI，Servlet 有以下几点优势：</p>\n<ul>\n<li>性能明显更好。</li>\n<li>在Web服务器的地址空间内执行，无需创建进程来处理每个客户端请求</li>\n<li>独立于平台的， JAVA编写的。</li>\n<li>安全可信的， 安全管理器执行了一系列限制，以保护服务器计算机上的资源</li>\n<li>JAVA类库的全部功能对 Servlet 来说都是可用的。</li>\n</ul>\n<h1 id=\"menu_2\">关于生命周期</h1><p>一个Java对象从最初被创建，到最后被销毁，所经历的完整过程，认为是其的生命周期。</p>\n<p>生命周期大致分为三个阶段：初始化阶段、运行时阶段、销毁阶段。</p>\n<p>Servlet对象从最初的创建，方法的调用，以及对象的销毁，都是由web容器（Web Container）管理的（如Tomcat）。</p>\n<p>默认情况下，Servlet对象在web服务器启动阶段中不会被实例化，若需要启动时实例化，则需要特殊的配置（如：load-on-startup）</p>\n<h2 id=\"menu_3\">初始化阶段</h2><ol>\n<li>Servlet容器会加载Servlet类，把它的.class文件中的数据加载到内存储中</li>\n<li>Servlet容器会创建ServletConfig对象，该对象包含了特点的Servlet的初始化配置信息</li>\n<li>Servlet容器创建Servlet对象，然后容器调用该对象的init(ServletConfig config) 方法</li>\n<li>每个Servlet对象都有一个与之关联的ServletConfig类对象，ServletConfig对象都会与当前Java web应用的ServletContext对象关联</li>\n<li>每个Servlet对象的init(ServletConfig config) 方法,在其生命周期内只会被调用一次</li>\n</ol>\n<h3 id=\"menu_4\">init()</h3><ul>\n<li>Servlet的生命周期中，仅执行一次init()方法</li>\n<li>在服务器装入Servlet时执行的，负责初始化Servlet对象</li>\n<li>可以配置服务器，在启动服务器或客户机首次访问Servlet时装入Servlet</li>\n<li>无论多少客户访问Servlet，都不会重复执行init()</li>\n</ul>\n<h2 id=\"menu_5\">运行时阶段</h2><ol>\n<li>Servlet容器接收到客户端要求访问特定的Servlet时，Servlet容器会针对该请求创建ServletRequest对象和ServletResponse对象</li>\n<li>调用相关的Servlet对象的service()方法，当一个请求被接收/处理，再通过ServletResponse对象将响应结果返回给客户端</li>\n<li>对应的ServletResponse对象和ServletRequest对象便会被Servlet容器销毁</li>\n</ol>\n<h3 id=\"menu_6\">service()</h3><ul>\n<li>Servlet的核心，负责响应客户的请求</li>\n<li>当请求一个HttpServlet对象，该对象的Service()方法就要调用，而且传递给这个方法ServletRequest对象和ServletResponse对象作为参数</li>\n<li>HttpServlet中已存在Service()方法，默认的服务功能是调用与HTTP请求的方法相应的do功能</li>\n</ul>\n<h2 id=\"menu_7\">销毁阶段</h2><ol>\n<li>当Java web应用被终止时，Servlet容器会调用所有Servlet对象的destroy()方法（释放Servlet对象所占用的资源）</li>\n<li>再销毁这些Servlet对象以及和它关联的ServletConfig对象</li>\n</ol>\n<h3 id=\"menu_8\">destroy()</h3><ul>\n<li>仅执行一次，在服务器端停止且卸载Servlet时执行该方法</li>\n<li>Servlet对象退出生命周期时，负责释放占用的资源</li>\n<li>一个Servlet在运行service()方法时可能会产生其他的线程，因此需要确认在调用destroy()方法时，这些线程已经终止或完成</li>\n</ul>\n<h1 id=\"menu_9\">概述Servlet对象生命周期</h1><ol>\n<li>用户在浏览器地址栏输入URL</li>\n<li>web容器截取请求路径（容器上下文中寻找请求路径）</li>\n<li>通过web.xml文件中的相关配置信息找到请求路径</li>\n<li>通过反射机制，调用servlet的无参构造方法完成servlet对象的实例化</li>\n<li>web容器调用servlet的init()方法完成初始化操作</li>\n<li>web容器调用servlet的service()方法提供服务</li>\n<li>找到对应的servlet对象</li>\n<li>web容器直接调用servlet的service()方法提供服务</li>\n<li>web容器关闭的时候、webapp重新部署的时候、servlet对象长时间无用户再次访问时，web容器会将该servlet对象销毁</li>\n<li>销毁前，web容器会调用servlet的destroy()方法，完成销毁之前的准备</li>\n</ol>\n<h1 id=\"menu_10\">自定义Servlet注意事项</h1><p>当客户发送一个请求，Servlet是调用service()方法对请求进行响应的。</p>\n<p>通过源代码可见，service()方法中对请求的方式进行了匹配，选择调用doGet、doPost等这些方法。</p>\n<p>再进入对应的方法中调用逻辑层的方法，实现对客户的响应。</p>\n<p>在Servlet接口和GenericServlet中是没有doGet()、doPost()等这些方法的，HttpServlet中定义了这些方法，但是都是返回error信息。</p>\n<p>所以我们自定义Servlet的时候，<strong>都必须实现doGet()、doPost()等这些方法</strong>。</p>\n<p>自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是上文提到的init(),service(),destroy()方法。</p>\n<ul>\n<li>GenericServlet是一个通用的，不特定于任何协议的Servlet,它实现了Servlet接口</li>\n<li>HttpServlet继承GenericServlet，因此HttpServlet也实现了Servlet接口</li>\n</ul>\n<p>所以一般自定义Servlet的时候只需要继承HttpServlet即可。</p>\n<p>Servlet接口和GenericServlet是不特定于任何协议的，而HttpServlet是特定于HTTP协议的类。</p>\n<p>所以HttpServlet中实现了service()方法，并将请求ServletRequest、ServletResponse强转为HttpRequest、HttpResponse。</p>\n<h1 id=\"menu_11\">Tomcat与Servlet是如何工作</h1><p>与上方过程基本一致：</p>\n<ol>\n<li>Web Client向Servlet容器（Tomcat）发出Http请求</li>\n<li>Servlet容器接收Web Client的请求</li>\n<li>Servlet容器创建一个HttpRequest对象并将Web Client请求的信息封装到这个对象中</li>\n<li>Servlet容器创建一个HttpResponse对象</li>\n<li>Servlet容器调用HttpServlet对象的service方法，把HttpRequest对象与HttpResponse对象作为参数传给HttpServlet对象</li>\n<li>HttpServlet调用HttpRequest对象的有关方法（doGet()、doPost()等），获取Http请求信息</li>\n<li>HttpServlet调用HttpResponse对象的有关方法（doGet()、doPost()等），生成响应数据</li>\n<li>Servlet容器把HttpServlet的响应结果传给Web Client</li>\n</ol>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">关于Servlet</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">关于生命周期</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">初始化阶段</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl3\">init()</a></li></ul></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">运行时阶段</a> <ul><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl3\">service()</a></li></ul></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">销毁阶段</a> <ul><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl3\">destroy()</a></li></ul></li></ul></li><li><a href=\"javascript:runTo(\'menu_9\')\" class=\"pl1\">概述Servlet对象生命周期</a> <!----></li><li><a href=\"javascript:runTo(\'menu_10\')\" class=\"pl1\">自定义Servlet注意事项</a> <!----></li><li><a href=\"javascript:runTo(\'menu_11\')\" class=\"pl1\">Tomcat与Servlet是如何工作</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1008, '# instantclick.js加速原理\n\ninstantclick.js利用用户点击链接或者悬浮在链接上的时候，对新页面进行预加载。\n\n使得访问新页面的时候能够实现更快速度打开甚至秒开的情况，对于用户体验有着极大的提升。\n\ninstantclick.js在页面跳转时通过对body体和title替换进行快速加载。\n\n因此这将意味着你的网页并不是真正的跳转到那个新的页面。\n\n所以如果你的新页面中定义了一些**DOMContentLoaded或jQuery.ready()触发的初始化动作都不会进行执行**。\n\n当然可以通过instantclick.js提供的监听事件来解决这个问题。\n\n# 顶部进度条\n\ninstantclick.js在用户点击链接的时候，预置了一个顶部的加载条。\n\n当然了，这个进度条进度条是假的，只是让用户意识到将要发生页面的跳转。\n\n默认情况，进度条的颜色是#29d，可以用CSS改变配色。\n\n```css    \n#instantclick-bar\n{\n	background: white;\n}\n/*可以消失*/\n#instantclick \n{\n	display: none;\n}\n```\n\n# 加速方案\n\ninstantclick.js提供了多种预加载的方案，需要根据您的网站场景进行选择。\n\n1. **悬停预加载**：on mouseover (hover)默认方案 \n	鼠标移到超链接上就进行预加载，如果页面内容不是特别多，用户点击链接进入文章会立即显示。\n	传说中的秒开就可以通过此模式实现。\n2. **点击瞬间预加载**：on mousedown\n	在用户鼠标点击的瞬间来预加载页面，有不错的速度提升。\n3. **悬停延时预加载**： on mouseover with a delay\n	如果用户将鼠标悬停你的超链接后，instantclick.js将根据你设置的时间延迟预加载。\n	建议延迟是100ms和50ms。\n	超过100ms实际上可能比on mousedown慢，小于50ms和on mouseover (hover)几乎无差异。      \n\n关于加速模式的选择主要根据服务器所能接受的开销能力选择即可。\n\n# 预加速案例\n\n首先，需要下载一个instantclick.js到您网站本地。\n\n下载地址：[http://instantclick.io/download](http://instantclick.io/download)\n\n```html\n<!-- 引入JS -->\n<script src=\"js/instantclick.min.js\"></script>\n<!-- data-no-instant表示该标签不进行预加载 -->\n<script data-no-instant>\n//选择点击瞬间预加载模式\nInstantClick.init(\"mousedown\");\n</script>\n```\n\n## 事件监听预回调\n\ninstantclick.js提供了4个事件用于进行调用开发。\n\n - change：页面更改完毕，即click触发\n - fetch：页面开始预加载\n - receive：页面预加载完毕，hover或mousedown触发的预加载，但不一定会change，因为用户不一定click\n - wait：用户点击一个链接，但是还没有加载的页面，只有立即触发页面时不显示\n\n这里比较常用的是change事件，前文中提到instantclick.js会使得一些新页面中定义的初始化JS操作失效，通过change就可以达到兼容。\n\n```html\n<script data-no-instant>\nInstantClick.on(\"change\", function() {\n	//比如新页面有个初始化表单数据的方法\n	initFormNumber();\n});\nInstantClick.init();\n</script>\n```\n\n## 特殊属性申明\n\n**data-no-instant：黑名单**\n	黑名单的链接，添加一个data-no-instant属性，表示该页面不需要预加载\n\n```html\n<a href=\"logOut.html\" data-no-instant>注销登录</a>\n```\n\n如果页面有区域的多个链接都不需要预加载，可以通过指定父级标签方式实现。\n\n```html\n<div class=\"conf\" data-no-instant>\n	<a href=\"logOut.html\">注销登录</a>\n	<a href=\"changePwd.html\">修改密码</a>\n</div>\n```\n\n**data-instant：白名单**\n	这个与黑名单相反，属于指明一定需要预加载的链接。\n	白名单优先级高于黑名单。\n\n```html\n<div class=\"conf\" data-no-instant>\n	<!-- 注销登录链接的预加载依旧生效 -->\n	<a href=\"maps.html\" data-instan>全站地图</a>\n	<a href=\"changePwd.html\">修改密码</a>\n</div>\n```', '<h1 id=\"menu_1\">instantclick.js加速原理</h1><p>instantclick.js利用用户点击链接或者悬浮在链接上的时候，对新页面进行预加载。</p>\n<p>使得访问新页面的时候能够实现更快速度打开甚至秒开的情况，对于用户体验有着极大的提升。</p>\n<p>instantclick.js在页面跳转时通过对body体和title替换进行快速加载。</p>\n<p>因此这将意味着你的网页并不是真正的跳转到那个新的页面。</p>\n<p>所以如果你的新页面中定义了一些<strong>DOMContentLoaded或jQuery.ready()触发的初始化动作都不会进行执行</strong>。</p>\n<p>当然可以通过instantclick.js提供的监听事件来解决这个问题。</p>\n<h1 id=\"menu_2\">顶部进度条</h1><p>instantclick.js在用户点击链接的时候，预置了一个顶部的加载条。</p>\n<p>当然了，这个进度条进度条是假的，只是让用户意识到将要发生页面的跳转。</p>\n<p>默认情况，进度条的颜色是#29d，可以用CSS改变配色。</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-id\">#instantclick-bar</span>\n{\n    <span class=\"hljs-attribute\">background</span>: white;\n}\n<span class=\"hljs-comment\">/*可以消失*/</span>\n<span class=\"hljs-selector-id\">#instantclick</span> \n{\n    <span class=\"hljs-attribute\">display</span>: none;\n}\n</code></pre>\n<h1 id=\"menu_3\">加速方案</h1><p>instantclick.js提供了多种预加载的方案，需要根据您的网站场景进行选择。</p>\n<ol>\n<li><strong>悬停预加载</strong>：on mouseover (hover)默认方案<br/> 鼠标移到超链接上就进行预加载，如果页面内容不是特别多，用户点击链接进入文章会立即显示。<br/> 传说中的秒开就可以通过此模式实现。</li>\n<li><strong>点击瞬间预加载</strong>：on mousedown<br/> 在用户鼠标点击的瞬间来预加载页面，有不错的速度提升。</li>\n<li><strong>悬停延时预加载</strong>： on mouseover with a delay<br/> 如果用户将鼠标悬停你的超链接后，instantclick.js将根据你设置的时间延迟预加载。<br/> 建议延迟是100ms和50ms。<br/> 超过100ms实际上可能比on mousedown慢，小于50ms和on mouseover (hover)几乎无差异。      </li>\n</ol>\n<p>关于加速模式的选择主要根据服务器所能接受的开销能力选择即可。</p>\n<h1 id=\"menu_4\">预加速案例</h1><p>首先，需要下载一个instantclick.js到您网站本地。</p>\n<p>下载地址：<a class=\"mlink\" href=\"http://instantclick.io/download\" title=\"http://instantclick.io/download\" target=\"_blank\">http://instantclick.io/download</a></p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&lt;!-- 引入JS --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;js/instantclick.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- data-no-instant表示该标签不进行预加载 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">data-no-instant</span>&gt;</span><span class=\"language-javascript\">\n<span class=\"hljs-comment\">//选择点击瞬间预加载模式</span>\n<span class=\"hljs-title class_\">InstantClick</span>.<span class=\"hljs-title function_\">init</span>(<span class=\"hljs-string\">&quot;mousedown&quot;</span>);\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<h2 id=\"menu_5\">事件监听预回调</h2><p>instantclick.js提供了4个事件用于进行调用开发。</p>\n<ul>\n<li>change：页面更改完毕，即click触发</li>\n<li>fetch：页面开始预加载</li>\n<li>receive：页面预加载完毕，hover或mousedown触发的预加载，但不一定会change，因为用户不一定click</li>\n<li>wait：用户点击一个链接，但是还没有加载的页面，只有立即触发页面时不显示</li>\n</ul>\n<p>这里比较常用的是change事件，前文中提到instantclick.js会使得一些新页面中定义的初始化JS操作失效，通过change就可以达到兼容。</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">data-no-instant</span>&gt;</span><span class=\"language-javascript\">\n<span class=\"hljs-title class_\">InstantClick</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;change&quot;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">//比如新页面有个初始化表单数据的方法</span>\n    <span class=\"hljs-title function_\">initFormNumber</span>();\n});\n<span class=\"hljs-title class_\">InstantClick</span>.<span class=\"hljs-title function_\">init</span>();\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<h2 id=\"menu_6\">特殊属性申明</h2><p><strong>data-no-instant：黑名单</strong><br/>    黑名单的链接，添加一个data-no-instant属性，表示该页面不需要预加载</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;logOut.html&quot;</span> <span class=\"hljs-attr\">data-no-instant</span>&gt;</span>注销登录<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n</code></pre>\n<p>如果页面有区域的多个链接都不需要预加载，可以通过指定父级标签方式实现。</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;conf&quot;</span> <span class=\"hljs-attr\">data-no-instant</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;logOut.html&quot;</span>&gt;</span>注销登录<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;changePwd.html&quot;</span>&gt;</span>修改密码<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<p><strong>data-instant：白名单</strong><br/>    这个与黑名单相反，属于指明一定需要预加载的链接。<br/>    白名单优先级高于黑名单。</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;conf&quot;</span> <span class=\"hljs-attr\">data-no-instant</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 注销登录链接的预加载依旧生效 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;maps.html&quot;</span> <span class=\"hljs-attr\">data-instan</span>&gt;</span>全站地图<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;changePwd.html&quot;</span>&gt;</span>修改密码<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">instantclick.js加速原理</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">顶部进度条</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">加速方案</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">预加速案例</a> <ul><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">事件监听预回调</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">特殊属性申明</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1009, '# Too many open files \n\nToo many open files错误在Linux系统中是非常常见的。\n\n从字面意思上看就是说程序打开的文件数过多，不过这里的files不单是文件的意思，实际上包括通讯链接、端口等。\n\n因此称之为做句柄(handle)会更合适，因此这个错误通常叫做句柄数超出系统限制。\n\n产生原因就是进程在某个时刻打开了超过系统限制的文件数量以及通讯链接数。\n\n比如米虫遇到这个错误就是启动某个Web项目时，Tomcat启动报错了。\n\n## 解决思路\n\n既然错误说明都很清晰了，解决问题方案自然就2个：\n\n1. 增大系统最大句柄数\n2. 减少实际使用的句柄（比如某个应用移植到别的环境中）\n\n# ulimit语句\n\nulimit是Linux系统的内键功能，它具有一套参数集，用于为由它生成的shell进程及其子进程的资源使用设置限制。\n\nLinux对于每个用户，系统限制其最大进程数。\n\n为提高性能，可以根据设备资源情况，设置各linux 用户的最大进程数。\n\n## 基本语法\n\n```shell\nulimit [-参数符] [选填：设置值]\n```\n\n## 参数说明\n\n- -H 设置硬资源限制（Hard）；\n- -S 设置软资源限制（Soft）；\n- -a 显示当前所有的资源限制；\n- -c [设置值]:设置core文件的最大值；单位:blocks\n- -d [设置值]:设置数据段的最大值；单位:kbytes\n- -f [设置值]:设置创建文件的最大值；单位:blocks\n- -l [设置值]:设置在内存中锁定进程的最大值；单位:kbytes\n- -m [设置值]:设置可以使用的常驻内存的最大值；单位:kbytes\n- -n [设置值]:设置内核可以同时打开的文件描述符的最大值；单位:n\n- -p [设置值]:设置管道缓冲区的最大值；单位:kbytes\n- -s [设置值]:设置堆栈的最大值；单位:kbytes\n- -t [设置值]:设置CPU使用时间的最大上限；单位:seconds\n- -v [设置值]:设置虚拟内存的最大值；单位:kbytes\n- -u <程序数目> 　用户最多可开启的程序数目\n\n[设置值]可以为数字和unlimited（无限制），但要注意的是并不是所有字段都可以设置为无限制\n\n# 处理实例\n\n针对上面提到的Too many open files错误可以通过如下方式处理。\n\n## ulimit命令修改\n\n```shell\n#同时打开的文件10240\nulimit -n 10240\n#仅在本次连接生效，局部环境变量，重启会恢复默认值\n```\n\n## 配置环境变量文件\n\n### profile环境变量\n\n```shell\nvi /etc/profile\n#在环境变量配置文件追加配置 \nulimit -n 10240\n#保存后运行source /etc/profile 或 . /etc/profile使其生效\nsource /etc/profile\n#只对当前修改用户生效，重启不会恢复默认值\n```\n\n### limits.conf配置文件\n\n```shell\n#结尾添加\n#soft是警告值，hard是真正意义的阈值，超过就会报错\n* soft nofile 10240\n* hard nofile 10240\n#可以只用一句\n* - nofile 8192\n#*表示所有用户，可配置用户名，如：www\nwww soft nofile 10240\nwww hard nofile 10240\n#该方式可以对所有用户生效，重启不会恢复默认值\n```', '<h1 id=\"menu_1\">Too many open files</h1><p>Too many open files错误在Linux系统中是非常常见的。</p>\n<p>从字面意思上看就是说程序打开的文件数过多，不过这里的files不单是文件的意思，实际上包括通讯链接、端口等。</p>\n<p>因此称之为做句柄(handle)会更合适，因此这个错误通常叫做句柄数超出系统限制。</p>\n<p>产生原因就是进程在某个时刻打开了超过系统限制的文件数量以及通讯链接数。</p>\n<p>比如米虫遇到这个错误就是启动某个Web项目时，Tomcat启动报错了。</p>\n<h2 id=\"menu_2\">解决思路</h2><p>既然错误说明都很清晰了，解决问题方案自然就2个：</p>\n<ol>\n<li>增大系统最大句柄数</li>\n<li>减少实际使用的句柄（比如某个应用移植到别的环境中）</li>\n</ol>\n<h1 id=\"menu_3\">ulimit语句</h1><p>ulimit是Linux系统的内键功能，它具有一套参数集，用于为由它生成的shell进程及其子进程的资源使用设置限制。</p>\n<p>Linux对于每个用户，系统限制其最大进程数。</p>\n<p>为提高性能，可以根据设备资源情况，设置各linux 用户的最大进程数。</p>\n<h2 id=\"menu_4\">基本语法</h2><pre><code class=\"hljs language-shell\">ulimit <span class=\"hljs-selector-attr\">[-参数符]</span> <span class=\"hljs-selector-attr\">[选填：设置值]</span>\n</code></pre>\n<h2 id=\"menu_5\">参数说明</h2><ul>\n<li>-H 设置硬资源限制（Hard）；</li>\n<li>-S 设置软资源限制（Soft）；</li>\n<li>-a 显示当前所有的资源限制；</li>\n<li>-c [设置值]:设置core文件的最大值；单位:blocks</li>\n<li>-d [设置值]:设置数据段的最大值；单位:kbytes</li>\n<li>-f [设置值]:设置创建文件的最大值；单位:blocks</li>\n<li>-l [设置值]:设置在内存中锁定进程的最大值；单位:kbytes</li>\n<li>-m [设置值]:设置可以使用的常驻内存的最大值；单位:kbytes</li>\n<li>-n [设置值]:设置内核可以同时打开的文件描述符的最大值；单位:n</li>\n<li>-p [设置值]:设置管道缓冲区的最大值；单位:kbytes</li>\n<li>-s [设置值]:设置堆栈的最大值；单位:kbytes</li>\n<li>-t [设置值]:设置CPU使用时间的最大上限；单位:seconds</li>\n<li>-v [设置值]:设置虚拟内存的最大值；单位:kbytes</li>\n<li>-u &lt;程序数目&gt; 　用户最多可开启的程序数目</li>\n</ul>\n<p>[设置值]可以为数字和unlimited（无限制），但要注意的是并不是所有字段都可以设置为无限制</p>\n<h1 id=\"menu_6\">处理实例</h1><p>针对上面提到的Too many open files错误可以通过如下方式处理。</p>\n<h2 id=\"menu_7\">ulimit命令修改</h2><pre><code class=\"hljs language-shell\"><span class=\"hljs-comment\">#同时打开的文件10240</span>\n<span class=\"hljs-built_in\">ulimit</span> -n 10240\n<span class=\"hljs-comment\">#仅在本次连接生效，局部环境变量，重启会恢复默认值</span>\n</code></pre>\n<h2 id=\"menu_8\">配置环境变量文件</h2><h3 id=\"menu_9\">profile环境变量</h3><pre><code class=\"hljs language-shell\">vi /etc/profile\n<span class=\"hljs-comment\">#在环境变量配置文件追加配置 </span>\n<span class=\"hljs-built_in\">ulimit</span> -n 10240\n<span class=\"hljs-comment\">#保存后运行source /etc/profile 或 . /etc/profile使其生效</span>\n<span class=\"hljs-built_in\">source</span> /etc/profile\n<span class=\"hljs-comment\">#只对当前修改用户生效，重启不会恢复默认值</span>\n</code></pre>\n<h3 id=\"menu_10\">limits.conf配置文件</h3><pre><code class=\"hljs language-shell\"><span class=\"hljs-comment\">#结尾添加</span>\n<span class=\"hljs-comment\">#soft是警告值，hard是真正意义的阈值，超过就会报错</span>\n<span class=\"hljs-string\">*</span> <span class=\"hljs-string\">soft</span> <span class=\"hljs-string\">nofile</span> <span class=\"hljs-number\">10240</span>\n<span class=\"hljs-string\">*</span> <span class=\"hljs-string\">hard</span> <span class=\"hljs-string\">nofile</span> <span class=\"hljs-number\">10240</span>\n<span class=\"hljs-comment\">#可以只用一句</span>\n<span class=\"hljs-string\">*</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">nofile</span> <span class=\"hljs-number\">8192</span>\n<span class=\"hljs-comment\">#*表示所有用户，可配置用户名，如：www</span>\n<span class=\"hljs-string\">www</span> <span class=\"hljs-string\">soft</span> <span class=\"hljs-string\">nofile</span> <span class=\"hljs-number\">10240</span>\n<span class=\"hljs-string\">www</span> <span class=\"hljs-string\">hard</span> <span class=\"hljs-string\">nofile</span> <span class=\"hljs-number\">10240</span>\n<span class=\"hljs-comment\">#该方式可以对所有用户生效，重启不会恢复默认值</span>\n</code></pre>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">Too many open files</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">解决思路</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">ulimit语句</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">基本语法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">参数说明</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl1\">处理实例</a> <ul><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">ulimit命令修改</a> <!----></li><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl2\">配置环境变量文件</a> <ul><li><a href=\"javascript:runTo(\'menu_9\')\" class=\"pl3\">profile环境变量</a></li><li><a href=\"javascript:runTo(\'menu_10\')\" class=\"pl3\">limits.conf配置文件</a></li></ul></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1010, '# 本文说明\n\n本文主要用于备忘，尤其是个人已经从Eclipse IDE转投IntelliJ IDEA的怀抱。\n\nIntelliJ IDEA自带的Maven、Git、Spring支持等实用功能实在是太香了。\n\n实际上，对于Git而言，个人比较建议使用命令行的方式去维护。\n\n另外推荐一个处理Git冲突的好工具，也是一个开源的跨语言IDE：\n\n- Visual Studio Code\n\n# 完整流程\n\n## 打开Git视窗\n\n![/static/upload/post/1645145982408.png](/static/upload/post/1645145982408.png)\n\n![/static/upload/post/1645145993813.png](/static/upload/post/1645145993813.png)\n\n## 配置项目\n\n![/static/upload/post/1645146011629.png](/static/upload/post/1645146011629.png)\n\n![/static/upload/post/1645146019826.png](/static/upload/post/1645146019826.png)\n\n![/static/upload/post/1645146030601.png](/static/upload/post/1645146030601.png)\n\n![/static/upload/post/1645146037922.png](/static/upload/post/1645146037922.png)\n\n![/static/upload/post/1645146045581.png](/static/upload/post/1645146045581.png)\n\n## 成功效果\n\n![/static/upload/post/1645146058287.png](/static/upload/post/1645146058287.png)\n\n## 执行操作\n\n右击项目选择执行的操作。\n\n![/static/upload/post/1645146068278.png](/static/upload/post/1645146068278.png)\n\n# 补充说明\n\n查看GIT配置信息。\n\n![/static/upload/post/1645146077723.png](/static/upload/post/1645146077723.png)', '<h1 id=\"menu_1\">本文说明</h1><p>本文主要用于备忘，尤其是个人已经从Eclipse IDE转投IntelliJ IDEA的怀抱。</p>\n<p>IntelliJ IDEA自带的Maven、Git、Spring支持等实用功能实在是太香了。</p>\n<p>实际上，对于Git而言，个人比较建议使用命令行的方式去维护。</p>\n<p>另外推荐一个处理Git冲突的好工具，也是一个开源的跨语言IDE：</p>\n<ul>\n<li>Visual Studio Code</li>\n</ul>\n<h1 id=\"menu_2\">完整流程</h1><h2 id=\"menu_3\">打开Git视窗</h2><p><img src=\"/static/upload/post/1645145982408.png\" alt=\"/static/upload/post/1645145982408.png\"/></p>\n<p><img src=\"/static/upload/post/1645145993813.png\" alt=\"/static/upload/post/1645145993813.png\"/></p>\n<h2 id=\"menu_4\">配置项目</h2><p><img src=\"/static/upload/post/1645146011629.png\" alt=\"/static/upload/post/1645146011629.png\"/></p>\n<p><img src=\"/static/upload/post/1645146019826.png\" alt=\"/static/upload/post/1645146019826.png\"/></p>\n<p><img src=\"/static/upload/post/1645146030601.png\" alt=\"/static/upload/post/1645146030601.png\"/></p>\n<p><img src=\"/static/upload/post/1645146037922.png\" alt=\"/static/upload/post/1645146037922.png\"/></p>\n<p><img src=\"/static/upload/post/1645146045581.png\" alt=\"/static/upload/post/1645146045581.png\"/></p>\n<h2 id=\"menu_5\">成功效果</h2><p><img src=\"/static/upload/post/1645146058287.png\" alt=\"/static/upload/post/1645146058287.png\"/></p>\n<h2 id=\"menu_6\">执行操作</h2><p>右击项目选择执行的操作。</p>\n<p><img src=\"/static/upload/post/1645146068278.png\" alt=\"/static/upload/post/1645146068278.png\"/></p>\n<h1 id=\"menu_7\">补充说明</h1><p>查看GIT配置信息。</p>\n<p><img src=\"/static/upload/post/1645146077723.png\" alt=\"/static/upload/post/1645146077723.png\"/></p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">本文说明</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">完整流程</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">打开Git视窗</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">配置项目</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">成功效果</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">执行操作</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl1\">补充说明</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1011, '# 信任关系的作用\n\n两个不同的环境之间建立信任关系后，通过ssh命令可以免密码切换到对方环境中去\n\n尤其在做批量自动化时非常实用，可以设立某个环境为agent（执行机），利用ssh/scp完成远程指令执行或者按照升级包的快速投放\n\n对于对公网开放的环境一般不要随便添加远程信任关系，是很危险的操作\n\n本文主要适用于内网环境间的快速访问，下面是完整流程与偷懒流程\n\n# 完整流程\n\n1. 以mebugs用户登录10.10.10.10\n2. **mkdir .ssh**\n	建立.ssh目录\n	如果系统显示mkdir: cannot create directory .ssh: File exists\n	表示目录.ssh已经创建，则不需要重新创建\n3. **cd .ssh**\n	进入.ssh目录 \n4. **ssh-keygen -t rsa -b 2048**\n	建立公钥\n	提示输入信息的地方，按回车即可\n5. **cp id_rsa.pub id_rsa1.pub**\n	生成的文件id_rsa.pub复制一份为id_rsa1.pub ，用以区分不同用户的密钥\n6. **sftp mebugs@10.10.10.20**\n	将id_rsa1.pub上传到（sftp上传）mebugs用户所在的.ssh目录下\n	1. **mkdir .ssh**\n		同上，有就无所谓。\n	2. **cd .ssh**\n		进入.ssh目录 \n	3. **put id_rsa1.pub**\n		上传公钥\n	4. **quit**\n7. **ssh mebugs@10.10.10.20**\n	远程登录，此时无信任关系需要输入密码。\n8. **cd .ssh**\n	进入.ssh目录 \n9.  **cat id_rsa1.pub >> authorized_keys**\n	追加公钥到authorized_keys文件\n10. 如果需要添加双向信任关系\n	在10.10.10.20下执行4-9步，将目标地址变成10.10.10.10的用户\n\n## 快捷流程\n\n举例10.10.10.10的mebugs用户与10.10.10.20的mebugs用户\n\n - 把10的mebugs用户的rsa.pub文件内容拷贝到20的mebugs用户的authorized_keys文件里面\n - 把20的mebugs用户的rsa.pub文件内容拷贝进10的mebugs用户的authorized_keys文件里面\n\n完成...\n\n1. 同时登录10.10.10.10的mebugs用户与10.10.10.20的mebugs用户\n2. 分别进入两个用户的cd .ssh\n3. vi id_rsa.pub 打开id_rsa.pup文件，全文Copy\n4. vi authorized_keys 打开另一个环境的authorized_keys，粘进去\n5. 反向操作3/4两步，如果不反向操作就是单向信任关系，互加了就是双向的。\n\n偷懒流程缺陷？\n\n哦~会有一些重复的垃圾数据以及不必要的信任关系，不建议（大力推荐）大家这么玩儿~\n\n不必要的信任关系：\n\n- 比如10和30有信任关系\n- 20不需要和30有信任关系\n- 但是20拷贝了10的内容\n- 20有了30的单向信任关系\n\n# 信任关系检查\n\n在10.10.10.10的mebugs用户下\n\n```shell\nssh mebugs@10.10.10.20\n```\n\n按下回车：如果不用输入密码直接登陆进去，说明信任关系加入成功\n', '<h1 id=\"menu_1\">信任关系的作用</h1><p>两个不同的环境之间建立信任关系后，通过ssh命令可以免密码切换到对方环境中去</p>\n<p>尤其在做批量自动化时非常实用，可以设立某个环境为agent（执行机），利用ssh/scp完成远程指令执行或者按照升级包的快速投放</p>\n<p>对于对公网开放的环境一般不要随便添加远程信任关系，是很危险的操作</p>\n<p>本文主要适用于内网环境间的快速访问，下面是完整流程与偷懒流程</p>\n<h1 id=\"menu_2\">完整流程</h1><ol>\n<li>以mebugs用户登录10.10.10.10</li>\n<li><strong>mkdir .ssh</strong><br/> 建立.ssh目录<br/> 如果系统显示mkdir: cannot create directory .ssh: File exists<br/> 表示目录.ssh已经创建，则不需要重新创建</li>\n<li><strong>cd .ssh</strong><br/> 进入.ssh目录 </li>\n<li><strong>ssh-keygen -t rsa -b 2048</strong><br/> 建立公钥<br/> 提示输入信息的地方，按回车即可</li>\n<li><strong>cp id_rsa.pub id_rsa1.pub</strong><br/> 生成的文件id_rsa.pub复制一份为id_rsa1.pub ，用以区分不同用户的密钥</li>\n<li><strong>sftp <a class=\"mlink\" href=\"mailto:&#x6d;&#101;&#x62;&#117;&#x67;&#115;&#64;&#49;&#48;&#x2e;&#x31;&#x30;&#x2e;&#x31;&#x30;&#x2e;&#x32;&#x30;\" title=\"&#x6d;&#101;&#x62;&#117;&#x67;&#115;&#64;&#49;&#48;&#x2e;&#x31;&#x30;&#x2e;&#x31;&#x30;&#x2e;&#x32;&#x30;\" target=\"_blank\">&#x6d;&#101;&#x62;&#117;&#x67;&#115;&#64;&#49;&#48;&#x2e;&#x31;&#x30;&#x2e;&#x31;&#x30;&#x2e;&#x32;&#x30;</a></strong><br/> 将id_rsa1.pub上传到（sftp上传）mebugs用户所在的.ssh目录下<ol>\n<li><strong>mkdir .ssh</strong><br/> 同上，有就无所谓。</li>\n<li><strong>cd .ssh</strong><br/> 进入.ssh目录 </li>\n<li><strong>put id_rsa1.pub</strong><br/> 上传公钥</li>\n<li><strong>quit</strong></li>\n</ol>\n</li>\n<li><strong>ssh <a class=\"mlink\" href=\"mailto:&#x6d;&#x65;&#98;&#117;&#103;&#115;&#x40;&#x31;&#x30;&#x2e;&#x31;&#48;&#x2e;&#x31;&#x30;&#x2e;&#x32;&#x30;\" title=\"&#x6d;&#x65;&#98;&#117;&#103;&#115;&#x40;&#x31;&#x30;&#x2e;&#x31;&#48;&#x2e;&#x31;&#x30;&#x2e;&#x32;&#x30;\" target=\"_blank\">&#x6d;&#x65;&#98;&#117;&#103;&#115;&#x40;&#x31;&#x30;&#x2e;&#x31;&#48;&#x2e;&#x31;&#x30;&#x2e;&#x32;&#x30;</a></strong><br/> 远程登录，此时无信任关系需要输入密码。</li>\n<li><strong>cd .ssh</strong><br/> 进入.ssh目录 </li>\n<li><strong>cat id_rsa1.pub &gt;&gt; authorized_keys</strong><br/> 追加公钥到authorized_keys文件</li>\n<li>如果需要添加双向信任关系<br/>在10.10.10.20下执行4-9步，将目标地址变成10.10.10.10的用户</li>\n</ol>\n<h2 id=\"menu_3\">快捷流程</h2><p>举例10.10.10.10的mebugs用户与10.10.10.20的mebugs用户</p>\n<ul>\n<li>把10的mebugs用户的rsa.pub文件内容拷贝到20的mebugs用户的authorized_keys文件里面</li>\n<li>把20的mebugs用户的rsa.pub文件内容拷贝进10的mebugs用户的authorized_keys文件里面</li>\n</ul>\n<p>完成...</p>\n<ol>\n<li>同时登录10.10.10.10的mebugs用户与10.10.10.20的mebugs用户</li>\n<li>分别进入两个用户的cd .ssh</li>\n<li>vi id_rsa.pub 打开id_rsa.pup文件，全文Copy</li>\n<li>vi authorized_keys 打开另一个环境的authorized_keys，粘进去</li>\n<li>反向操作3/4两步，如果不反向操作就是单向信任关系，互加了就是双向的。</li>\n</ol>\n<p>偷懒流程缺陷？</p>\n<p>哦<del>会有一些重复的垃圾数据以及不必要的信任关系，不建议（大力推荐）大家这么玩儿</del></p>\n<p>不必要的信任关系：</p>\n<ul>\n<li>比如10和30有信任关系</li>\n<li>20不需要和30有信任关系</li>\n<li>但是20拷贝了10的内容</li>\n<li>20有了30的单向信任关系</li>\n</ul>\n<h1 id=\"menu_4\">信任关系检查</h1><p>在10.10.10.10的mebugs用户下</p>\n<pre><code class=\"hljs language-shell\">ssh mebugs<span class=\"hljs-variable\">@10</span>.<span class=\"hljs-number\">10.10</span>.<span class=\"hljs-number\">20</span>\n</code></pre>\n<p>按下回车：如果不用输入密码直接登陆进去，说明信任关系加入成功</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">信任关系的作用</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">完整流程</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">快捷流程</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">信任关系检查</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1012, '# 基础维护\n\n## 监听相关\n\n【非连接态，未登录Oracle】\n\n```shell\n启动监听\nlsnrctl start [SID 选填，针对非默认的监听]\n查看监听\nlsnrctl status\n停止监听\nlsnrctl stop\n```\n\n## 系统用户登录\n\n【连接态】\n\n```shell\nsqlplus / as sysdba\n```\n\n## 启停数据库\n\n启停数据库均需要先登陆系统用户\n\n流程：开启监听 -> 登录系统用户 -> 启停数据库\n\n```shell\n#关闭数据库\nshutdown immediate\n#启动数据库\nstartup\n```\n\n# 表空间维护\n\n```sql\n--查询表空间：\nselect tablespace_name from dba_tablespaces;\n--删除表空间（并删除关联的表空间文件）：\ndrop tablespace MEBUGS_INDEX INCLUDING CONTENTS AND DATAFILES;\n--创建临时表空间（不可创建用户）：\n--size 500m autoextend on next 500m maxsize 20480m\n--初始大小500M，自增扩容每次500M，最大20G\ncreate temporary tablespace MEBUGS_DATA tempfile \'/home/oracle/oradb/sobest_data.dbf\' size 500m autoextend on next 500m maxsize 20480m extent management local;\n--创建普通表空间（可以创建用户）：\ncreate tablespace MEBUGS_IDX logging datafile \'/home/oracle/oradb/sobest_index.dbf\' size 500m autoextend on next 500m maxsize 20480m extent management local;\n```\n\n# 角色与用户维护\n\n```sql\n--创建角色：mebugs\nCREATE ROLE mebugs;\n--赋予mebugs角色权限（具体的权限能力意义略）：\ngrant CREATE SESSION,CREATE CLUSTER,CREATE DIMENSION,CREATE INDEXTYPE,CREATE PROCEDURE,CREATE ROLE,CREATE SEQUENCE,CREATE SYNONYM,CREATE TABLE,CREATE TRIGGER,CREATE TYPE,CREATE VIEW,CREATE DATABASE LINK,CREATE MATERIALIZED VIEW,CREATE JOB,QUERY REWRITE,DEBUG CONNECT SESSION to mebugs;\n--创建mebugs用户并赋予角色（用户名mebugs 密码Test123）\n--指定了该用户指向的表空间MEBUGS_DATA\ncreate user mebugs identified by Test123 default tablespace MEBUGS_DATA;\ngrant connect,mcentrexdbapp to mebugs;\n--赋予用户创建视图的能力\ngrant create view to mebugs;\n--赋予全局表空间配额（更多细致权限配额，请度娘）\ngrant unlimited tablespace to mebugs;\n--查询数据库用户：\nselect USERNAME from all_users; \n--删除数据库用户：\ndrop user mebugs cascade;\n```\n\n# 字符集配置（解决乱码问题）\n\n```sql\n--【连接态】\n--查询语言字符集\nselect userenv(\'language\') from dual;\n--关闭数据库\nshutdown immediate; \n--启动数据库实例（注意仅仅启动连接但是不启动数据库——\nstartup mount;\n--字符集配置\nALTER SYSTEM ENABLE RESTRICTED SESSION;\nALTER SYSTEM SET JOB_QUEUE_PROCESSES=0;\nALTER SYSTEM SET AQ_TM_PROCESSES=0;\nalter database open; \n--关键配置项 AL32UTF8\nALTER DATABASE CHARACTER SET AL32UTF8;\nALTER DATABASE character set INTERNAL_USE AL32UTF8;\n--关闭数据库\nshutdown immediate;\n--正式启动数据库\nstartup;\n--【非连接态】\n--配置变量即可\nexport NLS_LANG=\"AMERICAN_AMERICA.AL32UTF8\"\n```', '<h1 id=\"menu_1\">基础维护</h1><h2 id=\"menu_2\">监听相关</h2><p>【非连接态，未登录Oracle】</p>\n<pre><code class=\"hljs language-shell\">启动监听\nlsnrctl start <span class=\"hljs-selector-attr\">[SID 选填，针对非默认的监听]</span>\n查看监听\nlsnrctl status\n停止监听\nlsnrctl stop\n</code></pre>\n<h2 id=\"menu_3\">系统用户登录</h2><p>【连接态】</p>\n<pre><code class=\"hljs language-shell\">sqlplus / <span class=\"hljs-keyword\">as</span> sysdba\n</code></pre>\n<h2 id=\"menu_4\">启停数据库</h2><p>启停数据库均需要先登陆系统用户</p>\n<p>流程：开启监听 -&gt; 登录系统用户 -&gt; 启停数据库</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-comment\">#关闭数据库</span>\nshutdown immediate\n<span class=\"hljs-comment\">#启动数据库</span>\nstartup\n</code></pre>\n<h1 id=\"menu_5\">表空间维护</h1><pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">--查询表空间：</span>\n<span class=\"hljs-keyword\">select</span> tablespace_name <span class=\"hljs-keyword\">from</span> dba_tablespaces;\n<span class=\"hljs-comment\">--删除表空间（并删除关联的表空间文件）：</span>\n<span class=\"hljs-keyword\">drop</span> tablespace MEBUGS_INDEX INCLUDING CONTENTS <span class=\"hljs-keyword\">AND</span> DATAFILES;\n<span class=\"hljs-comment\">--创建临时表空间（不可创建用户）：</span>\n<span class=\"hljs-comment\">--size 500m autoextend on next 500m maxsize 20480m</span>\n<span class=\"hljs-comment\">--初始大小500M，自增扩容每次500M，最大20G</span>\n<span class=\"hljs-keyword\">create</span> temporary tablespace MEBUGS_DATA tempfile <span class=\"hljs-string\">&#x27;/home/oracle/oradb/sobest_data.dbf&#x27;</span> size <span class=\"hljs-number\">500</span>m autoextend <span class=\"hljs-keyword\">on</span> next <span class=\"hljs-number\">500</span>m maxsize <span class=\"hljs-number\">20480</span>m extent management <span class=\"hljs-keyword\">local</span>;\n<span class=\"hljs-comment\">--创建普通表空间（可以创建用户）：</span>\n<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span>space MEBUGS_IDX logging datafile <span class=\"hljs-string\">&#x27;/home/oracle/oradb/sobest_index.dbf&#x27;</span> size <span class=\"hljs-number\">500</span>m autoextend <span class=\"hljs-keyword\">on</span> next <span class=\"hljs-number\">500</span>m maxsize <span class=\"hljs-number\">20480</span>m extent management <span class=\"hljs-keyword\">local</span>;\n</code></pre>\n<h1 id=\"menu_6\">角色与用户维护</h1><pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">--创建角色：mebugs</span>\n<span class=\"hljs-keyword\">CREATE</span> ROLE mebugs;\n<span class=\"hljs-comment\">--赋予mebugs角色权限（具体的权限能力意义略）：</span>\n<span class=\"hljs-keyword\">grant</span> <span class=\"hljs-keyword\">CREATE</span> SESSION,<span class=\"hljs-keyword\">CREATE</span> CLUSTER,<span class=\"hljs-keyword\">CREATE</span> DIMENSION,<span class=\"hljs-keyword\">CREATE</span> INDEXTYPE,<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">PROCEDURE</span>,<span class=\"hljs-keyword\">CREATE</span> ROLE,<span class=\"hljs-keyword\">CREATE</span> SEQUENCE,<span class=\"hljs-keyword\">CREATE</span> SYNONYM,<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span>,<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TRIGGER</span>,<span class=\"hljs-keyword\">CREATE</span> TYPE,<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span>,<span class=\"hljs-keyword\">CREATE</span> DATABASE LINK,<span class=\"hljs-keyword\">CREATE</span> MATERIALIZED <span class=\"hljs-keyword\">VIEW</span>,<span class=\"hljs-keyword\">CREATE</span> JOB,QUERY REWRITE,DEBUG <span class=\"hljs-keyword\">CONNECT</span> SESSION <span class=\"hljs-keyword\">to</span> mebugs;\n<span class=\"hljs-comment\">--创建mebugs用户并赋予角色（用户名mebugs 密码Test123）</span>\n<span class=\"hljs-comment\">--指定了该用户指向的表空间MEBUGS_DATA</span>\n<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">user</span> mebugs identified <span class=\"hljs-keyword\">by</span> Test123 <span class=\"hljs-keyword\">default</span> tablespace MEBUGS_DATA;\n<span class=\"hljs-keyword\">grant</span> <span class=\"hljs-keyword\">connect</span>,mcentrexdbapp <span class=\"hljs-keyword\">to</span> mebugs;\n<span class=\"hljs-comment\">--赋予用户创建视图的能力</span>\n<span class=\"hljs-keyword\">grant</span> <span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">view</span> <span class=\"hljs-keyword\">to</span> mebugs;\n<span class=\"hljs-comment\">--赋予全局表空间配额（更多细致权限配额，请度娘）</span>\n<span class=\"hljs-keyword\">grant</span> unlimited tablespace <span class=\"hljs-keyword\">to</span> mebugs;\n<span class=\"hljs-comment\">--查询数据库用户：</span>\n<span class=\"hljs-keyword\">select</span> USERNAME <span class=\"hljs-keyword\">from</span> all_users; \n<span class=\"hljs-comment\">--删除数据库用户：</span>\n<span class=\"hljs-keyword\">drop</span> <span class=\"hljs-keyword\">user</span> mebugs cascade;\n</code></pre>\n<h1 id=\"menu_7\">字符集配置（解决乱码问题）</h1><pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">--【连接态】</span>\n<span class=\"hljs-comment\">--查询语言字符集</span>\n<span class=\"hljs-keyword\">select</span> userenv(<span class=\"hljs-string\">&#x27;language&#x27;</span>) <span class=\"hljs-keyword\">from</span> dual;\n<span class=\"hljs-comment\">--关闭数据库</span>\nshutdown immediate; \n<span class=\"hljs-comment\">--启动数据库实例（注意仅仅启动连接但是不启动数据库——</span>\nstartup mount;\n<span class=\"hljs-comment\">--字符集配置</span>\n<span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">SYSTEM</span> ENABLE RESTRICTED SESSION;\n<span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">SYSTEM</span> <span class=\"hljs-keyword\">SET</span> JOB_QUEUE_PROCESSES<span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">SYSTEM</span> <span class=\"hljs-keyword\">SET</span> AQ_TM_PROCESSES<span class=\"hljs-operator\">=</span><span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">alter</span> database <span class=\"hljs-keyword\">open</span>; \n<span class=\"hljs-comment\">--关键配置项 AL32UTF8</span>\n<span class=\"hljs-keyword\">ALTER</span> DATABASE <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> AL32UTF8;\n<span class=\"hljs-keyword\">ALTER</span> DATABASE <span class=\"hljs-type\">character</span> <span class=\"hljs-keyword\">set</span> INTERNAL_USE AL32UTF8;\n<span class=\"hljs-comment\">--关闭数据库</span>\nshutdown immediate;\n<span class=\"hljs-comment\">--正式启动数据库</span>\nstartup;\n<span class=\"hljs-comment\">--【非连接态】</span>\n<span class=\"hljs-comment\">--配置变量即可</span>\nexport NLS_LANG<span class=\"hljs-operator\">=</span>&quot;AMERICAN_AMERICA.AL32UTF8&quot;\n</code></pre>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">基础维护</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">监听相关</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">系统用户登录</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">启停数据库</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">表空间维护</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl1\">角色与用户维护</a> <!----></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl1\">字符集配置（解决乱码问题）</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1013, '# 关于rewrite\n\nrewrite的一般多用于实现RUL地址的重定向。\n\nNginx的rewrite通过perl兼容正则表达式语句进行规则匹配的。\n\n默认配置下，Nginx会支持rewrite的模块。\n\n## rewrite的作用\n\n通过下方案例便能轻松理解rewrite的作用。\n\n```shell\n# 原本访问文章的URL\nhttp://www.mebugs.com/post.php?url=java\n# URL太不美观、暴露了我的后端请求地址、暴露了请求参数\n# 通过rewrite可以实现如下地址访问，等同于上方地址\nhttp://www.mebugs.com/post_java.html\n# 配置规则\n# 访问post_开头.html结果地址，重写到post.php?url=中间匹配的字符\nrewrite ^/post_(.*).html$  /post.php?url=$1  break;\n```\n\n理解作用后，我们可以看下rewrite的语法。\n\n# rewrite的语法\n\nrewrite的语法很简单，分为四部分。\n\n```properties\n#关键字      正则           替代内容               标记\nrewrite    <regex>    <replacement>    [flag];\n```\n - 关键字：关键字不能改变\n - 正则：perl兼容正则表达式语句进行规则匹配\n - 替代内容：将正则匹配的内容替换成replacement\n - 标记：rewrite支持的flag标记\n\n## 正则<regex>\n\n关于正则的规则不需要多说，这一段内容主要用于匹配访问的URL。\n\nrewrite中常见的正则规则：\n\n - \\：标记后续字符串为特殊字符串或原义字符或一个向后引用，如“\\n”匹配一个换行符，而“$”则匹配“$”\n - ^：匹配起始位置\n - $：匹配结束位置\n - .：匹配任何单个字符\n - `*`：匹配前面的字符零次或多次，如x*能匹配x、xx、xxx，.*则表示通配\n - +：匹配前面的字符一次或多次\n - ?：匹配前面的字符零次或一次，\"?\"等效于\"{0,1}\"\n - (pattern)：非常重要！！！匹配括号内pattern并可以在后面获取对应的匹配，常用$1...$9属性获取小括号中的匹配内容\n\nrewrite中的正则还受其所在的location影响，因为外部location也是可以正则的。\n\n注意：**rewrite可以不配置在location下表示全局生效**\n\n```properties\n# 基本规则（所有的URL都会接受rewrite）\nlocation / {\n	rewrite ^/post_(.*).html$  /post.php?url=$1  break;\n}\n# location有规则（只有URL以.html结尾的请求才会进来）\nlocation ~ .*.(html)?$ {\n	rewrite ^/post_(.*).html$  /post.php?url=$1  break;\n}\n# 这是一个错误的规则（不会生效）\n# 外部定义了只有/open开始的URL进来，内部定义了匹配/post，所以规则不会生效\nlocation /open {\n	rewrite ^/post_(.*).html$  /post.php?url=$1  break;\n}\n```\n\n## 替代内容<replacement>\n\n替代内容实际上就是将前面匹配到的URL转换成实际URL。\n\n需要注意的是，<replacement>里面是可以接受参数的，接受的内容为正则<regex>中圆括号包裹的内容。\n\n```properties\n# 还是上文的例子\n# $1取得是前面规则中(.*)匹配的字符串，比如：/post_java.html时$1就是java\nrewrite ^/post_(.*).html$  /post.php?url=$1  break;\n# 多参数的写法\n# /page_new_1_.html => /page.php?type=new&current=1\nrewrite ^/page_([a-z]+)_(d+)_.html$  /page.php?type=$1&current=$2  break;\n```\n\n##  标记[flag]\n\n这是一个可选项，不写默认似乎是last。\n\n - last：本条规则匹配完成后，继续向下匹配新的location URI规则\n - break：本条规则匹配完成即终止，不再匹配后面的任何规则\n - redirect：返回302临时重定向，浏览器地址会显示跳转后的URL地址\n - permanent：返回301永久重定向，浏览器地址栏会显示跳转后的URL地址\n\n我们看到redirect和permanent会发生重定向。\n\n而last和break用来实现URL重写，**浏览器地址栏URL地址不变**。\n\n# 其他注意点\n## 正则匹配传参部分才需要圆括号\n正则<regex>中如果只是匹配但不需要传参，则无需用圆括号包裹。\n\n```properties\nrewrite ^/c_[0-9]+/(.*)$ /comm/$1 break;\n# 上方规则仅仅对第二部分进行传参匹配\n# 比如：/c_1/go =>/comm/go  /c_1/xx/mo =>/comm/xx/mo\n```\n\n## 引入规则配置文件\n\nrewrite不一定需要完全在配置文件中配置，可以单独引入。\n\n```properties\n# REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效\ninclude /www/server/rewrite/mebugs.conf;\n# REWRITE-END\n# 配置文件不一定要.conf，.htaccess 也是可以的\n```\n\n## 活用一些全局变量\n\n配置rewrite规则时可以引入一些Nginx的全局变量，甚至增加if条件判断，可以实现更为复杂的规则配置。\n\n```properties\n# 如果访问的是mebugs.com的任意子域名才生效如下规则\nif ($host ~* (.*)/.mebugs/.com) {\n	rewrite ^/page_([a-z]+)_(d+)_.html$  /page.php?type=$1&current=$2 last;\n}\n# 特定子域名访问子目录\nif ($http_host ~ me/.mebugs/.com$) {\nrewrite ^(.*) /me/$1 break;\n}\n```', '<h1 id=\"menu_1\">关于rewrite</h1><p>rewrite的一般多用于实现RUL地址的重定向。</p>\n<p>Nginx的rewrite通过perl兼容正则表达式语句进行规则匹配的。</p>\n<p>默认配置下，Nginx会支持rewrite的模块。</p>\n<h2 id=\"menu_2\">rewrite的作用</h2><p>通过下方案例便能轻松理解rewrite的作用。</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-comment\"># 原本访问文章的URL</span>\n<span class=\"hljs-symbol\">http:</span>/<span class=\"hljs-regexp\">/www.mebugs.com/post</span>.php?url=java\n<span class=\"hljs-comment\"># URL太不美观、暴露了我的后端请求地址、暴露了请求参数</span>\n<span class=\"hljs-comment\"># 通过rewrite可以实现如下地址访问，等同于上方地址</span>\n<span class=\"hljs-symbol\">http:</span>/<span class=\"hljs-regexp\">/www.mebugs.com/post</span>_java.html\n<span class=\"hljs-comment\"># 配置规则</span>\n<span class=\"hljs-comment\"># 访问post_开头.html结果地址，重写到post.php?url=中间匹配的字符</span>\nrewrite ^<span class=\"hljs-regexp\">/post_(.*).html$  /post</span>.php?url=<span class=\"hljs-variable\">$1</span>  <span class=\"hljs-keyword\">break</span>;\n</code></pre>\n<p>理解作用后，我们可以看下rewrite的语法。</p>\n<h1 id=\"menu_3\">rewrite的语法</h1><p>rewrite的语法很简单，分为四部分。</p>\n<pre><code class=\"hljs language-properties\">#关键字      正则           替代内容               标记\nrewrite    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">regex</span>&gt;</span>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">replacement</span>&gt;</span>    [flag];\n</code></pre>\n<ul>\n<li>关键字：关键字不能改变</li>\n<li>正则：perl兼容正则表达式语句进行规则匹配</li>\n<li>替代内容：将正则匹配的内容替换成replacement</li>\n<li>标记：rewrite支持的flag标记</li>\n</ul>\n<h2 id=\"menu_4\">正则<regex></h2><p>关于正则的规则不需要多说，这一段内容主要用于匹配访问的URL。</p>\n<p>rewrite中常见的正则规则：</p>\n<ul>\n<li>：标记后续字符串为特殊字符串或原义字符或一个向后引用，如“\n”匹配一个换行符，而“$”则匹配“$”</li>\n<li>^：匹配起始位置</li>\n<li>$：匹配结束位置</li>\n<li>.：匹配任何单个字符</li>\n<li><code>*</code>：匹配前面的字符零次或多次，如x*能匹配x、xx、xxx，.*则表示通配</li>\n<li>+：匹配前面的字符一次或多次</li>\n<li>?：匹配前面的字符零次或一次，&quot;?&quot;等效于&quot;{0,1}&quot;</li>\n<li>(pattern)：非常重要！！！匹配括号内pattern并可以在后面获取对应的匹配，常用$1...$9属性获取小括号中的匹配内容</li>\n</ul>\n<p>rewrite中的正则还受其所在的location影响，因为外部location也是可以正则的。</p>\n<p>注意：<strong>rewrite可以不配置在location下表示全局生效</strong></p>\n<pre><code class=\"hljs language-properties\"><span class=\"hljs-comment\"># 基本规则（所有的URL都会接受rewrite）</span>\nlocation / {\n    rewrite ^<span class=\"hljs-regexp\">/post_(.*).html$  /post</span>.php?url=<span class=\"hljs-variable\">$1</span>  <span class=\"hljs-keyword\">break</span>;\n}\n<span class=\"hljs-comment\"># location有规则（只有URL以.html结尾的请求才会进来）</span>\nlocation ~ .*.(html)<span class=\"hljs-string\">?$</span> {\n    rewrite ^<span class=\"hljs-regexp\">/post_(.*).html$  /post</span>.php?url=<span class=\"hljs-variable\">$1</span>  <span class=\"hljs-keyword\">break</span>;\n}\n<span class=\"hljs-comment\"># 这是一个错误的规则（不会生效）</span>\n<span class=\"hljs-comment\"># 外部定义了只有/open开始的URL进来，内部定义了匹配/post，所以规则不会生效</span>\nlocation /open {\n    rewrite ^<span class=\"hljs-regexp\">/post_(.*).html$  /post</span>.php?url=<span class=\"hljs-variable\">$1</span>  <span class=\"hljs-keyword\">break</span>;\n}\n</code></pre>\n<h2 id=\"menu_5\">替代内容<replacement></h2><p>替代内容实际上就是将前面匹配到的URL转换成实际URL。</p>\n<p>需要注意的是，<replacement>里面是可以接受参数的，接受的内容为正则<regex>中圆括号包裹的内容。</p>\n<pre><code class=\"hljs language-properties\"><span class=\"hljs-comment\"># 还是上文的例子</span>\n<span class=\"hljs-comment\"># $1取得是前面规则中(.*)匹配的字符串，比如：/post_java.html时$1就是java</span>\nrewrite ^<span class=\"hljs-regexp\">/post_(.*).html$  /post</span>.php?url=<span class=\"hljs-variable\">$1</span>  <span class=\"hljs-keyword\">break</span>;\n<span class=\"hljs-comment\"># 多参数的写法</span>\n<span class=\"hljs-comment\"># /page_new_1_.html =&gt; /page.php?type=new&amp;current=1</span>\nrewrite ^<span class=\"hljs-regexp\">/page_([a-z]+)_(d+)_.html$  /page</span>.php?type=<span class=\"hljs-variable\">$1</span>&amp;current=<span class=\"hljs-variable\">$2</span>  <span class=\"hljs-keyword\">break</span>;\n</code></pre>\n<h2 id=\"menu_6\">标记[flag]</h2><p>这是一个可选项，不写默认似乎是last。</p>\n<ul>\n<li>last：本条规则匹配完成后，继续向下匹配新的location URI规则</li>\n<li>break：本条规则匹配完成即终止，不再匹配后面的任何规则</li>\n<li>redirect：返回302临时重定向，浏览器地址会显示跳转后的URL地址</li>\n<li>permanent：返回301永久重定向，浏览器地址栏会显示跳转后的URL地址</li>\n</ul>\n<p>我们看到redirect和permanent会发生重定向。</p>\n<p>而last和break用来实现URL重写，<strong>浏览器地址栏URL地址不变</strong>。</p>\n<h1 id=\"menu_7\">其他注意点</h1><h2 id=\"menu_8\">正则匹配传参部分才需要圆括号</h2><p>正则<regex>中如果只是匹配但不需要传参，则无需用圆括号包裹。</p>\n<pre><code class=\"hljs language-properties\">rewrite ^<span class=\"hljs-regexp\">/c_[0-9]+/</span>(.*)<span class=\"hljs-variable\">$ </span>/comm/<span class=\"hljs-variable\">$1</span> <span class=\"hljs-keyword\">break</span>;\n<span class=\"hljs-comment\"># 上方规则仅仅对第二部分进行传参匹配</span>\n<span class=\"hljs-comment\"># 比如：/c_1/go =&gt;/comm/go  /c_1/xx/mo =&gt;/comm/xx/mo</span>\n</code></pre>\n<h2 id=\"menu_9\">引入规则配置文件</h2><p>rewrite不一定需要完全在配置文件中配置，可以单独引入。</p>\n<pre><code class=\"hljs language-properties\"><span class=\"hljs-comment\"># REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效</span>\n<span class=\"hljs-keyword\">include</span> /www/server/rewrite/mebugs.conf;\n<span class=\"hljs-comment\"># REWRITE-END</span>\n<span class=\"hljs-comment\"># 配置文件不一定要.conf，.htaccess 也是可以的</span>\n</code></pre>\n<h2 id=\"menu_10\">活用一些全局变量</h2><p>配置rewrite规则时可以引入一些Nginx的全局变量，甚至增加if条件判断，可以实现更为复杂的规则配置。</p>\n<pre><code class=\"hljs language-properties\"><span class=\"hljs-comment\"># 如果访问的是mebugs.com的任意子域名才生效如下规则</span>\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">$host</span> ~* (.*)/.mebugs/.com) {\n    rewrite ^<span class=\"hljs-regexp\">/page_([a-z]+)_(d+)_.html$  /page</span>.php?type=<span class=\"hljs-variable\">$1</span>&amp;current=<span class=\"hljs-variable\">$2</span> last;\n}\n<span class=\"hljs-comment\"># 特定子域名访问子目录</span>\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">$http_host</span> ~ me/.mebugs/.com<span class=\"hljs-variable\">$)</span> {\nrewrite ^(.*) /me/<span class=\"hljs-variable\">$1</span> <span class=\"hljs-keyword\">break</span>;\n}\n</code></pre>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">关于rewrite</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">rewrite的作用</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">rewrite的语法</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">正则&lt;regex&gt;</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">替代内容&lt;replacement&gt;</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">标记[flag]</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl1\">其他注意点</a> <ul><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl2\">正则匹配传参部分才需要圆括号</a> <!----></li><li><a href=\"javascript:runTo(\'menu_9\')\" class=\"pl2\">引入规则配置文件</a> <!----></li><li><a href=\"javascript:runTo(\'menu_10\')\" class=\"pl2\">活用一些全局变量</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1014, '# 需求描述\n\nuni-app的开发实际上本身就是在WebView上开发，只不过很多时候加载的是本地的网页资源。\n\n而在uni-app中嵌入一个网络页面（外部资源），官方也提供了案例就是vue页面中在创建一个web-view标签。\n\n```html\n<template>\n    <view>\n        <web-view src=\"http://www.mebugs.com/\"></web-view>\n    </view>\n</template>\n```\n\n加载一个网络页面需要解决一个比较尴尬的问题就是网页中做的导航和原生导航共存的问题。\n\n对于APP而言，我们希望尽量使用原生导航，所以在实现中往往隐藏网页自带的导航，然后通过原生导航操作页面。\n\n于是会发现一个问题，原生导航的返回往往是返回到上一个页面（这里指的是uni-app工程里面的上一页）。\n\n# 解决方案\n\n## 无限WebView\n\n1. 创建一个公共的网络页面加载器（加载器就一个web-view组件，src属性需由外部传入）\n2. 网络页面识别访问者是APP时，触发新页面访问需要向父组件发送消息（消息内容为新URL），并阻断原生事件\n3. uni-app（加载器）监听消息，再次向加载器发起新的navigate跳转请求，携带新的消息中URL\n4. 触发跳转后的原生导航就是常规的返回\n\n优点：\n\n - 几乎与原生完全一致的体验\n - 前进后退的路由栈完全一致不会出错\n \n缺点：\n\n- 需要远端页面修改代码配合\n- 性能不好（疯狂开WebView性能当然不好）\n- 某些场景会不兼容，无限WebView类似于在浏览器上不断打开新Tab页，某些需要记录上一页或来源reffer的场景无法兼容\n\n## 获取webView对象处理\n\n1. 网络页面加载器（加载器就一个web-view组件，src属性可由外部传入）\n2. 获取当前页面的子WebView（实际加载网络页面的WebView）对象\n3. 监听子WebView对象并创建计数器\n4. 子WebView对象加载新页面是更新计数器\n5. 触发原生返回按钮时根据计数器判断执行子WebView回退还是页面navigateBack\n\n```html\n<template>\n    <view>\n        <web-view src=\"http://www.mebugs.com/\"></web-view>\n    </view>\n</template>\n\n<script>\n	export default {\n		onNavigationBarButtonTap(e) {\n			var index = e.index;\n			if(index == 0) {\n				// 如果计数器>1 执行自WebView回退\n				if(this.index > 1) {\n					this.back()\n				}else{\n					// 框架回退\n					uni.navigateBack()  \n				}\n			}\n			// 个人中心\n			if(index == 1)\n			uni.navigateTo({\n			    url: \'/pages/index/mine\'\n			})\n		},\n        data() {\n            return {\n				currentWebview: false,\n				view: false,\n				index: 0\n            }\n        },\n		onReady() { \n			this.initWebview()\n		},\n		methods: {\n		    initWebview() { //初始化并获取子WebView\n				// #ifdef APP-PLUS\n				this.currentWebview = this.$scope.$getAppWebview() \n				let this_ = this\n				// 避免初始化失败 延时判断\n				setTimeout(function() {\n				    this_.view = this_.currentWebview.children()[0]\n					if(this_.view) {\n						// 子WebView绑定打开新页面触发的事件方法\n						this_.view.onloading = this_.loadNewUrl()\n					}else{\n						// 如果子WebView还是没有 递归获取\n						this_.initWebview()\n					}\n				}, 1000)\n				// #endif\n			},\n			back() {\n				// 子webView回退\n				this.view.back()\n				this.index = this.index - 1\n			},\n			loadNewUrl() {\n				// 计数器增加\n				this.index = this.index + 1\n			}\n		}\n    }\n</script>\n```\n\n# 实现效果\n\n\n![/static/upload/post/1645527176903.jpg](/static/upload/post/1645527176903.jpg)\n\n', '<h1 id=\"menu_1\">需求描述</h1><p>uni-app的开发实际上本身就是在WebView上开发，只不过很多时候加载的是本地的网页资源。</p>\n<p>而在uni-app中嵌入一个网络页面（外部资源），官方也提供了案例就是vue页面中在创建一个web-view标签。</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">view</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">web-view</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;http://www.mebugs.com/&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">web-view</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">view</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n</code></pre>\n<p>加载一个网络页面需要解决一个比较尴尬的问题就是网页中做的导航和原生导航共存的问题。</p>\n<p>对于APP而言，我们希望尽量使用原生导航，所以在实现中往往隐藏网页自带的导航，然后通过原生导航操作页面。</p>\n<p>于是会发现一个问题，原生导航的返回往往是返回到上一个页面（这里指的是uni-app工程里面的上一页）。</p>\n<h1 id=\"menu_2\">解决方案</h1><h2 id=\"menu_3\">无限WebView</h2><ol>\n<li>创建一个公共的网络页面加载器（加载器就一个web-view组件，src属性需由外部传入）</li>\n<li>网络页面识别访问者是APP时，触发新页面访问需要向父组件发送消息（消息内容为新URL），并阻断原生事件</li>\n<li>uni-app（加载器）监听消息，再次向加载器发起新的navigate跳转请求，携带新的消息中URL</li>\n<li>触发跳转后的原生导航就是常规的返回</li>\n</ol>\n<p>优点：</p>\n<ul>\n<li>几乎与原生完全一致的体验</li>\n<li>前进后退的路由栈完全一致不会出错</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>需要远端页面修改代码配合</li>\n<li>性能不好（疯狂开WebView性能当然不好）</li>\n<li>某些场景会不兼容，无限WebView类似于在浏览器上不断打开新Tab页，某些需要记录上一页或来源reffer的场景无法兼容</li>\n</ul>\n<h2 id=\"menu_4\">获取webView对象处理</h2><ol>\n<li>网络页面加载器（加载器就一个web-view组件，src属性可由外部传入）</li>\n<li>获取当前页面的子WebView（实际加载网络页面的WebView）对象</li>\n<li>监听子WebView对象并创建计数器</li>\n<li>子WebView对象加载新页面是更新计数器</li>\n<li>触发原生返回按钮时根据计数器判断执行子WebView回退还是页面navigateBack</li>\n</ol>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">view</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">web-view</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;http://www.mebugs.com/&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">web-view</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">view</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n        <span class=\"hljs-title function_\">onNavigationBarButtonTap</span>(<span class=\"hljs-params\">e</span>) {\n            <span class=\"hljs-keyword\">var</span> index = e.<span class=\"hljs-property\">index</span>;\n            <span class=\"hljs-keyword\">if</span>(index == <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-comment\">// 如果计数器&gt;1 执行自WebView回退</span>\n                <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">index</span> &gt; <span class=\"hljs-number\">1</span>) {\n                    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">back</span>()\n                }<span class=\"hljs-keyword\">else</span>{\n                    <span class=\"hljs-comment\">// 框架回退</span>\n                    uni.<span class=\"hljs-title function_\">navigateBack</span>()  \n                }\n            }\n            <span class=\"hljs-comment\">// 个人中心</span>\n            <span class=\"hljs-keyword\">if</span>(index == <span class=\"hljs-number\">1</span>)\n            uni.<span class=\"hljs-title function_\">navigateTo</span>({\n                <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&#x27;/pages/index/mine&#x27;</span>\n            })\n        },\n        <span class=\"hljs-title function_\">data</span>(<span class=\"hljs-params\"></span>) {\n            <span class=\"hljs-keyword\">return</span> {\n                <span class=\"hljs-attr\">currentWebview</span>: <span class=\"hljs-literal\">false</span>,\n                <span class=\"hljs-attr\">view</span>: <span class=\"hljs-literal\">false</span>,\n                <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">0</span>\n            }\n        },\n        <span class=\"hljs-title function_\">onReady</span>(<span class=\"hljs-params\"></span>) { \n            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">initWebview</span>()\n        },\n        <span class=\"hljs-attr\">methods</span>: {\n            <span class=\"hljs-title function_\">initWebview</span>(<span class=\"hljs-params\"></span>) { <span class=\"hljs-comment\">//初始化并获取子WebView</span>\n                <span class=\"hljs-comment\">// #ifdef APP-PLUS</span>\n                <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">currentWebview</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$scope</span>.$getAppWebview() \n                <span class=\"hljs-keyword\">let</span> this_ = <span class=\"hljs-variable language_\">this</span>\n                <span class=\"hljs-comment\">// 避免初始化失败 延时判断</span>\n                <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n                    this_.<span class=\"hljs-property\">view</span> = this_.<span class=\"hljs-property\">currentWebview</span>.<span class=\"hljs-title function_\">children</span>()[<span class=\"hljs-number\">0</span>]\n                    <span class=\"hljs-keyword\">if</span>(this_.<span class=\"hljs-property\">view</span>) {\n                        <span class=\"hljs-comment\">// 子WebView绑定打开新页面触发的事件方法</span>\n                        this_.<span class=\"hljs-property\">view</span>.<span class=\"hljs-property\">onloading</span> = this_.<span class=\"hljs-title function_\">loadNewUrl</span>()\n                    }<span class=\"hljs-keyword\">else</span>{\n                        <span class=\"hljs-comment\">// 如果子WebView还是没有 递归获取</span>\n                        this_.<span class=\"hljs-title function_\">initWebview</span>()\n                    }\n                }, <span class=\"hljs-number\">1000</span>)\n                <span class=\"hljs-comment\">// #endif</span>\n            },\n            <span class=\"hljs-title function_\">back</span>(<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-comment\">// 子webView回退</span>\n                <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">view</span>.<span class=\"hljs-title function_\">back</span>()\n                <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">index</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">index</span> - <span class=\"hljs-number\">1</span>\n            },\n            <span class=\"hljs-title function_\">loadNewUrl</span>(<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-comment\">// 计数器增加</span>\n                <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">index</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">index</span> + <span class=\"hljs-number\">1</span>\n            }\n        }\n    }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<h1 id=\"menu_5\">实现效果</h1><p><img src=\"/static/upload/post/1645527176903.jpg\" alt=\"/static/upload/post/1645527176903.jpg\"/></p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">需求描述</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">解决方案</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">无限WebView</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">获取webView对象处理</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">实现效果</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1015, '# MySql默认规则\n\nWindows下所有内容大小写不敏感。\n\nLinux下默认大小写规则如下：\n\n - 数据库名与表名严格区分大小写\n - 表别名严格区分大小写\n - 列名和列别名在所有情况下都是忽略大小写的\n - 变量名也是严格区分大小写的\n\n# 相关变量\n\nlower_case_file_system：数据目录所在的文件系统对文件名的大小写敏感\n\n - ON：大小写不敏感\n - OFF：敏感\n\nlower_case_table_names：表名与数据库名大小写敏感\n\n - 0：创建时按大小写字母保存表名和数据库名，比较时对大小写敏感（在大小写本身不敏感的系统中不能将其设置为0，可能导致索引被破坏）\n - 1：创建时**按小写字母**保存，比较时对大小写不敏感\n - 2：创建时按大小写字母保存表名和数据库名，比较时会转为小写查询（只在对大小写不敏感的文件系统上适用）\n\n\n![/static/upload/post/1645666136169.png](/static/upload/post/1645666136169.png)\n\n\n# Linux修改大小写不敏感\n\n```shell\nvi /etc/my.cnf\n# 添加或修改\nlower_case_table_names=1\n# 重启MySql\n# 使用 service 启动\nservice mysqld restart\n# 使用 mysqld 脚本启动\n/etc/inint.d/mysqld restart\n```\n\n# 其他说明\n\n一般来说在建库配置之初就应当确认好是否需要大小写敏感。\n\n为了避免大小写引发的问题，一种推荐的命名规则是：\n\n在定义数据库、表、列的时候全部采用小写字母加下划线的方式，不使用任何大写字母\n\n因为lower_case_table_names并不是个动态参数，修改需要重启数据库\n\n同时对于库中已有的大些字母表名或库名需要导出重新导入\n\n简而言之，这是个麻烦事儿\n', '<h1 id=\"menu_1\">MySql默认规则</h1><p>Windows下所有内容大小写不敏感。</p>\n<p>Linux下默认大小写规则如下：</p>\n<ul>\n<li>数据库名与表名严格区分大小写</li>\n<li>表别名严格区分大小写</li>\n<li>列名和列别名在所有情况下都是忽略大小写的</li>\n<li>变量名也是严格区分大小写的</li>\n</ul>\n<h1 id=\"menu_2\">相关变量</h1><p>lower_case_file_system：数据目录所在的文件系统对文件名的大小写敏感</p>\n<ul>\n<li>ON：大小写不敏感</li>\n<li>OFF：敏感</li>\n</ul>\n<p>lower_case_table_names：表名与数据库名大小写敏感</p>\n<ul>\n<li>0：创建时按大小写字母保存表名和数据库名，比较时对大小写敏感（在大小写本身不敏感的系统中不能将其设置为0，可能导致索引被破坏）</li>\n<li>1：创建时<strong>按小写字母</strong>保存，比较时对大小写不敏感</li>\n<li>2：创建时按大小写字母保存表名和数据库名，比较时会转为小写查询（只在对大小写不敏感的文件系统上适用）</li>\n</ul>\n<p><img src=\"/static/upload/post/1645666136169.png\" alt=\"/static/upload/post/1645666136169.png\"/></p>\n<h1 id=\"menu_3\">Linux修改大小写不敏感</h1><pre><code class=\"hljs language-shell\">vi /etc/my.cnf\n<span class=\"hljs-comment\"># 添加或修改</span>\nlower_case_table_names=1\n<span class=\"hljs-comment\"># 重启MySql</span>\n<span class=\"hljs-comment\"># 使用 service 启动</span>\nservice mysqld restart\n<span class=\"hljs-comment\"># 使用 mysqld 脚本启动</span>\n/etc/inint.d/mysqld restart\n</code></pre>\n<h1 id=\"menu_4\">其他说明</h1><p>一般来说在建库配置之初就应当确认好是否需要大小写敏感。</p>\n<p>为了避免大小写引发的问题，一种推荐的命名规则是：</p>\n<p>在定义数据库、表、列的时候全部采用小写字母加下划线的方式，不使用任何大写字母</p>\n<p>因为lower_case_table_names并不是个动态参数，修改需要重启数据库</p>\n<p>同时对于库中已有的大些字母表名或库名需要导出重新导入</p>\n<p>简而言之，这是个麻烦事儿</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">MySql默认规则</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">相关变量</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">Linux修改大小写不敏感</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">其他说明</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1016, '# 实现说明\n\n为什么通过MyBatis-Plus能够实现快速开发？\n\n深入查看其结构你会发现，MyBatis-Plus某种意义上来说就是一个已经搭建好的开发脚手架。\n\n通过Spring泛型能力，实际业务Service类继承IService类便可调用父类已经封装好的方法。\n\n此外，业务Mapper类继承BaseMapper同理。\n\nMyBatis-Plus核心类：IService、ServiceImpl、BaseMapper（泛型入参）。\n\n关于泛型本文不再过多赘述，很多SSM和SSH整合教程中均有大量描述。\n\n# IService常用方法\n\n本文不会全部列举所有方法，仅对常用的方法举例。\n\n调用方法**this.**\n\n## 更新数据\n\n```java\n// 插入一条新数据\nboolean save(T entity)\n// 插入或更新一条数据\n// 这里的实现是先查后插（务必注意实体类需要有@TableId主键）\nboolean saveOrUpdate(T entity)\n//  @TableId(value = \"id\", type = IdType.AUTO) 主键可以是自增也可以是INPUT\n// 批量插入\nboolean saveBatch(Collection<T> entityList)\n// 批量插入或更新（实际应用为了数据可控不经常直接掉这个方法）\nboolean saveOrUpdateBatch(Collection<T> entityList)\n// 更新数据，实体类需要有@TableId主键\nboolean updateById(T entity)\n// 通过自定Lambda实现更新\nboolean update(Wrapper<T> updateWrapper)\n```\n\n### Lambda更新语法\n\n```java\n// 直接写在方法内（简单条件）\n// 拼接出来的SQL：UPDATE `user` u SET u.`user_name` = \'UPDATE\' WHERE u.`id` = 1\nthis.update(Wrappers.<User>lambdaUpdate().set(User::getUserName,\"UPDATE\").eq(User::getId,1));\n// 条件拼接（复杂拼接）\n// 此处简单举例，理解其中的意思即可\nLambdaUpdateWrapper<User> updateWrapper = Wrappers.lambdaUpdate();\nif(StringUtils.isNotBlank(user.getUserName())){\n	updateWrapper.set(User::getUserName,user.getUserName());\n}\nif(user.getId() !=null) {\n	 updateWrapper.eq(User::getId,user.getId());\n}\nthis.update(updateWrapper);\n```\n\n## 查询数据\n\n```java\n// 根据主键查询对象\nT getById(Serializable id)\n// 根据自定义Lambda查询对象\n// 务必注意如果返回结果为多条getOne会报错\nT getOne(Wrapper<T> queryWrapper)\n// 根据自定义Lambda数目\nint count(Wrapper<T> queryWrapper)\n// 查询全表数据\nList<T> list()\n// 根据自定义Lambda查询列表\nList<T> list(Wrapper<T> queryWrapper)\n// 查询全表分页\n// 返回可以是IPage接口也可以是任意的IPage实现类\n<E extends IPage<T>> E page(E page)\n// 根据自定义Lambda查询分页\n<E extends IPage<T>> E page(E page, Wrapper<T> queryWrapper)\n// 根据自定义Lambda查询一个Map类型的列表\n// Map类型的返回比较适用于自行封装的方法\n// 比如有很多类似的业务表想进行统一封装查询就可以用Map返回\nList<Map<String, Object>> listMaps(Wrapper<T> queryWrapper)\n```\n\n### Lambda查询语法\n\n```java\n// 如上方的更新一样，查询也可以直接入参到方法也可以单独写\n// 以分页举例\nLambdaQueryWrapper<User> queryWrapper = Wrappers.lambdaQuery();\nif(StringUtils.isNotBlank(user.getUserName())){\n	queryWrapper.like(User::getUserName,user.getUserName());\n}\nif(user.getId() !=null) {\n	queryWrapper.eq(User::getId,user.getId());\n}\nthis.page(page,queryWrapper);\n```\n\n## 删除方法\n\n```java\n// 现阶段绝大多数系统都会采用软删除模式\n// 修改如status字段进行数据隐藏，因此删除的方法几乎不怎么用\n// 基于主键删除\nboolean removeById(Serializable id)\n// 基于自定义Lambda删除\nboolean remove(Wrapper<T> queryWrapper)\n```\n\n# BaseMapper常用方法\n\n实际上IService中有很多方法都是直接或间接调用BaseMapper完成数据库操作的。\n\n在业务Service想要使用Mapper无需注入，直接**this.baseMapper.**即可。\n\n## 常用方法\n\n```java\n// 插入数据（等同于save()）\nint insert(T entity)\n// 根据自定义Lambda查询对象（等同于getOne()）\nint insert(T entity)T selectOne(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper)\n```\n\n##  BaseMapper使用说明\n\n一般我们如果需要调用MyBatis-Plus提供的方法时，不怎么获取用this.baseMapper操作。\n\nthis.baseMapper主要作用是调用自己在业务Mapper中定义的方法。\n\n```java\npublic interface UserMapper extends BaseMapper<User> {\n	/**\n	 * 根据页面定制对象查询用户\n	 * @param page\n	 * @param status\n	 * @return\n	 */\n	IPage<UserVo> pageForVo(Page page, Integer status);\n	\n}\n// UserServiceImpl可以直接调用\nthis.baseMapper.pageForVo(page,null);\n```', '<h1 id=\"menu_1\">实现说明</h1><p>为什么通过MyBatis-Plus能够实现快速开发？</p>\n<p>深入查看其结构你会发现，MyBatis-Plus某种意义上来说就是一个已经搭建好的开发脚手架。</p>\n<p>通过Spring泛型能力，实际业务Service类继承IService类便可调用父类已经封装好的方法。</p>\n<p>此外，业务Mapper类继承BaseMapper同理。</p>\n<p>MyBatis-Plus核心类：IService、ServiceImpl、BaseMapper（泛型入参）。</p>\n<p>关于泛型本文不再过多赘述，很多SSM和SSH整合教程中均有大量描述。</p>\n<h1 id=\"menu_2\">IService常用方法</h1><p>本文不会全部列举所有方法，仅对常用的方法举例。</p>\n<p>调用方法<strong>this.</strong></p>\n<h2 id=\"menu_3\">更新数据</h2><pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// 插入一条新数据</span>\n<span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">save</span><span class=\"hljs-params\">(T entity)</span>\n<span class=\"hljs-comment\">// 插入或更新一条数据</span>\n<span class=\"hljs-comment\">// 这里的实现是先查后插（务必注意实体类需要有@TableId主键）</span>\n<span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">saveOrUpdate</span><span class=\"hljs-params\">(T entity)</span>\n<span class=\"hljs-comment\">//  @TableId(value = &quot;id&quot;, type = IdType.AUTO) 主键可以是自增也可以是INPUT</span>\n<span class=\"hljs-comment\">// 批量插入</span>\n<span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">saveBatch</span><span class=\"hljs-params\">(Collection&lt;T&gt; entityList)</span>\n<span class=\"hljs-comment\">// 批量插入或更新（实际应用为了数据可控不经常直接掉这个方法）</span>\n<span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">saveOrUpdateBatch</span><span class=\"hljs-params\">(Collection&lt;T&gt; entityList)</span>\n<span class=\"hljs-comment\">// 更新数据，实体类需要有@TableId主键</span>\n<span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">updateById</span><span class=\"hljs-params\">(T entity)</span>\n<span class=\"hljs-comment\">// 通过自定Lambda实现更新</span>\n<span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">update</span><span class=\"hljs-params\">(Wrapper&lt;T&gt; updateWrapper)</span>\n</code></pre>\n<h3 id=\"menu_4\">Lambda更新语法</h3><pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// 直接写在方法内（简单条件）</span>\n<span class=\"hljs-comment\">// 拼接出来的SQL：UPDATE `user` u SET u.`user_name` = &#x27;UPDATE&#x27; WHERE u.`id` = 1</span>\n<span class=\"hljs-keyword\">this</span>.update(Wrappers.&lt;User&gt;lambdaUpdate().<span class=\"hljs-keyword\">set</span>(User::getUserName,<span class=\"hljs-string\">&quot;UPDATE&quot;</span>).eq(User::getId,<span class=\"hljs-number\">1</span>));\n<span class=\"hljs-comment\">// 条件拼接（复杂拼接）</span>\n<span class=\"hljs-comment\">// 此处简单举例，理解其中的意思即可</span>\nLambdaUpdateWrapper&lt;User&gt; updateWrapper = Wrappers.lambdaUpdate();\n<span class=\"hljs-keyword\">if</span>(StringUtils.isNotBlank(user.getUserName())){\n    updateWrapper.<span class=\"hljs-keyword\">set</span>(User::getUserName,user.getUserName());\n}\n<span class=\"hljs-keyword\">if</span>(user.getId() !=<span class=\"hljs-literal\">null</span>) {\n     updateWrapper.eq(User::getId,user.getId());\n}\n<span class=\"hljs-keyword\">this</span>.update(updateWrapper);\n</code></pre>\n<h2 id=\"menu_5\">查询数据</h2><pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// 根据主键查询对象</span>\nT <span class=\"hljs-title function_\">getById</span><span class=\"hljs-params\">(Serializable id)</span>\n<span class=\"hljs-comment\">// 根据自定义Lambda查询对象</span>\n<span class=\"hljs-comment\">// 务必注意如果返回结果为多条getOne会报错</span>\nT <span class=\"hljs-title function_\">getOne</span><span class=\"hljs-params\">(Wrapper&lt;T&gt; queryWrapper)</span>\n<span class=\"hljs-comment\">// 根据自定义Lambda数目</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">count</span><span class=\"hljs-params\">(Wrapper&lt;T&gt; queryWrapper)</span>\n<span class=\"hljs-comment\">// 查询全表数据</span>\nList&lt;T&gt; <span class=\"hljs-title function_\">list</span><span class=\"hljs-params\">()</span>\n<span class=\"hljs-comment\">// 根据自定义Lambda查询列表</span>\nList&lt;T&gt; <span class=\"hljs-title function_\">list</span><span class=\"hljs-params\">(Wrapper&lt;T&gt; queryWrapper)</span>\n<span class=\"hljs-comment\">// 查询全表分页</span>\n<span class=\"hljs-comment\">// 返回可以是IPage接口也可以是任意的IPage实现类</span>\n&lt;E <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">IPage</span>&lt;T&gt;&gt; E <span class=\"hljs-title function_\">page</span><span class=\"hljs-params\">(E page)</span>\n<span class=\"hljs-comment\">// 根据自定义Lambda查询分页</span>\n&lt;E <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">IPage</span>&lt;T&gt;&gt; E <span class=\"hljs-title function_\">page</span><span class=\"hljs-params\">(E page, Wrapper&lt;T&gt; queryWrapper)</span>\n<span class=\"hljs-comment\">// 根据自定义Lambda查询一个Map类型的列表</span>\n<span class=\"hljs-comment\">// Map类型的返回比较适用于自行封装的方法</span>\n<span class=\"hljs-comment\">// 比如有很多类似的业务表想进行统一封装查询就可以用Map返回</span>\nList&lt;Map&lt;String, Object&gt;&gt; <span class=\"hljs-title function_\">listMaps</span><span class=\"hljs-params\">(Wrapper&lt;T&gt; queryWrapper)</span>\n</code></pre>\n<h3 id=\"menu_6\">Lambda查询语法</h3><pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// 如上方的更新一样，查询也可以直接入参到方法也可以单独写</span>\n<span class=\"hljs-comment\">// 以分页举例</span>\nLambdaQueryWrapper&lt;User&gt; queryWrapper = Wrappers.lambdaQuery();\n<span class=\"hljs-keyword\">if</span>(StringUtils.isNotBlank(user.getUserName())){\n    queryWrapper.like(User::getUserName,user.getUserName());\n}\n<span class=\"hljs-keyword\">if</span>(user.getId() !=<span class=\"hljs-literal\">null</span>) {\n    queryWrapper.eq(User::getId,user.getId());\n}\nthis.page(page,queryWrapper);\n</code></pre>\n<h2 id=\"menu_7\">删除方法</h2><pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// 现阶段绝大多数系统都会采用软删除模式</span>\n<span class=\"hljs-comment\">// 修改如status字段进行数据隐藏，因此删除的方法几乎不怎么用</span>\n<span class=\"hljs-comment\">// 基于主键删除</span>\n<span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">removeById</span><span class=\"hljs-params\">(Serializable id)</span>\n<span class=\"hljs-comment\">// 基于自定义Lambda删除</span>\n<span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(Wrapper&lt;T&gt; queryWrapper)</span>\n</code></pre>\n<h1 id=\"menu_8\">BaseMapper常用方法</h1><p>实际上IService中有很多方法都是直接或间接调用BaseMapper完成数据库操作的。</p>\n<p>在业务Service想要使用Mapper无需注入，直接**this.baseMapper.**即可。</p>\n<h2 id=\"menu_9\">常用方法</h2><pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// 插入数据（等同于save()）</span>\n<span class=\"hljs-selector-tag\">int</span> <span class=\"hljs-selector-tag\">insert</span>(T entity)\n<span class=\"hljs-comment\">// 根据自定义Lambda查询对象（等同于getOne()）</span>\n<span class=\"hljs-selector-tag\">int</span> <span class=\"hljs-selector-tag\">insert</span>(T entity)<span class=\"hljs-selector-tag\">T</span> <span class=\"hljs-selector-tag\">selectOne</span>(<span class=\"hljs-variable\">@Param</span>(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper)\n</code></pre>\n<h2 id=\"menu_10\">BaseMapper使用说明</h2><p>一般我们如果需要调用MyBatis-Plus提供的方法时，不怎么获取用this.baseMapper操作。</p>\n<p>this.baseMapper主要作用是调用自己在业务Mapper中定义的方法。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">UserMapper</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseMapper</span>&lt;User&gt; {\n    <span class=\"hljs-comment\">/**\n     * 根据页面定制对象查询用户\n     * <span class=\"hljs-doctag\">@param</span> page\n     * <span class=\"hljs-doctag\">@param</span> status\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    IPage&lt;UserVo&gt; <span class=\"hljs-title function_\">pageForVo</span><span class=\"hljs-params\">(Page page, Integer status)</span>;\n    \n}\n<span class=\"hljs-comment\">// UserServiceImpl可以直接调用</span>\n<span class=\"hljs-built_in\">this</span>.baseMapper.pageForVo(page,<span class=\"hljs-literal\">null</span>);\n</code></pre>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">实现说明</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">IService常用方法</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">更新数据</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl3\">Lambda更新语法</a></li></ul></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">查询数据</a> <ul><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl3\">Lambda查询语法</a></li></ul></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">删除方法</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl1\">BaseMapper常用方法</a> <ul><li><a href=\"javascript:runTo(\'menu_9\')\" class=\"pl2\">常用方法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_10\')\" class=\"pl2\">BaseMapper使用说明</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1017, '# 保留请求日志\n## 需求描述\n\n默认情况下，Chrome浏览器再打开新页面或刷新当前页的时候，请求数据会被清空。\n\n但是在某些特殊场景下，开发者需要检查上一步（上一页）的请求是否正常返回。\n\n如：登录页、下单页等。\n\n## Preserve log 按钮\n\nNetwork标签中，工具栏一行中，有一个红色圆点和清空按钮（这个大家应该都比较清楚）。\n\n	- 红色圆点按钮的时候表示当前的请求不被清空。\n	- 但当重载页面或者跳转到新的页面，那么请求也会被清空。\n	- 清空按钮则是直接清空当前保存的所有请求信息。\n\n\n![/static/upload/post/1645683593372.png](/static/upload/post/1645683593372.png)\n\n\n在放大镜按钮后方有一个**Preserve log多选框**。\n\n如果勾选后，无论刷新页面还是打开新页面，只要是在**当前Tab下**操作的所有请求信息均会被保存。\n\n注意：如果通过新Tab页打开依旧无法保存请求记录。\n\n# 请求过滤器\n## 需求描述\n\n页面请求非常多的时候，我们手工寻找某个请求非常困难？\n\n某些固定的请求非常多的时候，想看的核心请求非常困难？\n\n## 过滤\n\n过滤器位于下图中的红点按钮下方，Filter输入框，默认是没有值，显示全部请求。\n\n某些类型过滤，可以直接点击下图所示的快速分类Tab页。\n\n\n![/static/upload/post/1645684293715.png](/static/upload/post/1645684293715.png)\n\n\n### 一般过滤\n\n直接输入内容进行匹配。\n\n如： .css匹配所有CSS请求文件\n\n### 高级过滤\n\n规则配置，以 -（中划线）开头。\n\n当输入-时，会为您联想很多快速命令。\n\n\n![/static/upload/post/1645684302455.png](/static/upload/post/1645684302455.png)\n\n\n特别注意：\n\n> -（中划线）可以给你提示，但是它本身的含义是**取反**，实际需求中过滤规则可能不要 -（中划线）\n\n本文仅作抛砖引玉：\n\n\n - -info（取反：请求中包含info的不显示）\n - -info -logo（取反：请求中包含info或者logo的不显示）\n - method:POST（仅显示POST请求）\n - domain:192.168.1.3（仅显示向192.168.1.3发出的请求）\n\n', '<h1 id=\"menu_1\">保留请求日志</h1><h2 id=\"menu_2\">需求描述</h2><p>默认情况下，Chrome浏览器再打开新页面或刷新当前页的时候，请求数据会被清空。</p>\n<p>但是在某些特殊场景下，开发者需要检查上一步（上一页）的请求是否正常返回。</p>\n<p>如：登录页、下单页等。</p>\n<h2 id=\"menu_3\">Preserve log 按钮</h2><p>Network标签中，工具栏一行中，有一个红色圆点和清空按钮（这个大家应该都比较清楚）。</p>\n<pre><code><span class=\"hljs-bullet\">-</span> 红色圆点按钮的时候表示当前的请求不被清空。\n<span class=\"hljs-bullet\">-</span> 但当重载页面或者跳转到新的页面，那么请求也会被清空。\n<span class=\"hljs-bullet\">-</span> 清空按钮则是直接清空当前保存的所有请求信息。\n</code></pre>\n<p><img src=\"/static/upload/post/1645683593372.png\" alt=\"/static/upload/post/1645683593372.png\"/></p>\n<p>在放大镜按钮后方有一个<strong>Preserve log多选框</strong>。</p>\n<p>如果勾选后，无论刷新页面还是打开新页面，只要是在<strong>当前Tab下</strong>操作的所有请求信息均会被保存。</p>\n<p>注意：如果通过新Tab页打开依旧无法保存请求记录。</p>\n<h1 id=\"menu_4\">请求过滤器</h1><h2 id=\"menu_5\">需求描述</h2><p>页面请求非常多的时候，我们手工寻找某个请求非常困难？</p>\n<p>某些固定的请求非常多的时候，想看的核心请求非常困难？</p>\n<h2 id=\"menu_6\">过滤</h2><p>过滤器位于下图中的红点按钮下方，Filter输入框，默认是没有值，显示全部请求。</p>\n<p>某些类型过滤，可以直接点击下图所示的快速分类Tab页。</p>\n<p><img src=\"/static/upload/post/1645684293715.png\" alt=\"/static/upload/post/1645684293715.png\"/></p>\n<h3 id=\"menu_7\">一般过滤</h3><p>直接输入内容进行匹配。</p>\n<p>如： .css匹配所有CSS请求文件</p>\n<h3 id=\"menu_8\">高级过滤</h3><p>规则配置，以 -（中划线）开头。</p>\n<p>当输入-时，会为您联想很多快速命令。</p>\n<p><img src=\"/static/upload/post/1645684302455.png\" alt=\"/static/upload/post/1645684302455.png\"/></p>\n<p>特别注意：</p>\n<blockquote>\n<p>-（中划线）可以给你提示，但是它本身的含义是<strong>取反</strong>，实际需求中过滤规则可能不要 -（中划线）</p>\n</blockquote>\n<p>本文仅作抛砖引玉：</p>\n<ul>\n<li>-info（取反：请求中包含info的不显示）</li>\n<li>-info -logo（取反：请求中包含info或者logo的不显示）</li>\n<li>method:POST（仅显示POST请求）</li>\n<li>domain:192.168.1.3（仅显示向192.168.1.3发出的请求）</li>\n</ul>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">保留请求日志</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">需求描述</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">Preserve log 按钮</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">请求过滤器</a> <ul><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">需求描述</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">过滤</a> <ul><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl3\">一般过滤</a></li><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl3\">高级过滤</a></li></ul></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1018, '# 创建线程\n\n## 继承Thread类\n\n```java\n/**\n * 通过继承Thread类实现多线程\n */\npublic class MyThread extends Thread {\n    public MyThread() {\n        System.out.println(\"构造！调用线程名：\"+Thread.currentThread().getName());\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"线程启动了！本线程名：\"+getName());\n        for(int i=0;i<100;i++){\n            System.out.println(getName()+\"++\"+ i);\n        }\n\n    }\n\n    // 测试代码\n    public static void main(String[] args)\n    {\n        // 直接创建自定的继承类\n        new MyThread().start();\n        new MyThread().start();\n    }\n}\n```\n\n## 实现Runnable接口\n\n```java\n/**\n * 通过实现Runnable接口创建线程类\n */\npublic class MyRunnable implements Runnable   {\n\n    @Override\n    public void run() {\n        System.out.println(\"线程启动了！\");\n    }\n\n    // 测试代码\n    public static void main(String[] args)\n    {\n        // 直接运行\n        new Thread(new MyRunnable()).start();\n        // 想获取当前线程的信息\n        Thread thread = new Thread(new MyRunnable());\n        thread.start();\n        System.out.println(\"线程启动了！线程的名字;\"+thread.getName());\n        // 匿名内部类写法\n        new Thread(new Runnable(){\n            @Override\n            public void run() {\n                System.out.println(\"匿名内部类线程启动了！\");\n            }\n        }).start();\n        // JDK1.8 lambda写法\n        new Thread(() -> {\n            System.out.println(\"lambda写法匿名内部类线程启动了\");\n        }).start();\n    }\n}\n```\n\n## 实现Callable接口配合Future\n\n```java\n/**\n * 实现Callable接口配合Future创建线程\n */\npublic class MyCallable implements Callable<String> {\n    @Override\n    public String call() throws Exception {\n        Thread.sleep(5000);\n        System.out.println(\"子线程名：\"+Thread.currentThread().getName());\n        return \"返回值1\";\n    }\n\n    // 测试代码\n    public static void main(String[] args)\n    {\n        MyCallable myCallable = new MyCallable();\n        // FutureTask能用来包装一个Callable或Runnable对象，因为它实现了Runnable接口，而且它能被传递到Executor进行执行\n        // RunnableFuture接口同时继承Future接口和Runnable接口，在执行run()方法后，可以通过Future访问执行结果，实现类是FutureTask\n        FutureTask<String> task =  new FutureTask<String>(myCallable);\n        new Thread(task).start();\n        try {\n            //取消任务\n            //task.cancel(true);\n            //完成状态\n            //task.isDone();\n            //取消状态\n            //System.out.println(\"子线程的取消了吗：\"+task.isCancelled());\n            System.out.println(\"子线程的返回值：\"+task.get());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n# 优缺点\n## 继承Thread类\n\n优点：\n\n - 编写简单\n - run()方法内访问当前线程，使用this即可\n\n缺点：\n\n - 线程类不能再继承其他父类\n\n## 实现Runnable或Callable接口\n\n优点：\n\n - 线程类只是实现了接口，还可以继承其他类\n - 多个线程可以共享同一个target对象，适合多个相同线程来处理同一份资源\n\n缺点：\n\n - （不算缺点的缺点）访问当前线程，则必须使用Thread.currentThread()方法\n\n\n# Runnable或Callable区别\n\nCallable方案（JDK1.5）可以理解为是Runnable的增强版，其关系如下：\n\n![/static/upload/post/1645745446619.png](/static/upload/post/1645745446619.png)\n\n区别如下：\n\n1. Callable的重写方法是call()，Runnable的重写方法是run()\n2. Callable的任务执行后可返回值，而Runnable的任务是不能返回值的\n3. Callable的call方法可以抛出异常，Runnable的run()方法不可以\n4. Callable任务可以拿到一个Future对象，表示异步计算的结果。\n\n提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。\n\n可以了解任务执行情况，可取消任务的执行，还可获取执行结果。\n\n# Future接口提供的方法\n\n## boolean cancel(boolean mayInterruptIfRunning)\n\n取消Future里关联的Callable任务\n\nmayInterruptIfRunning入参：是否允许在线程运行时中断\n\n## V get()\n\n返回Callable任务里call()方法的返回值\n\n调用该方法将导致程序阻塞，必须等到子线程结束以后才会得到返回值\n\n## V get(long timeout, TimeUnit unit)\n\n返回Callable任务里call()方法的返回值\n\n该方法让程序最多阻塞timeout和unit指定的时间\n\n如果经过指定时间后，Callable任务依然没有返回值，将会抛出TimeoutException异常\n\n## boolean isCancelled()\n\n如果Callable任务正常完成前被取消，则返回true\n\n## boolean isDone()\n\n如果Callable任务已经完成， 则返回true', '<h1 id=\"menu_1\">创建线程</h1><h2 id=\"menu_2\">继承Thread类</h2><pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">/**\n * 通过继承Thread类实现多线程\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyThread</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Thread</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">MyThread</span>() {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;构造！调用线程名：&quot;</span>+<span class=\"hljs-title class_\">Thread</span>.<span class=\"hljs-title function_\">currentThread</span>().<span class=\"hljs-title function_\">getName</span>());\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">run</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;线程启动了！本线程名：&quot;</span>+<span class=\"hljs-title function_\">getName</span>());\n        <span class=\"hljs-keyword\">for</span>(int i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">100</span>;i++){\n            <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-title function_\">getName</span>()+<span class=\"hljs-string\">&quot;++&quot;</span>+ i);\n        }\n\n    }\n\n    <span class=\"hljs-comment\">// 测试代码</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>)\n    {\n        <span class=\"hljs-comment\">// 直接创建自定的继承类</span>\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyThread</span>().<span class=\"hljs-title function_\">start</span>();\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyThread</span>().<span class=\"hljs-title function_\">start</span>();\n    }\n}\n</code></pre>\n<h2 id=\"menu_3\">实现Runnable接口</h2><pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">/**\n * 通过实现Runnable接口创建线程类\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyRunnable</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Runnable</span>   {\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">run</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;线程启动了！&quot;</span>);\n    }\n\n    <span class=\"hljs-comment\">// 测试代码</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>)\n    {\n        <span class=\"hljs-comment\">// 直接运行</span>\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyRunnable</span>()).<span class=\"hljs-title function_\">start</span>();\n        <span class=\"hljs-comment\">// 想获取当前线程的信息</span>\n        <span class=\"hljs-title class_\">Thread</span> thread = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyRunnable</span>());\n        thread.<span class=\"hljs-title function_\">start</span>();\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;线程启动了！线程的名字;&quot;</span>+thread.<span class=\"hljs-title function_\">getName</span>());\n        <span class=\"hljs-comment\">// 匿名内部类写法</span>\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Runnable</span>(){\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">run</span>(<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;匿名内部类线程启动了！&quot;</span>);\n            }\n        }).<span class=\"hljs-title function_\">start</span>();\n        <span class=\"hljs-comment\">// JDK1.8 lambda写法</span>\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(() -&gt; {\n            <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;lambda写法匿名内部类线程启动了&quot;</span>);\n        }).<span class=\"hljs-title function_\">start</span>();\n    }\n}\n</code></pre>\n<h2 id=\"menu_4\">实现Callable接口配合Future</h2><pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">/**\n * 实现Callable接口配合Future创建线程\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyCallable</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Callable</span>&lt;<span class=\"hljs-title class_\">String</span>&gt; {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">String</span> <span class=\"hljs-title function_\">call</span>() throws <span class=\"hljs-title class_\">Exception</span> {\n        <span class=\"hljs-title class_\">Thread</span>.<span class=\"hljs-title function_\">sleep</span>(<span class=\"hljs-number\">5000</span>);\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;子线程名：&quot;</span>+<span class=\"hljs-title class_\">Thread</span>.<span class=\"hljs-title function_\">currentThread</span>().<span class=\"hljs-title function_\">getName</span>());\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;返回值1&quot;</span>;\n    }\n\n    <span class=\"hljs-comment\">// 测试代码</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>)\n    {\n        <span class=\"hljs-title class_\">MyCallable</span> myCallable = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyCallable</span>();\n        <span class=\"hljs-comment\">// FutureTask能用来包装一个Callable或Runnable对象，因为它实现了Runnable接口，而且它能被传递到Executor进行执行</span>\n        <span class=\"hljs-comment\">// RunnableFuture接口同时继承Future接口和Runnable接口，在执行run()方法后，可以通过Future访问执行结果，实现类是FutureTask</span>\n        <span class=\"hljs-title class_\">FutureTask</span>&lt;<span class=\"hljs-title class_\">String</span>&gt; task =  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FutureTask</span>&lt;<span class=\"hljs-title class_\">String</span>&gt;(myCallable);\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(task).<span class=\"hljs-title function_\">start</span>();\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">//取消任务</span>\n            <span class=\"hljs-comment\">//task.cancel(true);</span>\n            <span class=\"hljs-comment\">//完成状态</span>\n            <span class=\"hljs-comment\">//task.isDone();</span>\n            <span class=\"hljs-comment\">//取消状态</span>\n            <span class=\"hljs-comment\">//System.out.println(&quot;子线程的取消了吗：&quot;+task.isCancelled());</span>\n            <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;子线程的返回值：&quot;</span>+task.<span class=\"hljs-title function_\">get</span>());\n        } <span class=\"hljs-keyword\">catch</span> (<span class=\"hljs-title class_\">InterruptedException</span> e) {\n            e.<span class=\"hljs-title function_\">printStackTrace</span>();\n        } <span class=\"hljs-keyword\">catch</span> (<span class=\"hljs-title class_\">ExecutionException</span> e) {\n            e.<span class=\"hljs-title function_\">printStackTrace</span>();\n        }\n    }\n}\n</code></pre>\n<h1 id=\"menu_5\">优缺点</h1><h2 id=\"menu_6\">继承Thread类</h2><p>优点：</p>\n<ul>\n<li>编写简单</li>\n<li>run()方法内访问当前线程，使用this即可</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>线程类不能再继承其他父类</li>\n</ul>\n<h2 id=\"menu_7\">实现Runnable或Callable接口</h2><p>优点：</p>\n<ul>\n<li>线程类只是实现了接口，还可以继承其他类</li>\n<li>多个线程可以共享同一个target对象，适合多个相同线程来处理同一份资源</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>（不算缺点的缺点）访问当前线程，则必须使用Thread.currentThread()方法</li>\n</ul>\n<h1 id=\"menu_8\">Runnable或Callable区别</h1><p>Callable方案（JDK1.5）可以理解为是Runnable的增强版，其关系如下：</p>\n<p><img src=\"/static/upload/post/1645745446619.png\" alt=\"/static/upload/post/1645745446619.png\"/></p>\n<p>区别如下：</p>\n<ol>\n<li>Callable的重写方法是call()，Runnable的重写方法是run()</li>\n<li>Callable的任务执行后可返回值，而Runnable的任务是不能返回值的</li>\n<li>Callable的call方法可以抛出异常，Runnable的run()方法不可以</li>\n<li>Callable任务可以拿到一个Future对象，表示异步计算的结果。</li>\n</ol>\n<p>提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。</p>\n<p>可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</p>\n<h1 id=\"menu_9\">Future接口提供的方法</h1><h2 id=\"menu_10\">boolean cancel(boolean mayInterruptIfRunning)</h2><p>取消Future里关联的Callable任务</p>\n<p>mayInterruptIfRunning入参：是否允许在线程运行时中断</p>\n<h2 id=\"menu_11\">V get()</h2><p>返回Callable任务里call()方法的返回值</p>\n<p>调用该方法将导致程序阻塞，必须等到子线程结束以后才会得到返回值</p>\n<h2 id=\"menu_12\">V get(long timeout, TimeUnit unit)</h2><p>返回Callable任务里call()方法的返回值</p>\n<p>该方法让程序最多阻塞timeout和unit指定的时间</p>\n<p>如果经过指定时间后，Callable任务依然没有返回值，将会抛出TimeoutException异常</p>\n<h2 id=\"menu_13\">boolean isCancelled()</h2><p>如果Callable任务正常完成前被取消，则返回true</p>\n<h2 id=\"menu_14\">boolean isDone()</h2><p>如果Callable任务已经完成， 则返回true</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">创建线程</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">继承Thread类</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">实现Runnable接口</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">实现Callable接口配合Future</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">优缺点</a> <ul><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">继承Thread类</a> <!----></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">实现Runnable或Callable接口</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl1\">Runnable或Callable区别</a> <!----></li><li><a href=\"javascript:runTo(\'menu_9\')\" class=\"pl1\">Future接口提供的方法</a> <ul><li><a href=\"javascript:runTo(\'menu_10\')\" class=\"pl2\">boolean cancel(boolean mayInterruptIfRunning)</a> <!----></li><li><a href=\"javascript:runTo(\'menu_11\')\" class=\"pl2\">V get()</a> <!----></li><li><a href=\"javascript:runTo(\'menu_12\')\" class=\"pl2\">V get(long timeout, TimeUnit unit)</a> <!----></li><li><a href=\"javascript:runTo(\'menu_13\')\" class=\"pl2\">boolean isCancelled()</a> <!----></li><li><a href=\"javascript:runTo(\'menu_14\')\" class=\"pl2\">boolean isDone()</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1019, '# 问题描述\n\nCentOS环境启动Docker后卡住，此后会发现ssh远程连接被断开，且此后无法连接服务器。\n\n具体情况如下图：\n\n![/static/upload/post/1645764637203.jpg](/static/upload/post/1645764637203.jpg)\n\n必须直接登录环境后，重启才能正常连接ssh。\n\n但是一旦启动Docker还是会出现相同情况。\n\n# 原因分析\n## Bridge桥接模式\n\nDocker默认使用Bridge桥接模式，其本质类似于NAT。\n\n![/static/upload/post/1645764649411.png](/static/upload/post/1645764649411.png)\n\n## 错误原因\n\n通过**ip addr**查看宿主机IP为192.168.1.33\n\nDocker创建了一个虚拟网络桥连，使用了192.168.1.35。\n\n由于Docker的桥接网段和宿主机在一个网段，导致XShell进行ssh访问192.168.1.33直接找到了Docker的网桥IP(192.168.1.35)。\n\n而网桥IP(192.168.1.35)仅有宿主机可以访问，就导致XShell无法进行ssh连接了。\n\n![/static/upload/post/1645764657813.png](/static/upload/post/1645764657813.png)\n\n# 解决手段\n\n修改Docker桥接绑定的ip，使其与宿主机IP不再同一个网段。\n\n## 方案1：/etc/docker/daemon.json\n\n环境上不一定有这个文件，没有直接vi编辑保存新增即可。\n\n```json\n{\n	\"bip\": \"172.16.0.1/12\"\n}\n```\n\n```bash\n# 加载配置\nsystemctl daemon-reload\n# 重启Docker\nsystemctl restart docker\n```\n\n## 方案2：/etc/default/docker\n\n```bash\nvi /etc/default/docker\n# 新增或修改\nDOCKER_OPTS=\"--bip=172.16.0.1/12\"\n# 编辑服务配置\nvi /etc/systemd/system/docker.service\n# 如果docker.service文件不存在，则看 /lib/systemd/system/docker.service\n# 增加生效配置\nEnvironmentFile=-/etc/default/docker\nExecStart=/usr/bin/dockerd  $DOCKER_OPTS\n# 重启Docker\nsystemctl restart docker\n```\n\n## 生效成功\n\n![/static/upload/post/1645764667624.png](/static/upload/post/1645764667624.png)\n\n# 补充阅读\n\n局域网保留网段：\n\n- A类：10.0.0.0/8      10.0.0.0～10.255.255.255\n- B类：172.16.0.0/12  172.16.0.0～172.31.255.255\n- C类：192.168.0.0/16  192.168.0.0～192.168.255.255\n\n', '<h1 id=\"menu_1\">问题描述</h1><p>CentOS环境启动Docker后卡住，此后会发现ssh远程连接被断开，且此后无法连接服务器。</p>\n<p>具体情况如下图：</p>\n<p><img src=\"/static/upload/post/1645764637203.jpg\" alt=\"/static/upload/post/1645764637203.jpg\"/></p>\n<p>必须直接登录环境后，重启才能正常连接ssh。</p>\n<p>但是一旦启动Docker还是会出现相同情况。</p>\n<h1 id=\"menu_2\">原因分析</h1><h2 id=\"menu_3\">Bridge桥接模式</h2><p>Docker默认使用Bridge桥接模式，其本质类似于NAT。</p>\n<p><img src=\"/static/upload/post/1645764649411.png\" alt=\"/static/upload/post/1645764649411.png\"/></p>\n<h2 id=\"menu_4\">错误原因</h2><p>通过<strong>ip addr</strong>查看宿主机IP为192.168.1.33</p>\n<p>Docker创建了一个虚拟网络桥连，使用了192.168.1.35。</p>\n<p>由于Docker的桥接网段和宿主机在一个网段，导致XShell进行ssh访问192.168.1.33直接找到了Docker的网桥IP(192.168.1.35)。</p>\n<p>而网桥IP(192.168.1.35)仅有宿主机可以访问，就导致XShell无法进行ssh连接了。</p>\n<p><img src=\"/static/upload/post/1645764657813.png\" alt=\"/static/upload/post/1645764657813.png\"/></p>\n<h1 id=\"menu_5\">解决手段</h1><p>修改Docker桥接绑定的ip，使其与宿主机IP不再同一个网段。</p>\n<h2 id=\"menu_6\">方案1：/etc/docker/daemon.json</h2><p>环境上不一定有这个文件，没有直接vi编辑保存新增即可。</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;bip&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;172.16.0.1/12&quot;</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># 加载配置</span>\nsystemctl daemon-reload\n<span class=\"hljs-comment\"># 重启Docker</span>\nsystemctl restart docker\n</code></pre>\n<h2 id=\"menu_7\">方案2：/etc/default/docker</h2><pre><code class=\"hljs language-bash\">vi /etc/default/docker\n<span class=\"hljs-comment\"># 新增或修改</span>\nDOCKER_OPTS=<span class=\"hljs-string\">&quot;--bip=172.16.0.1/12&quot;</span>\n<span class=\"hljs-comment\"># 编辑服务配置</span>\nvi /etc/systemd/system/docker.service\n<span class=\"hljs-comment\"># 如果docker.service文件不存在，则看 /lib/systemd/system/docker.service</span>\n<span class=\"hljs-comment\"># 增加生效配置</span>\nEnvironmentFile=-/etc/default/docker\nExecStart=/usr/bin/dockerd  $DOCKER_OPTS\n<span class=\"hljs-comment\"># 重启Docker</span>\nsystemctl restart docker\n</code></pre>\n<h2 id=\"menu_8\">生效成功</h2><p><img src=\"/static/upload/post/1645764667624.png\" alt=\"/static/upload/post/1645764667624.png\"/></p>\n<h1 id=\"menu_9\">补充阅读</h1><p>局域网保留网段：</p>\n<ul>\n<li>A类：10.0.0.0/8      10.0.0.0～10.255.255.255</li>\n<li>B类：172.16.0.0/12  172.16.0.0～172.31.255.255</li>\n<li>C类：192.168.0.0/16  192.168.0.0～192.168.255.255</li>\n</ul>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">问题描述</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">原因分析</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">Bridge桥接模式</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">错误原因</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">解决手段</a> <ul><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">方案1：/etc/docker/daemon.json</a> <!----></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">方案2：/etc/default/docker</a> <!----></li><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl2\">生效成功</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_9\')\" class=\"pl1\">补充阅读</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1020, '# 前言\n\n本文直接从Git命令开始。\n\n默认您已经创建好相关远程工程。\n\n默认您已经配置好鉴权账户和密码（建议通过密钥授权）。\n\nGit命令并不受代码托管平台影响，无论是GitHub、Gitee、GitLab均可使用。\n\n本文主要针对开发，也就是说需要关联工程后续且需要提交代码的场景。\n\n# 全新工程\n\n所谓全新工程是指本地创建了一个目录，里面没有任何内容。\n\n```shell\n# 在本地新建一个工程文件夹\n# 初始化当前项目\ngit init\n\n# 关联远程仓库\n# 其中origin的名字可以而改为其他（一般默认用这个）\n# git@gitee.com:mebugs/meals.git是我的地址\n# 这一步也可以通过配置文件处理\ngit remote add origin git@gitee.com:mebugs/meals.git\n\n# 拉取代码\n# 如果此时直接git pull会报错\n# There is no tracking information for the current branch.\n# Please specify which branch you want to merge with.\n# See git-pull(1) for details.\n#   git pull <remote> <branch>\n# If you wish to set tracking information for this branch you can do so with:\n# git branch --set-upstream-to=origin/<branch> master\n# 这里提示进行本地与远程分支需要先关联\n# 因为此时还没有本地分支，正确的流程应该是\n# 创建本地分支、与远程分支关联、然后拉取远程分支\n# 对于全新工程，可以直接强制拉取并关联\n# 通过下方命令完成三件事：\n# 创建一个本地master分支、创建远程master分支、拉取代码\ngit pull origin master\n\n# 设置关联\n# 设置关联属于选用操作（但是非常建议执行此操作）\n# 如果不设置关联的话，每次pull或push代码需要带上分支名\n# 例如：git pull origin master\n# 设置关联后，拉取或推送直接输入：git pull/push\ngit branch --set-upstream-to=origin/master master\n```\n\n![/static/upload/post/1645765242340.jpg](/static/upload/post/1645765242340.jpg)\n\n# 已有工程\n\n --allow-unrelated-histories\n\n已有工程表示本地工程已经存在了部分文件。\n\n实际上本地已有工程和全新工程基本是一致的。\n\n```shell\n# 初始化\ngit init\n\n# 关联远程仓库\ngit remote add origin git@gitee.com:mebugs/meals.git\n\n# 拉取代码并合并\n# 远程分支和本地分支都有内容，一般在拉取代码时指定 --allow-unrelated-histories\n# 表示允许不相关历史提交，并强制合并（但是可能存在合并失败的情况，需要手工处理）\n# 一般处理合并建议使用 –rebase生成更好的可读提交记录\ngit pull origin master --allow-unrelated-histories\n\n# 设置关联\ngit branch --set-upstream-to=origin/master master\n\n# 如果确定本地作为最新的代码内容\n# 可以强制提交代码（一般不建议）\ngit push --force origin master\n```\n\n# 关联分支\n\n有时候我们在某个开发阶段会将工程切换到特定的分支。\n\n如dev分支。\n\n## 直接切换\n\n```shell\n# 已经在master分支想切换到dev\n# 在本地创建分支dev\n# 切换并关联此远程分支\n# 下方命令git checkout -b dev（本地分支名） origin/dev（远程分支）\ngit checkout -b dev origin/dev\n```\n\n## 全新创建关联\n\n```shell\n# 全新工程直接关联其他分支\n# 初始化\ngit init\n\n# 关联远程仓库\ngit remote add origin git@gitee.com:mebugs/meals.git\n\n# 拉取远程仓库指定分支的代码\ngit fetch origin dev\n\n# 在本地创建分支dev\n# 切换并关联此远程分支\ngit checkout -b dev origin/dev\n```', '<h1 id=\"menu_1\">前言</h1><p>本文直接从Git命令开始。</p>\n<p>默认您已经创建好相关远程工程。</p>\n<p>默认您已经配置好鉴权账户和密码（建议通过密钥授权）。</p>\n<p>Git命令并不受代码托管平台影响，无论是GitHub、Gitee、GitLab均可使用。</p>\n<p>本文主要针对开发，也就是说需要关联工程后续且需要提交代码的场景。</p>\n<h1 id=\"menu_2\">全新工程</h1><p>所谓全新工程是指本地创建了一个目录，里面没有任何内容。</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-comment\"># 在本地新建一个工程文件夹</span>\n<span class=\"hljs-comment\"># 初始化当前项目</span>\ngit init\n\n<span class=\"hljs-comment\"># 关联远程仓库</span>\n<span class=\"hljs-comment\"># 其中origin的名字可以而改为其他（一般默认用这个）</span>\n<span class=\"hljs-comment\"># git<span class=\"hljs-doctag\">@gitee</span>.com:mebugs/meals.git是我的地址</span>\n<span class=\"hljs-comment\"># 这一步也可以通过配置文件处理</span>\ngit remote add origin git<span class=\"hljs-variable\">@gitee</span>.<span class=\"hljs-symbol\">com:</span>mebugs/meals.git\n\n<span class=\"hljs-comment\"># 拉取代码</span>\n<span class=\"hljs-comment\"># 如果此时直接git pull会报错</span>\n<span class=\"hljs-comment\"># There is no tracking information for the current branch.</span>\n<span class=\"hljs-comment\"># Please specify which branch you want to merge with.</span>\n<span class=\"hljs-comment\"># See git-pull(1) for details.</span>\n<span class=\"hljs-comment\">#   git pull &lt;remote&gt; &lt;branch&gt;</span>\n<span class=\"hljs-comment\"># If you wish to set tracking information for this branch you can do so with:</span>\n<span class=\"hljs-comment\"># git branch --set-upstream-to=origin/&lt;branch&gt; master</span>\n<span class=\"hljs-comment\"># 这里提示进行本地与远程分支需要先关联</span>\n<span class=\"hljs-comment\"># 因为此时还没有本地分支，正确的流程应该是</span>\n<span class=\"hljs-comment\"># 创建本地分支、与远程分支关联、然后拉取远程分支</span>\n<span class=\"hljs-comment\"># 对于全新工程，可以直接强制拉取并关联</span>\n<span class=\"hljs-comment\"># 通过下方命令完成三件事：</span>\n<span class=\"hljs-comment\"># 创建一个本地master分支、创建远程master分支、拉取代码</span>\ngit pull origin master\n\n<span class=\"hljs-comment\"># 设置关联</span>\n<span class=\"hljs-comment\"># 设置关联属于选用操作（但是非常建议执行此操作）</span>\n<span class=\"hljs-comment\"># 如果不设置关联的话，每次pull或push代码需要带上分支名</span>\n<span class=\"hljs-comment\"># 例如：git pull origin master</span>\n<span class=\"hljs-comment\"># 设置关联后，拉取或推送直接输入：git pull/push</span>\ngit branch --set-upstream-to=origin/master master\n</code></pre>\n<p><img src=\"/static/upload/post/1645765242340.jpg\" alt=\"/static/upload/post/1645765242340.jpg\"/></p>\n<h1 id=\"menu_3\">已有工程</h1><p> --allow-unrelated-histories</p>\n<p>已有工程表示本地工程已经存在了部分文件。</p>\n<p>实际上本地已有工程和全新工程基本是一致的。</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-comment\"># 初始化</span>\ngit init\n\n<span class=\"hljs-comment\"># 关联远程仓库</span>\ngit remote add origin git<span class=\"hljs-variable\">@gitee</span>.<span class=\"hljs-symbol\">com:</span>mebugs/meals.git\n\n<span class=\"hljs-comment\"># 拉取代码并合并</span>\n<span class=\"hljs-comment\"># 远程分支和本地分支都有内容，一般在拉取代码时指定 --allow-unrelated-histories</span>\n<span class=\"hljs-comment\"># 表示允许不相关历史提交，并强制合并（但是可能存在合并失败的情况，需要手工处理）</span>\n<span class=\"hljs-comment\"># 一般处理合并建议使用 –rebase生成更好的可读提交记录</span>\ngit pull origin master --allow-unrelated-histories\n\n<span class=\"hljs-comment\"># 设置关联</span>\ngit branch --set-upstream-to=origin/master master\n\n<span class=\"hljs-comment\"># 如果确定本地作为最新的代码内容</span>\n<span class=\"hljs-comment\"># 可以强制提交代码（一般不建议）</span>\ngit push --force origin master\n</code></pre>\n<h1 id=\"menu_4\">关联分支</h1><p>有时候我们在某个开发阶段会将工程切换到特定的分支。</p>\n<p>如dev分支。</p>\n<h2 id=\"menu_5\">直接切换</h2><pre><code class=\"hljs language-shell\"><span class=\"hljs-comment\"># 已经在master分支想切换到dev</span>\n<span class=\"hljs-comment\"># 在本地创建分支dev</span>\n<span class=\"hljs-comment\"># 切换并关联此远程分支</span>\n<span class=\"hljs-comment\"># 下方命令git checkout -b dev（本地分支名） origin/dev（远程分支）</span>\ngit checkout -b dev origin/dev\n</code></pre>\n<h2 id=\"menu_6\">全新创建关联</h2><pre><code class=\"hljs language-shell\"><span class=\"hljs-comment\"># 全新工程直接关联其他分支</span>\n<span class=\"hljs-comment\"># 初始化</span>\ngit init\n\n<span class=\"hljs-comment\"># 关联远程仓库</span>\ngit remote add origin git<span class=\"hljs-variable\">@gitee</span>.<span class=\"hljs-symbol\">com:</span>mebugs/meals.git\n\n<span class=\"hljs-comment\"># 拉取远程仓库指定分支的代码</span>\ngit fetch origin dev\n\n<span class=\"hljs-comment\"># 在本地创建分支dev</span>\n<span class=\"hljs-comment\"># 切换并关联此远程分支</span>\ngit checkout -b dev origin/dev\n</code></pre>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">前言</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">全新工程</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">已有工程</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">关联分支</a> <ul><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">直接切换</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">全新创建关联</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1021, '# 缓存的意义\n\n缓存的意义主要用于解决数据库访问压力，提升数据返回速度。\n\n见下图；\n\n![/static/upload/post/1645769485003.jpg](/static/upload/post/1645769485003.jpg)\n\n从上图我们可以清晰的明白缓存的意义。\n\n那么缓存可以解决什么问题呢？\n\n1. 数据库访问瓶颈（减少了数据库访问的次数）\n2. 应用访问瓶颈（减少了单次访问的时间）\n\n# 本地缓存\n\n所谓本地缓存即应用自身直接开辟使用的内存空间。\n\n一般来说，为了解决高并发访问时，第一步基本会采用本地缓存方案。\n\n本地缓存的优点：\n\n1. 访问速度快：\n	本地缓存不需要跨网络传输，具有超高的性能\n\n本地缓存的缺点：\n\n1. 内存竞争；\n	本地缓存占用了应用进程的内存空间，会与应用的其他内存进行竞争\n2. 重启或异常丢失：\n	本地缓存的数据是存储在应用进程的内存空间的，当应用进程重启或异常，本地缓存的数据会丢失\n	当然可以通过持久化的方式解决，但才用了持久化实际上就弱化了性能\n3. 集群组网缓存同步：\n	本地缓存只支持当前节点的应用进程访问，如果在集群组网下的多节点之间可能出现缓存不一致\n	此外，多节点间的缓存同步逻辑复杂且带来很多不可控的因素（如同步失败、节点重启等等）\n\n就如下图所示：\n\n![/static/upload/post/1645769511410.jpg](/static/upload/post/1645769511410.jpg)\n\n当应用节点越来越多的时候，我们在修改数据后要不断去考虑如何解决缓存同步的问题。\n\n而在解决缓存同步的过程中会暴露越来越多的问题：\n\n1. 节点越来越多，缓存同步通知开销越来越大（额外的性能开销）\n2. 为了保证缓存同步，需要维护一个节点列表，并不断同步各个节点的存活状态（额外的业务逻辑）\n3. 某些节点异常时可能导致通知进程的异常（可能导致通知丢失）\n4. 某些节点尚未收到同步通知之前收到新的访问请求（错误缓存被读取）\n\n# 分布式缓存\n\n分布式缓存也是缓存，唯一的区别就在于，在整个架构体系中是完全独立的一个进程。\n\n分布式缓存的优点：\n\n1. 无内存竞争/不受重启影响：\n	独立部署的进程，独立的内存空间，不会受到应用进程重启的影响（甚至可以将分布式缓存单独部署在其他的网络节点）\n	应用进程重启时，分布式缓存的数据依然存在\n2. 存储容量的不受限：\n	分布式缓存一般可以单独部署在一个新的网络节点，在内存方法几乎不受其他应用影响\n	同时分布式缓存也可以通过集群组网的方式进行容量拓展\n3. 数据一致性：\n	分布式缓存一般给整个集群的其他网络节点进行统一缓存数据存取操作\n	不存在本地缓存中的数据更新问题，保证了不同节点的应用进程的数据一致性问题\n4. 读写分离：\n	分布式缓存本身技术架构中多数支持读写分离，能够提供较高的访问性能\n\n分布式缓存的缺点：\n\n1. 额外开销：\n	无论分布式缓存与应用是否安装在同一个网络节点均会增加少量的应用开销\n	此外，如果进行多节点部署或跨网络部署会增加额外的网络开销\n\n\n就如下图所示：\n\n\n![/static/upload/post/1645769531978.jpg](/static/upload/post/1645769531978.jpg)\n\n\n# 常见两种分布式缓存\n\n## MemCached\n\nMemCached相对于本地缓存的主要差别是以独立进程方式存在，数据集中存储，数据不随应用程序的重启而丢失。\n\n而key-value键值对的 value 也是一个简单的对象类型，即value可以是任意格式的数据，如简单的数字、字符串、对象等，也可以是文件、图像、视频等复杂格式的数据，但是不支持数据结构的特性。\n\n所以MemCached进程相当于是在内存维护了一个非常大的哈希表来存储数据，对应的数据操作复杂度都是 O(1)，即常量级别。\n\n这也是 MemCached 高性能的一个实现方式，键值对存取速度都非常快。\n\n## Redis\nRedis更一步丰富了key-value键值对的 value 的数据结构类型，即可以在Redis中完成value的相关数据操作，如Set集合、有序集合ZSet等，这样就不需要在应用程序额外进行这些操作，实现了开箱即用。\n\nRedis是单线程的，不存在并发数据读写的线程安全问题，以及更重要的是保证的数据读写操作的顺序性。\n\nRedis支持主从同步（读写分离）、集群分片拓展、数据持久化等特性，这也是 MemCached 不支持的。\n\n所以在某些高并发场景下（如日志）Redis完全可以作为数据库来使用，提高高并发场景中的访问性能。', '<h1 id=\"menu_1\">缓存的意义</h1><p>缓存的意义主要用于解决数据库访问压力，提升数据返回速度。</p>\n<p>见下图；</p>\n<p><img src=\"/static/upload/post/1645769485003.jpg\" alt=\"/static/upload/post/1645769485003.jpg\"/></p>\n<p>从上图我们可以清晰的明白缓存的意义。</p>\n<p>那么缓存可以解决什么问题呢？</p>\n<ol>\n<li>数据库访问瓶颈（减少了数据库访问的次数）</li>\n<li>应用访问瓶颈（减少了单次访问的时间）</li>\n</ol>\n<h1 id=\"menu_2\">本地缓存</h1><p>所谓本地缓存即应用自身直接开辟使用的内存空间。</p>\n<p>一般来说，为了解决高并发访问时，第一步基本会采用本地缓存方案。</p>\n<p>本地缓存的优点：</p>\n<ol>\n<li>访问速度快：<br/> 本地缓存不需要跨网络传输，具有超高的性能</li>\n</ol>\n<p>本地缓存的缺点：</p>\n<ol>\n<li>内存竞争；<br/> 本地缓存占用了应用进程的内存空间，会与应用的其他内存进行竞争</li>\n<li>重启或异常丢失：<br/> 本地缓存的数据是存储在应用进程的内存空间的，当应用进程重启或异常，本地缓存的数据会丢失<br/> 当然可以通过持久化的方式解决，但才用了持久化实际上就弱化了性能</li>\n<li>集群组网缓存同步：<br/> 本地缓存只支持当前节点的应用进程访问，如果在集群组网下的多节点之间可能出现缓存不一致<br/> 此外，多节点间的缓存同步逻辑复杂且带来很多不可控的因素（如同步失败、节点重启等等）</li>\n</ol>\n<p>就如下图所示：</p>\n<p><img src=\"/static/upload/post/1645769511410.jpg\" alt=\"/static/upload/post/1645769511410.jpg\"/></p>\n<p>当应用节点越来越多的时候，我们在修改数据后要不断去考虑如何解决缓存同步的问题。</p>\n<p>而在解决缓存同步的过程中会暴露越来越多的问题：</p>\n<ol>\n<li>节点越来越多，缓存同步通知开销越来越大（额外的性能开销）</li>\n<li>为了保证缓存同步，需要维护一个节点列表，并不断同步各个节点的存活状态（额外的业务逻辑）</li>\n<li>某些节点异常时可能导致通知进程的异常（可能导致通知丢失）</li>\n<li>某些节点尚未收到同步通知之前收到新的访问请求（错误缓存被读取）</li>\n</ol>\n<h1 id=\"menu_3\">分布式缓存</h1><p>分布式缓存也是缓存，唯一的区别就在于，在整个架构体系中是完全独立的一个进程。</p>\n<p>分布式缓存的优点：</p>\n<ol>\n<li>无内存竞争/不受重启影响：<br/> 独立部署的进程，独立的内存空间，不会受到应用进程重启的影响（甚至可以将分布式缓存单独部署在其他的网络节点）<br/> 应用进程重启时，分布式缓存的数据依然存在</li>\n<li>存储容量的不受限：<br/> 分布式缓存一般可以单独部署在一个新的网络节点，在内存方法几乎不受其他应用影响<br/> 同时分布式缓存也可以通过集群组网的方式进行容量拓展</li>\n<li>数据一致性：<br/> 分布式缓存一般给整个集群的其他网络节点进行统一缓存数据存取操作<br/> 不存在本地缓存中的数据更新问题，保证了不同节点的应用进程的数据一致性问题</li>\n<li>读写分离：<br/> 分布式缓存本身技术架构中多数支持读写分离，能够提供较高的访问性能</li>\n</ol>\n<p>分布式缓存的缺点：</p>\n<ol>\n<li>额外开销：<br/> 无论分布式缓存与应用是否安装在同一个网络节点均会增加少量的应用开销<br/> 此外，如果进行多节点部署或跨网络部署会增加额外的网络开销</li>\n</ol>\n<p>就如下图所示：</p>\n<p><img src=\"/static/upload/post/1645769531978.jpg\" alt=\"/static/upload/post/1645769531978.jpg\"/></p>\n<h1 id=\"menu_4\">常见两种分布式缓存</h1><h2 id=\"menu_5\">MemCached</h2><p>MemCached相对于本地缓存的主要差别是以独立进程方式存在，数据集中存储，数据不随应用程序的重启而丢失。</p>\n<p>而key-value键值对的 value 也是一个简单的对象类型，即value可以是任意格式的数据，如简单的数字、字符串、对象等，也可以是文件、图像、视频等复杂格式的数据，但是不支持数据结构的特性。</p>\n<p>所以MemCached进程相当于是在内存维护了一个非常大的哈希表来存储数据，对应的数据操作复杂度都是 O(1)，即常量级别。</p>\n<p>这也是 MemCached 高性能的一个实现方式，键值对存取速度都非常快。</p>\n<h2 id=\"menu_6\">Redis</h2><p>Redis更一步丰富了key-value键值对的 value 的数据结构类型，即可以在Redis中完成value的相关数据操作，如Set集合、有序集合ZSet等，这样就不需要在应用程序额外进行这些操作，实现了开箱即用。</p>\n<p>Redis是单线程的，不存在并发数据读写的线程安全问题，以及更重要的是保证的数据读写操作的顺序性。</p>\n<p>Redis支持主从同步（读写分离）、集群分片拓展、数据持久化等特性，这也是 MemCached 不支持的。</p>\n<p>所以在某些高并发场景下（如日志）Redis完全可以作为数据库来使用，提高高并发场景中的访问性能。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">缓存的意义</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">本地缓存</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">分布式缓存</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">常见两种分布式缓存</a> <ul><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">MemCached</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">Redis</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1022, '# scope属性样例\n\nscope属性一般配置在依赖节点内。\n\n该属性的主要作用是用于控制当前依赖的依赖范围。\n\n简单来说就是控制依赖在应用的编译到发布过程中生效的范围。\n\n比如下方样式就是大名鼎鼎的lombok插件，配置为provided（已提供范围）。\n\n```xml\n<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok  do not compile-->\n<dependency>\n	<groupId>org.projectlombok</groupId>\n	<artifactId>lombok</artifactId>\n	<version>1.18.14</version>\n	<!-- compile：默认范围，用于编译 -->\n	<!-- provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath -->\n	<!-- runtime：在执行时需要使用 --> \n	<!-- test：用于test任务时使用 -->\n	<!-- system：需要外在提供相应的元素。通过systemPath来取得 -->\n	<!-- systemPath：仅用于范围为system。提供相应的路径 -->\n	<scope>provided</scope>\n</dependency>\n```\n\n# 属性定义和解释\n\n## compile （编译范围）\n\ncompile是默认的范围。\n\n一般来说如果dependency节点内没有配置scope，就表示是compile。\n\n编译范围依赖在所有的classpath中可用，打包时该依赖会被打包。\n\n该依赖会被传递。\n\n## provided （已提供范围）\n\nprovided依赖表示该依赖在实际JDK或容器中已存在。\n\n已提供范围的依赖在编译classpath可用。\n\n打包时该依赖不会被打包。\n\n常见的例子：\n\nWeb应用在编译时需要依赖的ServletAPI来编译servlet，但实际打包时并不需要这个ServletAPI。\n\n因为ServletAPI的jar包往往由应用服务器或者servlet容器（如Tomcat）提供。\n\n因此可以将ServletAPI依赖配置为provided。\n\n同理本文上方例子里的lombok插件也只是编译的时候需要。\n\n该依赖不会被传递。\n\n## runtime （运行时范围）\n\nruntime依赖在运行和测试系统的时候需要，但在编译的时候不需要。\n\nruntime与provided刚好相反，打包时该依赖会被打包。\n\n常见的例子：\n\n编译的时候只需要JDBC的API。\n\n而在运行的时候才需要JDBC驱动。\n\n该依赖会被传递。\n\n## test （测试范围）\n\ntest范围依赖，在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。\n\n该依赖不会被传递。\n\n## system （系统范围）\n\nsystem范围依赖与provided类似，但是你必须显式的提供一个对于本地系统中JAR文件的路径。\n\n这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。\n\n这样的构件应该是一直可用的，Maven也不会在仓库中去寻找它。\n\n如果你将一个依赖范围设置成系统范围，你必须同时提供一个systemPath元素。\n\n注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的Maven仓库中引用依赖）。\n\nsystem一般用在某些特殊的jar包依赖（比如私有jar或者某些过期版本的jar)\n\n该依赖不会被传递。\n\n```xml\n<dependency>\n	<groupId>quartz</groupId>\n	<artifactId>quartz</artifactId>\n	<version>1.8.6</version>\n	<!-- system：需要外在提供相应的元素。通过systemPath来取得 -->\n	<scope>system</scope>\n	<!-- systemPath：仅用于范围为system。提供相应的路径 -->\n	<systemPath>${project.basedir}/src/main/webapp/WEB-INF/lib/quartz-1.8.6.jar</systemPath>\n</dependency>\n```\n\n\n# 拓展阅读：optional\n\n除了scope管理依赖范围之外，还有一个optional也用于控制依赖范围。\n\noptional（可选的依赖）\n\n理解为此功能/此依赖可选，如果不需要某项功能，可以不引用这个包。\n\noptional主要作用于其他依赖当前项目的工程，阻断依赖的传递。\n\n简单来说：\n\nA配置了某个依赖（例如是下方的devtools），设置optional为true。\n\nB为A的子项目或依赖A，这时候如需要devtools，B可以配置devtools的依赖。\n\n如果B不需要devtools，pom文件无需任何配置（B项目中不会自定引入devtools）。\n\n反之，如果A项目optiona设为false或没有设置（optiona默认为false)。\n\nB项目无论是否配置devtools该依赖都会被引入。\n\n```xml\n<!--devtools 热部署-->\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-devtools</artifactId>\n  <optional>true</optional>\n</dependency>\n```\n', '<h1 id=\"menu_1\">scope属性样例</h1><p>scope属性一般配置在依赖节点内。</p>\n<p>该属性的主要作用是用于控制当前依赖的依赖范围。</p>\n<p>简单来说就是控制依赖在应用的编译到发布过程中生效的范围。</p>\n<p>比如下方样式就是大名鼎鼎的lombok插件，配置为provided（已提供范围）。</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-comment\">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok  do not compile--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.projectlombok<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>lombok<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.18.14<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- compile：默认范围，用于编译 --&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath --&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- runtime：在执行时需要使用 --&gt;</span> \n    <span class=\"hljs-comment\">&lt;!-- test：用于test任务时使用 --&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- system：需要外在提供相应的元素。通过systemPath来取得 --&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- systemPath：仅用于范围为system。提供相应的路径 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>provided<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<h1 id=\"menu_2\">属性定义和解释</h1><h2 id=\"menu_3\">compile （编译范围）</h2><p>compile是默认的范围。</p>\n<p>一般来说如果dependency节点内没有配置scope，就表示是compile。</p>\n<p>编译范围依赖在所有的classpath中可用，打包时该依赖会被打包。</p>\n<p>该依赖会被传递。</p>\n<h2 id=\"menu_4\">provided （已提供范围）</h2><p>provided依赖表示该依赖在实际JDK或容器中已存在。</p>\n<p>已提供范围的依赖在编译classpath可用。</p>\n<p>打包时该依赖不会被打包。</p>\n<p>常见的例子：</p>\n<p>Web应用在编译时需要依赖的ServletAPI来编译servlet，但实际打包时并不需要这个ServletAPI。</p>\n<p>因为ServletAPI的jar包往往由应用服务器或者servlet容器（如Tomcat）提供。</p>\n<p>因此可以将ServletAPI依赖配置为provided。</p>\n<p>同理本文上方例子里的lombok插件也只是编译的时候需要。</p>\n<p>该依赖不会被传递。</p>\n<h2 id=\"menu_5\">runtime （运行时范围）</h2><p>runtime依赖在运行和测试系统的时候需要，但在编译的时候不需要。</p>\n<p>runtime与provided刚好相反，打包时该依赖会被打包。</p>\n<p>常见的例子：</p>\n<p>编译的时候只需要JDBC的API。</p>\n<p>而在运行的时候才需要JDBC驱动。</p>\n<p>该依赖会被传递。</p>\n<h2 id=\"menu_6\">test （测试范围）</h2><p>test范围依赖，在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。</p>\n<p>该依赖不会被传递。</p>\n<h2 id=\"menu_7\">system （系统范围）</h2><p>system范围依赖与provided类似，但是你必须显式的提供一个对于本地系统中JAR文件的路径。</p>\n<p>这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。</p>\n<p>这样的构件应该是一直可用的，Maven也不会在仓库中去寻找它。</p>\n<p>如果你将一个依赖范围设置成系统范围，你必须同时提供一个systemPath元素。</p>\n<p>注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的Maven仓库中引用依赖）。</p>\n<p>system一般用在某些特殊的jar包依赖（比如私有jar或者某些过期版本的jar)</p>\n<p>该依赖不会被传递。</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>quartz<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>quartz<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.8.6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- system：需要外在提供相应的元素。通过systemPath来取得 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>system<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- systemPath：仅用于范围为system。提供相应的路径 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">systemPath</span>&gt;</span>${project.basedir}/src/main/webapp/WEB-INF/lib/quartz-1.8.6.jar<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">systemPath</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<h1 id=\"menu_8\">拓展阅读：optional</h1><p>除了scope管理依赖范围之外，还有一个optional也用于控制依赖范围。</p>\n<p>optional（可选的依赖）</p>\n<p>理解为此功能/此依赖可选，如果不需要某项功能，可以不引用这个包。</p>\n<p>optional主要作用于其他依赖当前项目的工程，阻断依赖的传递。</p>\n<p>简单来说：</p>\n<p>A配置了某个依赖（例如是下方的devtools），设置optional为true。</p>\n<p>B为A的子项目或依赖A，这时候如需要devtools，B可以配置devtools的依赖。</p>\n<p>如果B不需要devtools，pom文件无需任何配置（B项目中不会自定引入devtools）。</p>\n<p>反之，如果A项目optiona设为false或没有设置（optiona默认为false)。</p>\n<p>B项目无论是否配置devtools该依赖都会被引入。</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-comment\">&lt;!--devtools 热部署--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-devtools<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">optional</span>&gt;</span>true<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">optional</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">scope属性样例</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">属性定义和解释</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">compile （编译范围）</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">provided （已提供范围）</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">runtime （运行时范围）</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">test （测试范围）</a> <!----></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">system （系统范围）</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl1\">拓展阅读：optional</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1023, '# 语法语义\n\n```sql\nCASE WHEN {condition} THEN {result}\n \n[WHEN...THEN...]\n \nELSE {result}\n\nEND\n```\n\nWHEN{condition}是一个返回布尔类型的表达式\n\n1. 如果表达式返回true，则整个函数返回相应THEN后的{result}值\n2. 如果表达式返回false，则继续匹配后续的WHEN条件\n3. 如果所有表达式均返回false，则返回ELSE后的{result}值\n4. 如果没有配置ELSE {result}，则返回null\n\n需要特别注意的是，当WHEN被匹配后会直接执行当WHEN对应的THEN，后续的WHEN就会被舍弃。\n\n# 两种写法\n\nCASE WHEN的SQL有两种写法，下方直接以实例进行说明：\n\n```sql\n--写法1\n--WHEN后面的表达式支持AND进行多条件匹配 \nCASE\n	WHEN age > 60 THEN \'老人\'\n    WHEN age > 35 AND age <= 60 THEN \'中年人\'\n    WHEN age > 20 AND age <= 35 THEN \'青年人\'\n	WHEN age > 15 AND age <= 20 THEN \'少年人\' \n	ELSE \'儿童\' END\n```\n\n```sql\n--写法2\n--这是简单简单CASE格式\n--仅支持字段与数据对比（即常说的等于）\n--字段值与数据的数据类型必须相同或者可被隐性转换\n--比如：数字类型的age可以和数字比（如本案例）\n--数字类型的age可以和数字字符串字符串比（WHEN \'60\' THEN \'60生日老人\'）\n--而(WHEN \'abc\' THEN \'怪人\')则会报错\nCASE age \n	WHEN 60 THEN \'60生日老人\'\n    WHEN 40 THEN \'40中年人\'\n    WHEN 20 THEN \'20青年人\'\n	WHEN 15 THEN \'15少年人\' \n	ELSE \'儿童\' END\n```\n\n此外需要注意的是，THEN {result} 和 ELSE {result}中的{result}类型必须一致。\n\n比如下方的语法则会出错！\n\n```sql\n--这里THEN后面既有输出字符串也有输出数字的，无法统一类型\nCASE age \n	WHEN 60 THEN \'60生日老人\'\n    WHEN 40 THEN 10086\n    WHEN 20 THEN \'20青年人\'\n	WHEN 15 THEN 12345 \n	ELSE 10010 END\n```\n\n# 应用\n\nCASE WHEN一般放在SELECT子句内，下方通过案例进行了解其应用。\n\n```sql\n--如果sex为1查询出男、为2查询出女、其他查询出外星人\n--并将结果命名为sex_name\nSELECT u.name,\n	CASE u.sex \n		WHEN 1 THEN \'男\'\n		WHEN 2 THEN \'女\'\n		ELSE \'外星人\' END AS sex_name\nFROM sys_user u\n```\n\n## 其他用法\n\n```sql\n--CASE WHEN判空 名字为空显示指定字符串\nCASE WHEN name IS NULL THEN \'未知姓名\' ELSE name END\n--关于判空MySQL中有IFNULL(字段, 为空返回值)函数\n```\n\n## 衍生思路\n\nCASE WHEN可以通过某个特定的type字段分别从不同的表中查询数据（虽然这个方式非常不效率）\n\n```sql\n--如果文章type为1从post_book表取图片\n--如果文章type为2从post_tool表取图片\n--否则返回默认图片\nSELECT p.id, p.img,\n	CASE p.type\n		WHEN 1 THEN \n			(SELECT b.img FROM post_book b WHERE b.pid = p.id)\n		WHEN 2 THEN \n			(SELECT t.img FROM post_tool t WHERE t.pid = p.id)\n		ELSE \'/normalImg.png\'\n		END AS logo\nFROM post p\n```', '<h1 id=\"menu_1\">语法语义</h1><pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CASE</span> WHEN {condition} THEN {result}\n \n[WHEN...THEN...]\n \n<span class=\"hljs-keyword\">ELSE</span> {result}\n\nEND\n</code></pre>\n<p>WHEN{condition}是一个返回布尔类型的表达式</p>\n<ol>\n<li>如果表达式返回true，则整个函数返回相应THEN后的{result}值</li>\n<li>如果表达式返回false，则继续匹配后续的WHEN条件</li>\n<li>如果所有表达式均返回false，则返回ELSE后的{result}值</li>\n<li>如果没有配置ELSE {result}，则返回null</li>\n</ol>\n<p>需要特别注意的是，当WHEN被匹配后会直接执行当WHEN对应的THEN，后续的WHEN就会被舍弃。</p>\n<h1 id=\"menu_2\">两种写法</h1><p>CASE WHEN的SQL有两种写法，下方直接以实例进行说明：</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">--写法1</span>\n<span class=\"hljs-comment\">--WHEN后面的表达式支持AND进行多条件匹配 </span>\n<span class=\"hljs-keyword\">CASE</span>\n    <span class=\"hljs-keyword\">WHEN</span> age <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">60</span> <span class=\"hljs-keyword\">THEN</span> <span class=\"hljs-string\">&#x27;老人&#x27;</span>\n    <span class=\"hljs-keyword\">WHEN</span> age <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">35</span> <span class=\"hljs-keyword\">AND</span> age <span class=\"hljs-operator\">&lt;=</span> <span class=\"hljs-number\">60</span> <span class=\"hljs-keyword\">THEN</span> <span class=\"hljs-string\">&#x27;中年人&#x27;</span>\n    <span class=\"hljs-keyword\">WHEN</span> age <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-keyword\">AND</span> age <span class=\"hljs-operator\">&lt;=</span> <span class=\"hljs-number\">35</span> <span class=\"hljs-keyword\">THEN</span> <span class=\"hljs-string\">&#x27;青年人&#x27;</span>\n    <span class=\"hljs-keyword\">WHEN</span> age <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">15</span> <span class=\"hljs-keyword\">AND</span> age <span class=\"hljs-operator\">&lt;=</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-keyword\">THEN</span> <span class=\"hljs-string\">&#x27;少年人&#x27;</span> \n    <span class=\"hljs-keyword\">ELSE</span> <span class=\"hljs-string\">&#x27;儿童&#x27;</span> <span class=\"hljs-keyword\">END</span>\n</code></pre>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">--写法2</span>\n<span class=\"hljs-comment\">--这是简单简单CASE格式</span>\n<span class=\"hljs-comment\">--仅支持字段与数据对比（即常说的等于）</span>\n<span class=\"hljs-comment\">--字段值与数据的数据类型必须相同或者可被隐性转换</span>\n<span class=\"hljs-comment\">--比如：数字类型的age可以和数字比（如本案例）</span>\n<span class=\"hljs-comment\">--数字类型的age可以和数字字符串字符串比（WHEN &#x27;60&#x27; THEN &#x27;60生日老人&#x27;）</span>\n<span class=\"hljs-comment\">--而(WHEN &#x27;abc&#x27; THEN &#x27;怪人&#x27;)则会报错</span>\n<span class=\"hljs-keyword\">CASE</span> age \n    <span class=\"hljs-keyword\">WHEN</span> <span class=\"hljs-number\">60</span> <span class=\"hljs-keyword\">THEN</span> <span class=\"hljs-string\">&#x27;60生日老人&#x27;</span>\n    <span class=\"hljs-keyword\">WHEN</span> <span class=\"hljs-number\">40</span> <span class=\"hljs-keyword\">THEN</span> <span class=\"hljs-string\">&#x27;40中年人&#x27;</span>\n    <span class=\"hljs-keyword\">WHEN</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-keyword\">THEN</span> <span class=\"hljs-string\">&#x27;20青年人&#x27;</span>\n    <span class=\"hljs-keyword\">WHEN</span> <span class=\"hljs-number\">15</span> <span class=\"hljs-keyword\">THEN</span> <span class=\"hljs-string\">&#x27;15少年人&#x27;</span> \n    <span class=\"hljs-keyword\">ELSE</span> <span class=\"hljs-string\">&#x27;儿童&#x27;</span> <span class=\"hljs-keyword\">END</span>\n</code></pre>\n<p>此外需要注意的是，THEN {result} 和 ELSE {result}中的{result}类型必须一致。</p>\n<p>比如下方的语法则会出错！</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">--这里THEN后面既有输出字符串也有输出数字的，无法统一类型</span>\n<span class=\"hljs-keyword\">CASE</span> age \n    <span class=\"hljs-keyword\">WHEN</span> <span class=\"hljs-number\">60</span> <span class=\"hljs-keyword\">THEN</span> <span class=\"hljs-string\">&#x27;60生日老人&#x27;</span>\n    <span class=\"hljs-keyword\">WHEN</span> <span class=\"hljs-number\">40</span> <span class=\"hljs-keyword\">THEN</span> <span class=\"hljs-number\">10086</span>\n    <span class=\"hljs-keyword\">WHEN</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-keyword\">THEN</span> <span class=\"hljs-string\">&#x27;20青年人&#x27;</span>\n    <span class=\"hljs-keyword\">WHEN</span> <span class=\"hljs-number\">15</span> <span class=\"hljs-keyword\">THEN</span> <span class=\"hljs-number\">12345</span> \n    <span class=\"hljs-keyword\">ELSE</span> <span class=\"hljs-number\">10010</span> <span class=\"hljs-keyword\">END</span>\n</code></pre>\n<h1 id=\"menu_3\">应用</h1><p>CASE WHEN一般放在SELECT子句内，下方通过案例进行了解其应用。</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">--如果sex为1查询出男、为2查询出女、其他查询出外星人</span>\n<span class=\"hljs-comment\">--并将结果命名为sex_name</span>\n<span class=\"hljs-keyword\">SELECT</span> u.name,\n    <span class=\"hljs-keyword\">CASE</span> u.sex \n        <span class=\"hljs-keyword\">WHEN</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">THEN</span> <span class=\"hljs-string\">&#x27;男&#x27;</span>\n        <span class=\"hljs-keyword\">WHEN</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">THEN</span> <span class=\"hljs-string\">&#x27;女&#x27;</span>\n        <span class=\"hljs-keyword\">ELSE</span> <span class=\"hljs-string\">&#x27;外星人&#x27;</span> <span class=\"hljs-keyword\">END</span> <span class=\"hljs-keyword\">AS</span> sex_name\n<span class=\"hljs-keyword\">FROM</span> sys_user u\n</code></pre>\n<h2 id=\"menu_4\">其他用法</h2><pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">--CASE WHEN判空 名字为空显示指定字符串</span>\n<span class=\"hljs-keyword\">CASE</span> <span class=\"hljs-keyword\">WHEN</span> name <span class=\"hljs-keyword\">IS</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">THEN</span> <span class=\"hljs-string\">&#x27;未知姓名&#x27;</span> <span class=\"hljs-keyword\">ELSE</span> name <span class=\"hljs-keyword\">END</span>\n<span class=\"hljs-comment\">--关于判空MySQL中有IFNULL(字段, 为空返回值)函数</span>\n</code></pre>\n<h2 id=\"menu_5\">衍生思路</h2><p>CASE WHEN可以通过某个特定的type字段分别从不同的表中查询数据（虽然这个方式非常不效率）</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">--如果文章type为1从post_book表取图片</span>\n<span class=\"hljs-comment\">--如果文章type为2从post_tool表取图片</span>\n<span class=\"hljs-comment\">--否则返回默认图片</span>\n<span class=\"hljs-keyword\">SELECT</span> p.id, p.img,\n    <span class=\"hljs-keyword\">CASE</span> p.type\n        <span class=\"hljs-keyword\">WHEN</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">THEN</span> \n            (<span class=\"hljs-keyword\">SELECT</span> b.img <span class=\"hljs-keyword\">FROM</span> post_book b <span class=\"hljs-keyword\">WHERE</span> b.pid <span class=\"hljs-operator\">=</span> p.id)\n        <span class=\"hljs-keyword\">WHEN</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">THEN</span> \n            (<span class=\"hljs-keyword\">SELECT</span> t.img <span class=\"hljs-keyword\">FROM</span> post_tool t <span class=\"hljs-keyword\">WHERE</span> t.pid <span class=\"hljs-operator\">=</span> p.id)\n        <span class=\"hljs-keyword\">ELSE</span> <span class=\"hljs-string\">&#x27;/normalImg.png&#x27;</span>\n        <span class=\"hljs-keyword\">END</span> <span class=\"hljs-keyword\">AS</span> logo\n<span class=\"hljs-keyword\">FROM</span> post p\n</code></pre>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">语法语义</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">两种写法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">应用</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">其他用法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">衍生思路</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1024, '# Redis\n\nRedis（Remote Dictionary Server）是一个由 Salvatore Sanfilippo写的key-value存储系统，是跨平台的非关系型数据库\n\nRedis是一个开源的使用ANSI C语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API\n\nRedis通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型\n\nRedis官网地址：[https://redis.io/](https://redis.io/)\n\n# 关于Windows版本\n\nRedis目前提供源码、Docker镜像、云版三种下载形式。\n\n需要注意的是Redis官网并**没有提供Windows版本**下载和安装。\n\nRedis是一个开源的应用，可以自行对源码进行封装成msi安装文件。\n\n但是对于绝大多数不熟悉Window应用开发的小伙伴来说，显然太过为难了！\n\n## Windows团队维护版\n\n几年前微软开源团队开始在github上维护Windows版本的Redis。\n\n地址：[https://github.com/microsoftarchive/redis/tags](https://github.com/microsoftarchive/redis/tags)\n\n但是从2016年开始，该项目就不再维护了，版本截止于3.2.100。\n\n![/static/upload/post/1645785984766.jpg](/static/upload/post/1645785984766.jpg)\n\n这是github上windows团队项目的简介：\n\n![/static/upload/post/1645785993324.jpg](/static/upload/post/1645785993324.jpg)\n\n我们尝试从memurai中找Windows版本的Redis，但这是一个商业化的网站，仅提供免费的开发版，并且10天就需要重新申请一次。\n\n嘶？这...\n\n![/static/upload/post/1645786003804.jpg](/static/upload/post/1645786003804.jpg)\n\n## 大佬带队版本\n\n好在！！！有一群志愿者站了出来，将redis的windows版本继续更新了！\n\n地址：[https://github.com/tporadowski/redis/tags](https://github.com/tporadowski/redis/tags)\n\n虽然并没有完全于官网版本号同步，但依旧保持着不断更新。\n\n![/static/upload/post/1645786026767.jpg](/static/upload/post/1645786026767.jpg)\n\n感谢大佬！\n\n地址：[https://github.com/tporadowski/redis/tags](https://github.com/tporadowski/redis/tags)\n', '<h1 id=\"menu_1\">Redis</h1><p>Redis（Remote Dictionary Server）是一个由 Salvatore Sanfilippo写的key-value存储系统，是跨平台的非关系型数据库</p>\n<p>Redis是一个开源的使用ANSI C语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API</p>\n<p>Redis通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型</p>\n<p>Redis官网地址：<a class=\"mlink\" href=\"https://redis.io/\" title=\"https://redis.io/\" target=\"_blank\">https://redis.io/</a></p>\n<h1 id=\"menu_2\">关于Windows版本</h1><p>Redis目前提供源码、Docker镜像、云版三种下载形式。</p>\n<p>需要注意的是Redis官网并<strong>没有提供Windows版本</strong>下载和安装。</p>\n<p>Redis是一个开源的应用，可以自行对源码进行封装成msi安装文件。</p>\n<p>但是对于绝大多数不熟悉Window应用开发的小伙伴来说，显然太过为难了！</p>\n<h2 id=\"menu_3\">Windows团队维护版</h2><p>几年前微软开源团队开始在github上维护Windows版本的Redis。</p>\n<p>地址：<a class=\"mlink\" href=\"https://github.com/microsoftarchive/redis/tags\" title=\"https://github.com/microsoftarchive/redis/tags\" target=\"_blank\">https://github.com/microsoftarchive/redis/tags</a></p>\n<p>但是从2016年开始，该项目就不再维护了，版本截止于3.2.100。</p>\n<p><img src=\"/static/upload/post/1645785984766.jpg\" alt=\"/static/upload/post/1645785984766.jpg\"/></p>\n<p>这是github上windows团队项目的简介：</p>\n<p><img src=\"/static/upload/post/1645785993324.jpg\" alt=\"/static/upload/post/1645785993324.jpg\"/></p>\n<p>我们尝试从memurai中找Windows版本的Redis，但这是一个商业化的网站，仅提供免费的开发版，并且10天就需要重新申请一次。</p>\n<p>嘶？这...</p>\n<p><img src=\"/static/upload/post/1645786003804.jpg\" alt=\"/static/upload/post/1645786003804.jpg\"/></p>\n<h2 id=\"menu_4\">大佬带队版本</h2><p>好在！！！有一群志愿者站了出来，将redis的windows版本继续更新了！</p>\n<p>地址：<a class=\"mlink\" href=\"https://github.com/tporadowski/redis/tags\" title=\"https://github.com/tporadowski/redis/tags\" target=\"_blank\">https://github.com/tporadowski/redis/tags</a></p>\n<p>虽然并没有完全于官网版本号同步，但依旧保持着不断更新。</p>\n<p><img src=\"/static/upload/post/1645786026767.jpg\" alt=\"/static/upload/post/1645786026767.jpg\"/></p>\n<p>感谢大佬！</p>\n<p>地址：<a class=\"mlink\" href=\"https://github.com/tporadowski/redis/tags\" title=\"https://github.com/tporadowski/redis/tags\" target=\"_blank\">https://github.com/tporadowski/redis/tags</a></p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">Redis</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">关于Windows版本</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">Windows团队维护版</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">大佬带队版本</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1025, '# Spring\n\nSpring是一个开源**容器**框架。\n\n可以接管web层，业务层，dao层，持久层的组件，并且可以配置各种bean,和维护bean与bean之间的关系。\n\n其核心就是控制反转(IOC)和面向切面(AOP)。\n\n简单的说就是一个分层的轻量级开源框架。\n\n# SpringMVC\n\nSpringMVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。\n\nSpringMVC是Web层MVC框架，用于替代servlet（处理|响应请求，获取表单参数，表单校验等）。\n\n某种意义上来说SpringMVC可以相当于是Struts2加上Spring的整合。\n\n# SpringBoot\n\nSpringBoot是一个微服务框架，延续了Spring框架的核心思想IOC和AOP，简化了应用的开发和部署。\n\nSpringBoot是为了简化Spring应用的创建、运行、调试、部署等而出现的，使用它可以做到专注于Spring应用的开发，而无需过多关注XML的配置。\n\n提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题->习惯大于约定。\n\nSpringBoot的核心在于自动配置。\n\n# 关系说明\n\n## SpringMVC和Spring的关系\n\nSpring为简化我们的开发工作，封装了一系列的开箱即用的组件功能模块。\n\n包括：Spring JDBC 、Spring MVC 、Spring Security、 Spring AOP 、Spring ORM 、Spring Test等。\n如下图：\n\n![/static/upload/post/1645786392786.jpg](/static/upload/post/1645786392786.jpg)\n\n因此：\nSpringMVC是属于SpringWeb里面的一个功能模块（SpringWebMVC）。\n\n专门用来开发SpringWeb项目的一种MVC模式的技术框架实现。\n\n## Spring和SpringBoot的关系\n\nSpringBoot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。\n\n我们通过了解SpringBoot所具备的能力就很容易理解Spring和SpringBoot的关系。\n\n1. 创建独立的spring应用。\n2. 嵌入Tomcat, JettyUndertow 而且不需要部署他们\n3. 提供的“starters” poms来简化Maven配置\n4. 尽可能自动配置spring应用\n5. 提供生产指标,健壮检查和外部化配置\n6. 绝对没有代码生成和XML配置要求\n\n从功能角度来看，SpringBoot可以理解为一个可以一键发布的Spring应用。\n\n## 三者关系概述\n\nspring mvc < spring < springboot\n\n - Spring包含了SpringMVC\n - SpringBoot包含了Spring\n - SpringBoot在Spring的基础上进行了增强\n\n# SpringBoot下的应用创建和部署\n\n回忆一下在没有SpringBoot之前我们创建和发布一个应用需要做那些事情？\n\n1. pom.xml中引入Spring依赖\n2. pom.xml中引入第三方依赖，并通过配置文件与Spring整合（Bean管理）\n3. 解决各类依赖冲突（尤其是第三方的依赖版本冲突）\n4. 选择一个运行的容器（如：Tomcat，以下已Tomcat举例）\n5. 在环境上安装好Tomcat容器\n6. 配置Tomcat容器的server.xml（应用路径、端口等）\n7. 通过maven编译打包（pom.xml需配置编译打包插件）\n8. 将War包放到Tomcat容器指定路径\n9. 启动Tomcat容器（bin/startup.sh）\n\n通过SpringBoot来创建应用我们需要做什么？\n\n1. pom.xml中引入SpringBoot的starter依赖\n2. pom.xml中引入第三方starter（无需整合和依赖冲突，starter已按照**约定配置做好整合**）\n3. 通过maven编译打包（pom.xml仅需指定发布格式，如Jar包）\n4. 将Jar包放到环境上\n5. java -jar xxx.jar（完成启动）\n\n# 一句话结论\n\nSpring包含了SpringMVC，SpringBoot是Spring的扩展，使开发，测试和部署更加方便。\n\n - Spring 是一个核心引擎\n - SpringMVC是基于核心引擎的一个MVC框架（用于Web开发）\n - SpringBoot是基于核心引擎的一套快速开发整合包', '<h1 id=\"menu_1\">Spring</h1><p>Spring是一个开源<strong>容器</strong>框架。</p>\n<p>可以接管web层，业务层，dao层，持久层的组件，并且可以配置各种bean,和维护bean与bean之间的关系。</p>\n<p>其核心就是控制反转(IOC)和面向切面(AOP)。</p>\n<p>简单的说就是一个分层的轻量级开源框架。</p>\n<h1 id=\"menu_2\">SpringMVC</h1><p>SpringMVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。</p>\n<p>SpringMVC是Web层MVC框架，用于替代servlet（处理|响应请求，获取表单参数，表单校验等）。</p>\n<p>某种意义上来说SpringMVC可以相当于是Struts2加上Spring的整合。</p>\n<h1 id=\"menu_3\">SpringBoot</h1><p>SpringBoot是一个微服务框架，延续了Spring框架的核心思想IOC和AOP，简化了应用的开发和部署。</p>\n<p>SpringBoot是为了简化Spring应用的创建、运行、调试、部署等而出现的，使用它可以做到专注于Spring应用的开发，而无需过多关注XML的配置。</p>\n<p>提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题-&gt;习惯大于约定。</p>\n<p>SpringBoot的核心在于自动配置。</p>\n<h1 id=\"menu_4\">关系说明</h1><h2 id=\"menu_5\">SpringMVC和Spring的关系</h2><p>Spring为简化我们的开发工作，封装了一系列的开箱即用的组件功能模块。</p>\n<p>包括：Spring JDBC 、Spring MVC 、Spring Security、 Spring AOP 、Spring ORM 、Spring Test等。<br/>如下图：</p>\n<p><img src=\"/static/upload/post/1645786392786.jpg\" alt=\"/static/upload/post/1645786392786.jpg\"/></p>\n<p>因此：<br/>SpringMVC是属于SpringWeb里面的一个功能模块（SpringWebMVC）。</p>\n<p>专门用来开发SpringWeb项目的一种MVC模式的技术框架实现。</p>\n<h2 id=\"menu_6\">Spring和SpringBoot的关系</h2><p>SpringBoot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。</p>\n<p>我们通过了解SpringBoot所具备的能力就很容易理解Spring和SpringBoot的关系。</p>\n<ol>\n<li>创建独立的spring应用。</li>\n<li>嵌入Tomcat, JettyUndertow 而且不需要部署他们</li>\n<li>提供的“starters” poms来简化Maven配置</li>\n<li>尽可能自动配置spring应用</li>\n<li>提供生产指标,健壮检查和外部化配置</li>\n<li>绝对没有代码生成和XML配置要求</li>\n</ol>\n<p>从功能角度来看，SpringBoot可以理解为一个可以一键发布的Spring应用。</p>\n<h2 id=\"menu_7\">三者关系概述</h2><p>spring mvc &lt; spring &lt; springboot</p>\n<ul>\n<li>Spring包含了SpringMVC</li>\n<li>SpringBoot包含了Spring</li>\n<li>SpringBoot在Spring的基础上进行了增强</li>\n</ul>\n<h1 id=\"menu_8\">SpringBoot下的应用创建和部署</h1><p>回忆一下在没有SpringBoot之前我们创建和发布一个应用需要做那些事情？</p>\n<ol>\n<li>pom.xml中引入Spring依赖</li>\n<li>pom.xml中引入第三方依赖，并通过配置文件与Spring整合（Bean管理）</li>\n<li>解决各类依赖冲突（尤其是第三方的依赖版本冲突）</li>\n<li>选择一个运行的容器（如：Tomcat，以下已Tomcat举例）</li>\n<li>在环境上安装好Tomcat容器</li>\n<li>配置Tomcat容器的server.xml（应用路径、端口等）</li>\n<li>通过maven编译打包（pom.xml需配置编译打包插件）</li>\n<li>将War包放到Tomcat容器指定路径</li>\n<li>启动Tomcat容器（bin/startup.sh）</li>\n</ol>\n<p>通过SpringBoot来创建应用我们需要做什么？</p>\n<ol>\n<li>pom.xml中引入SpringBoot的starter依赖</li>\n<li>pom.xml中引入第三方starter（无需整合和依赖冲突，starter已按照<strong>约定配置做好整合</strong>）</li>\n<li>通过maven编译打包（pom.xml仅需指定发布格式，如Jar包）</li>\n<li>将Jar包放到环境上</li>\n<li>java -jar xxx.jar（完成启动）</li>\n</ol>\n<h1 id=\"menu_9\">一句话结论</h1><p>Spring包含了SpringMVC，SpringBoot是Spring的扩展，使开发，测试和部署更加方便。</p>\n<ul>\n<li>Spring 是一个核心引擎</li>\n<li>SpringMVC是基于核心引擎的一个MVC框架（用于Web开发）</li>\n<li>SpringBoot是基于核心引擎的一套快速开发整合包</li>\n</ul>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">Spring</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">SpringMVC</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">SpringBoot</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">关系说明</a> <ul><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">SpringMVC和Spring的关系</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">Spring和SpringBoot的关系</a> <!----></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">三者关系概述</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl1\">SpringBoot下的应用创建和部署</a> <!----></li><li><a href=\"javascript:runTo(\'menu_9\')\" class=\"pl1\">一句话结论</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1026, '# 问题描述\n\nAndroid Studio手滑设置了一个代理（本想提升一下下载速度）\n\n结果设置代理后发现，Could not install Gradle distribution...\n\n几乎所有的下载行为都失败了，已知公司的网络本身没有代理也能够流畅的下载依赖\n\n所以...我是配置了一个Down掉的代理\n\n# 关闭代理\n\nAndroid Studio关闭代理位于：【File】->【Settings】->【见下图】\n\n![/static/upload/post/1646005936236.jpg](/static/upload/post/1646005936236.jpg)\n\n原本以为设置玩之后，就可以轻松愉悦的继续搬砖了，玩玩没想到的是...\n\n依旧是报错报的飞起。\n\n# 检查gradle.properties\n\nAndroid Studio中设置完代理后，会在项目的gradle.properties文件中生成代理配置信息。\n\n大致效果如下图：\n\n![/static/upload/post/1646005946314.jpg](/static/upload/post/1646005946314.jpg)\n\n在gradle.properties配置中删除**systemProp.http[3].proxy***相关的配置。\n\n同时检查gradle.properties的公共配置文件和项目配置文件是否均没有代理的配置项。\n\n![/static/upload/post/1646005956589.jpg](/static/upload/post/1646005956589.jpg)\n\n# 公共配置文件位置\n\n一般情况在Android Studio即可修改公共配置文件。\n\n如果需要自行寻找修改，一般位于：**C:UsersAdministrator.gradle**\n\n![/static/upload/post/1646005966604.jpg](/static/upload/post/1646005966604.jpg)\n', '<h1 id=\"menu_1\">问题描述</h1><p>Android Studio手滑设置了一个代理（本想提升一下下载速度）</p>\n<p>结果设置代理后发现，Could not install Gradle distribution...</p>\n<p>几乎所有的下载行为都失败了，已知公司的网络本身没有代理也能够流畅的下载依赖</p>\n<p>所以...我是配置了一个Down掉的代理</p>\n<h1 id=\"menu_2\">关闭代理</h1><p>Android Studio关闭代理位于：【File】-&gt;【Settings】-&gt;【见下图】</p>\n<p><img src=\"/static/upload/post/1646005936236.jpg\" alt=\"/static/upload/post/1646005936236.jpg\"/></p>\n<p>原本以为设置玩之后，就可以轻松愉悦的继续搬砖了，玩玩没想到的是...</p>\n<p>依旧是报错报的飞起。</p>\n<h1 id=\"menu_3\">检查gradle.properties</h1><p>Android Studio中设置完代理后，会在项目的gradle.properties文件中生成代理配置信息。</p>\n<p>大致效果如下图：</p>\n<p><img src=\"/static/upload/post/1646005946314.jpg\" alt=\"/static/upload/post/1646005946314.jpg\"/></p>\n<p>在gradle.properties配置中删除<strong>systemProp.http[3].proxy</strong>*相关的配置。</p>\n<p>同时检查gradle.properties的公共配置文件和项目配置文件是否均没有代理的配置项。</p>\n<p><img src=\"/static/upload/post/1646005956589.jpg\" alt=\"/static/upload/post/1646005956589.jpg\"/></p>\n<h1 id=\"menu_4\">公共配置文件位置</h1><p>一般情况在Android Studio即可修改公共配置文件。</p>\n<p>如果需要自行寻找修改，一般位于：<strong>C:UsersAdministrator.gradle</strong></p>\n<p><img src=\"/static/upload/post/1646005966604.jpg\" alt=\"/static/upload/post/1646005966604.jpg\"/></p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">问题描述</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">关闭代理</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">检查gradle.properties</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">公共配置文件位置</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1027, '# MVC简介\n\nMVC的全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范。\n\nMVC是用一种业务逻辑、数据与界面显示分离的方法来组织代码，将众多的业务逻辑聚集到一个部件里面，在需要改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，达到减少编码的时间。\n\nMVC始存于桌面程序中的，M是指业务模型，V是指用户界面，C则是控制器。\n\nMVC设计在Java Web应用中得到广泛的应用，但其并不局限于Java语言，比如前端、PHP、.NET 等语言。\n\n之所以采用MVC设计模式的根本原因在于解耦各个模块。\n\n## MVC设计思想\n\nMVC英文即Model-View-Controller，即把一个应用的输入、处理、输出流程按照Model、View、Controller的方式进行分离，这样一个应用被分成三个层：模型层、视图层、控制层。\n\nMVC三个层面的职责非常明确，而且相互分离，因此每个层面都可以独立的改变而不影响其他部分，从而大大提高了应用的灵活性和重用性。\n\n\n![/static/upload/post/1646006359290.jpg](/static/upload/post/1646006359290.jpg)\n\n\n### 模型（Model）\n\n模型（Model）通常又分为数据模型和业务逻辑模型。\n\n1. 数据模型用来存放业务数据，比如订单信息、用户信息等；\n2. 业务逻辑模型包含应用的业务操作，比如订单的添加或者修改等。\n\n因此：Model主要用于存储数据以及处理用户请求的业务逻辑。\n\n### 视图（View）\n\n视图（View）代表模型（Model）包含的数据的可视化，将内容展现给用户。\n\n - 视图从模型获得要展示的数据，然后用自己的方式展现给用户，相当于提供界面来与用户进行人机交互，比如由html元素组成的网页界面，或者软件的客户端界面。\n - 一般来说，模型发生改变时会通知视图，视图也可以主动向模型（经过控制器）查询变化来保证数据一致性。\n - 当用户在视图（View）界面上操作后，如提交、触发事件等，将向控制器（Controller）发出请求。\n\n### 控制器（Controller）\n\n控制器（Controller）控制数据流向模型对象，并在数据变化时更新视图。\n\n控制器（Controller）作用于模型和视图上，本身并不做任何处理，它使得视图与模型解耦分离。\n\n1. 收到用户的请求后，会将请求与模型的更新相映射，调用模型来实现用户请求的功能。\n2. 选择用于响应的视图，将模型更新后的数据展示给用户。\n\n# MVC的作用\n\n当程序结构划分不明确时，各个部分功能混乱，如果需要变更业务功能时，无论是业务逻辑修改还是显示形式修改，都要修改很多的关联类，“牵一发而动全身”，导致软件的开发和维护效率低下，BUG百出。\n\n遵循MVC模式来开发系统，就会极大的避免上述问题的出现。\n\nMVC模式的核心手段是解耦，MVC模式通过科学的层次划分，把整个应用程序划分成模型、视图、控制器三个部分，然后严密控制三个部分之间的通信，从而得到一个结构清晰、功能分布合理、可重用、可扩展、可维护的应用程序。\n\n## MVC的好处\n\n1. 低耦合：\n	MVC模式，模型和视图是解耦的，模型不会依赖于视图，而视图也仅仅是从模型中获取需要展示的数据，并不会与模型的逻辑处理相关联。\n2. 低成本：\n	MVC模式帮我们清楚的划分了职责，可以让程序员各司其职，服务端只关心业务逻辑的实现，也就是模型部分；UI程序员只关心页面展示，也就是视图部分即可。\n3. 可维护：\n	MVC模式划分出明晰的模型和视图部分，并使其解耦，在软件需求发生变更的时候，就可以各自独立的改变而不会相互影响，使得程序更容易维护和扩展。\n\n# MVC在Web应用中的实现（Model2模型）\n\n采用MVC设计模式并不一定完全生搬硬套。\n\n比如在Java的Web开发中，通常把Servlet+JSP+JavaBean的模型称为Model2模型，这是一个完全遵循MVC模式的模型。\n\n经典框架Struts2、SpringMVC均遵循了这个模型进行设计。\n\n - JavaBean（模型）{数据模型：实体类；逻辑模型：Service层、Dao层等}\n - JSP（视图）\n - Servlet（控制）{原生Servlet、SpringMVC的Controller、Struts2的Action等}\n\n在Web开发中，由于Web应用程序的性质，不存在服务器主动向客户端“推”数据（这里代指TCP协议下），因此从Model到View之间的虚线是不存在的。\n\n效果如下图：\n\n![/static/upload/post/1646006409933.gif](/static/upload/post/1646006409933.gif)', '<h1 id=\"menu_1\">MVC简介</h1><p>MVC的全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范。</p>\n<p>MVC是用一种业务逻辑、数据与界面显示分离的方法来组织代码，将众多的业务逻辑聚集到一个部件里面，在需要改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，达到减少编码的时间。</p>\n<p>MVC始存于桌面程序中的，M是指业务模型，V是指用户界面，C则是控制器。</p>\n<p>MVC设计在Java Web应用中得到广泛的应用，但其并不局限于Java语言，比如前端、PHP、.NET 等语言。</p>\n<p>之所以采用MVC设计模式的根本原因在于解耦各个模块。</p>\n<h2 id=\"menu_2\">MVC设计思想</h2><p>MVC英文即Model-View-Controller，即把一个应用的输入、处理、输出流程按照Model、View、Controller的方式进行分离，这样一个应用被分成三个层：模型层、视图层、控制层。</p>\n<p>MVC三个层面的职责非常明确，而且相互分离，因此每个层面都可以独立的改变而不影响其他部分，从而大大提高了应用的灵活性和重用性。</p>\n<p><img src=\"/static/upload/post/1646006359290.jpg\" alt=\"/static/upload/post/1646006359290.jpg\"/></p>\n<h3 id=\"menu_3\">模型（Model）</h3><p>模型（Model）通常又分为数据模型和业务逻辑模型。</p>\n<ol>\n<li>数据模型用来存放业务数据，比如订单信息、用户信息等；</li>\n<li>业务逻辑模型包含应用的业务操作，比如订单的添加或者修改等。</li>\n</ol>\n<p>因此：Model主要用于存储数据以及处理用户请求的业务逻辑。</p>\n<h3 id=\"menu_4\">视图（View）</h3><p>视图（View）代表模型（Model）包含的数据的可视化，将内容展现给用户。</p>\n<ul>\n<li>视图从模型获得要展示的数据，然后用自己的方式展现给用户，相当于提供界面来与用户进行人机交互，比如由html元素组成的网页界面，或者软件的客户端界面。</li>\n<li>一般来说，模型发生改变时会通知视图，视图也可以主动向模型（经过控制器）查询变化来保证数据一致性。</li>\n<li>当用户在视图（View）界面上操作后，如提交、触发事件等，将向控制器（Controller）发出请求。</li>\n</ul>\n<h3 id=\"menu_5\">控制器（Controller）</h3><p>控制器（Controller）控制数据流向模型对象，并在数据变化时更新视图。</p>\n<p>控制器（Controller）作用于模型和视图上，本身并不做任何处理，它使得视图与模型解耦分离。</p>\n<ol>\n<li>收到用户的请求后，会将请求与模型的更新相映射，调用模型来实现用户请求的功能。</li>\n<li>选择用于响应的视图，将模型更新后的数据展示给用户。</li>\n</ol>\n<h1 id=\"menu_6\">MVC的作用</h1><p>当程序结构划分不明确时，各个部分功能混乱，如果需要变更业务功能时，无论是业务逻辑修改还是显示形式修改，都要修改很多的关联类，“牵一发而动全身”，导致软件的开发和维护效率低下，BUG百出。</p>\n<p>遵循MVC模式来开发系统，就会极大的避免上述问题的出现。</p>\n<p>MVC模式的核心手段是解耦，MVC模式通过科学的层次划分，把整个应用程序划分成模型、视图、控制器三个部分，然后严密控制三个部分之间的通信，从而得到一个结构清晰、功能分布合理、可重用、可扩展、可维护的应用程序。</p>\n<h2 id=\"menu_7\">MVC的好处</h2><ol>\n<li>低耦合：<br/> MVC模式，模型和视图是解耦的，模型不会依赖于视图，而视图也仅仅是从模型中获取需要展示的数据，并不会与模型的逻辑处理相关联。</li>\n<li>低成本：<br/> MVC模式帮我们清楚的划分了职责，可以让程序员各司其职，服务端只关心业务逻辑的实现，也就是模型部分；UI程序员只关心页面展示，也就是视图部分即可。</li>\n<li>可维护：<br/> MVC模式划分出明晰的模型和视图部分，并使其解耦，在软件需求发生变更的时候，就可以各自独立的改变而不会相互影响，使得程序更容易维护和扩展。</li>\n</ol>\n<h1 id=\"menu_8\">MVC在Web应用中的实现（Model2模型）</h1><p>采用MVC设计模式并不一定完全生搬硬套。</p>\n<p>比如在Java的Web开发中，通常把Servlet+JSP+JavaBean的模型称为Model2模型，这是一个完全遵循MVC模式的模型。</p>\n<p>经典框架Struts2、SpringMVC均遵循了这个模型进行设计。</p>\n<ul>\n<li>JavaBean（模型）{数据模型：实体类；逻辑模型：Service层、Dao层等}</li>\n<li>JSP（视图）</li>\n<li>Servlet（控制）{原生Servlet、SpringMVC的Controller、Struts2的Action等}</li>\n</ul>\n<p>在Web开发中，由于Web应用程序的性质，不存在服务器主动向客户端“推”数据（这里代指TCP协议下），因此从Model到View之间的虚线是不存在的。</p>\n<p>效果如下图：</p>\n<p><img src=\"/static/upload/post/1646006409933.gif\" alt=\"/static/upload/post/1646006409933.gif\"/></p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">MVC简介</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">MVC设计思想</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl3\">模型（Model）</a></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl3\">视图（View）</a></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl3\">控制器（Controller）</a></li></ul></li></ul></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl1\">MVC的作用</a> <ul><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">MVC的好处</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl1\">MVC在Web应用中的实现（Model2模型）</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1028, '# 框架简介\n\nSpringMVC框架通过实现Model-View-Controller（MVC）模式来很好地将数据、业务与展现进行分离\n\nSpringMVC框架和Struts、Struts2非常类似\n\nSpringMVC的设计是围绕**DispatcherServlet（前端控制器）**展开的\n\n## DispatcherServlet：\n\n1. 负责将请求派发到特定的handler（处理程序）\n2. 给处理程序分派请求，执行视图解析，处理语言环境和主题解析，支持上传文件\n3. 通过映射来决定哪一个处理程序应当处理传入的请求\n4. 通过可配的handler mappings、view resolution、locale以及theme resolution来处理请求并且转到对应的视图。\n\n# 框架优点\n\nSpringMVC，基于MVC架构模式的思想，将web层进行职责解耦\n\n请求驱动类型是使用请求-响应模型，框架的目的就是帮助我们简化开发\n\n清晰的角色划分，分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要：\n\n - 前端控制器（DispatcherServlet）\n - 请求到处理器映射（HandlerMapping）\n - 处理器适配器（HandlerAdapter）\n - 视图解析器（ViewResolver）\n - 处理器或页面控制器（Controller）\n - 验证器（ Validator）\n - 命令对象（Command请求参数绑定到的对象就叫命令对象）\n - 表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）\n\n## 优点列举\n\n1. SpringMVC拥有强大的灵活性、非入侵性和可配置性\n2. SpringMVC提供了一个前端控制器DispatcherServlet，开发者无须额外开发控制器对象\n3. SpringMVC分工明确，包含控制器、验证器、命令对象、模型对象、处理程序映射视图解析器，等等，每一个功能实现由一个专门的对象负责完成\n4. SpringMVC可以自动绑定用户输入，并正确地转换数据类型。例如：SpringMVC能自动解析字符串，并将其设置为模型的int或float类型的属性\n5. SpringMVC使用一个名称/值的Map对象实现更加灵活的模型数据传输\n6. SpringMVC内置了常见的校验器，可以校验用户输入，如果校验不通过，则重定向回输入表单。输入校验是可选的，并且支持编程方式及声明方式\n7. SpringMVC支持国际化，支持根据用户区域显示多国语言，并且国际化的配置非常简单\n8. SpringMVC支持多种视图技术，最常见的有JSP技术以及其他技术，包括Velocity和FreeMarker\n9. SpringMVC提供了一个简单而强大的JSP标签库，支持数据绑定功能，使得编写JSP页面更加容易\n10. SpringMVC属于Spring框架的子项目，比起其他轻量级WEB框架最大的优势：与Spring框架无缝集成   \n\n# 核心类\n\n - **DispatcherServlet：前端控制器**\n	用户请求到达前端控制器，它就相当于MVC模式中的Controller\n	虽然实际应用中开发依旧需要开发业务自有的Controller层，但DispatcherServlet相当于一个总的入口\n	DispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，降低组件之间的耦合性\n	\n - **HandlerMapping：处理器映射器**\n	HandlerMapping负责根据用户请求找到Handler即处理器\n	SpringMVC框架提供了不同的映射器实现不同的映射方式\n	例如：配置文件方式，实现接口方式，注解方式等\n	\n - **Handler：处理器**\n	Handler是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理\n	Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler（也就是我们实际开发的Controller）\n	\n - **HandlAdapter：处理器适配器**\n	通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行 \n	\n - **View Resolver：视图解析器**\n	View Resolver负责将处理结果生成View视图\n	View Resolver根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象\n	对View进行渲染将处理结果通过页面展示给用户\n	\n - **View：视图**\n	SpringMVC框架提供了很多的View视图类型的支持\n	包括：jstlView、freemarkerView、pdfView等\n	我们最常用的视图就是jsp\n	通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要根据业务需求开发具体的页面\n\n# 数据流程\n\n1. **用户发送请求—>DispatcherServlet**\n	前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制\n	\n2. **DispatcherServlet—>HandlerMapping**\n	HandlerMapping将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象，通过这种策略模式，很容易添加新的映射策略\n	\n3. **DispatcherServlet—>HandlerAdapter**\n	HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器\n	\n4. **HandlerAdapter—>处理器功能处理方法的调用**\n	HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理\n	\n5. **返回一个ModelAndView对象（Model模型数据）**\n	包含模型数据、逻辑视图名\n	\n6. **ModelAndView的逻辑视图名—> ViewResolver**\n	ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术\n	\n7. **View—>渲染**\n	View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术\n	\n8. **返回给DispatcherServlet**\n	由DispatcherServlet返回响应给用户，到此一个流程结束\n', '<h1 id=\"menu_1\">框架简介</h1><p>SpringMVC框架通过实现Model-View-Controller（MVC）模式来很好地将数据、业务与展现进行分离</p>\n<p>SpringMVC框架和Struts、Struts2非常类似</p>\n<p>SpringMVC的设计是围绕<strong>DispatcherServlet（前端控制器）</strong>展开的</p>\n<h2 id=\"menu_2\">DispatcherServlet：</h2><ol>\n<li>负责将请求派发到特定的handler（处理程序）</li>\n<li>给处理程序分派请求，执行视图解析，处理语言环境和主题解析，支持上传文件</li>\n<li>通过映射来决定哪一个处理程序应当处理传入的请求</li>\n<li>通过可配的handler mappings、view resolution、locale以及theme resolution来处理请求并且转到对应的视图。</li>\n</ol>\n<h1 id=\"menu_3\">框架优点</h1><p>SpringMVC，基于MVC架构模式的思想，将web层进行职责解耦</p>\n<p>请求驱动类型是使用请求-响应模型，框架的目的就是帮助我们简化开发</p>\n<p>清晰的角色划分，分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要：</p>\n<ul>\n<li>前端控制器（DispatcherServlet）</li>\n<li>请求到处理器映射（HandlerMapping）</li>\n<li>处理器适配器（HandlerAdapter）</li>\n<li>视图解析器（ViewResolver）</li>\n<li>处理器或页面控制器（Controller）</li>\n<li>验证器（ Validator）</li>\n<li>命令对象（Command请求参数绑定到的对象就叫命令对象）</li>\n<li>表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）</li>\n</ul>\n<h2 id=\"menu_4\">优点列举</h2><ol>\n<li>SpringMVC拥有强大的灵活性、非入侵性和可配置性</li>\n<li>SpringMVC提供了一个前端控制器DispatcherServlet，开发者无须额外开发控制器对象</li>\n<li>SpringMVC分工明确，包含控制器、验证器、命令对象、模型对象、处理程序映射视图解析器，等等，每一个功能实现由一个专门的对象负责完成</li>\n<li>SpringMVC可以自动绑定用户输入，并正确地转换数据类型。例如：SpringMVC能自动解析字符串，并将其设置为模型的int或float类型的属性</li>\n<li>SpringMVC使用一个名称/值的Map对象实现更加灵活的模型数据传输</li>\n<li>SpringMVC内置了常见的校验器，可以校验用户输入，如果校验不通过，则重定向回输入表单。输入校验是可选的，并且支持编程方式及声明方式</li>\n<li>SpringMVC支持国际化，支持根据用户区域显示多国语言，并且国际化的配置非常简单</li>\n<li>SpringMVC支持多种视图技术，最常见的有JSP技术以及其他技术，包括Velocity和FreeMarker</li>\n<li>SpringMVC提供了一个简单而强大的JSP标签库，支持数据绑定功能，使得编写JSP页面更加容易</li>\n<li>SpringMVC属于Spring框架的子项目，比起其他轻量级WEB框架最大的优势：与Spring框架无缝集成   </li>\n</ol>\n<h1 id=\"menu_5\">核心类</h1><ul>\n<li><strong>DispatcherServlet：前端控制器</strong><br/> 用户请求到达前端控制器，它就相当于MVC模式中的Controller<br/> 虽然实际应用中开发依旧需要开发业务自有的Controller层，但DispatcherServlet相当于一个总的入口<br/> DispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，降低组件之间的耦合性</li>\n<li><strong>HandlerMapping：处理器映射器</strong><br/> HandlerMapping负责根据用户请求找到Handler即处理器<br/> SpringMVC框架提供了不同的映射器实现不同的映射方式<br/> 例如：配置文件方式，实现接口方式，注解方式等</li>\n<li><strong>Handler：处理器</strong><br/> Handler是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理<br/> Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler（也就是我们实际开发的Controller）</li>\n<li><strong>HandlAdapter：处理器适配器</strong><br/> 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行 </li>\n<li><strong>View Resolver：视图解析器</strong><br/> View Resolver负责将处理结果生成View视图<br/> View Resolver根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象<br/> 对View进行渲染将处理结果通过页面展示给用户</li>\n<li><strong>View：视图</strong><br/> SpringMVC框架提供了很多的View视图类型的支持<br/> 包括：jstlView、freemarkerView、pdfView等<br/> 我们最常用的视图就是jsp<br/> 通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要根据业务需求开发具体的页面</li>\n</ul>\n<h1 id=\"menu_6\">数据流程</h1><ol>\n<li><strong>用户发送请求—&gt;DispatcherServlet</strong><br/> 前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制</li>\n<li><strong>DispatcherServlet—&gt;HandlerMapping</strong><br/> HandlerMapping将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象，通过这种策略模式，很容易添加新的映射策略</li>\n<li><strong>DispatcherServlet—&gt;HandlerAdapter</strong><br/> HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器</li>\n<li><strong>HandlerAdapter—&gt;处理器功能处理方法的调用</strong><br/> HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理</li>\n<li><strong>返回一个ModelAndView对象（Model模型数据）</strong><br/> 包含模型数据、逻辑视图名</li>\n<li><strong>ModelAndView的逻辑视图名—&gt; ViewResolver</strong><br/> ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术</li>\n<li><strong>View—&gt;渲染</strong><br/> View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术</li>\n<li><strong>返回给DispatcherServlet</strong><br/> 由DispatcherServlet返回响应给用户，到此一个流程结束</li>\n</ol>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">框架简介</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">DispatcherServlet：</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">框架优点</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">优点列举</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">核心类</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl1\">数据流程</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1029, '# maven简介\n\nmaven是一个用于项目管理的综合工具。\n\n1. 提供了开发人员构建一个完整的生命周期框架。\n2. 可以自动完成项目的基础工具建设。\n3. 应对多个开发团队环境时，可以设置按标准在非常短的时间里完成配置工作。\n4. 让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。\n5. 最强大的功能就是能够自动下载项目依赖库，这也是最实用的地方。\n6. 是专门用于构建和管理Java相关项目的管理工具。\n\nmaven是意第绪语，依地语（犹太人使用的国际语），表示专家的意思。\n\n用maven管理Java 项目，你就是专家了，哈哈哈！\n\n# pom.xml\n\nPOM代表项目对象模型，是maven中工作的基本单位，是一个xml文件，始终保存在项目根目录中的pom.xml文件。\n\n建立一个maven项目，maven会检查你的pom.xml文件，以确定哪些依赖下载。\n\n首先，maven将从本地资源库获得maven的本地资源库依赖资源。\n\n如果没有找到，会从默认的maven中央存储库查找下载。\n\n因此，pom.xml是配置项目依赖关系的重要文件。\n\n## 实例解析\n\n取用一个单项目pom.xml并对其解释，便于理解其配置和运作方式。\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n	http://maven.apache.org/maven-v4_0_0.xsd\">\n<!-- 指定当前POM模型的版本，对于maven2,maven3只能是4.0.0 -->\n<modelVersion>4.0.0</modelVersion>\n<!-- 项目编号，独一无二的。可以理解为父级package --> \n<groupId>com.mebugs</groupId>\n<!-- 项目名称，与项目编号组成唯一的项目标识 -->\n<artifactId>mebugsWeb</artifactId>\n<!-- 项目的版本 -->\n<version>1.0</version>\n<!-- 项目产生的构件类型，例如jar、war，插件可以创建他们自己的构件类型 -->\n<packaging>war</packaging> \n<!-- 项目名称，用来声明一个对用户而言比较友好的项目名称，文档使用 --> \n<name>Mebugs Maven Webapp</name> \n<!-- 项目主页的URL，maven产生的文档用。非必须 -->\n<url>http://maven.apache.org</url>\n<!-- 项目的详细描述,文档用。非必须 -->\n<description>A maven project for mebugs</description>\n<!-- 常用的版本号统一设置 -->\n<properties>\n	<!-- 定义spring的版本 -->\n	<spring.version>4.3.10.RELEASE</spring.version>\n	<!-- 定义jackson的版本 -->\n	<jackson.version>2.9.3</jackson.version>\n	<!-- 项目编码方式 -->\n	<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n	<!-- jdk版本 -->\n	<jdk.version>1.8</jdk.version>\n</properties> \n<!-- 依赖列表 -->\n<dependencies>\n	<!-- 基础的依赖配置，版本号自行填写 -->\n	<dependency>\n		<groupId>log4j</groupId>\n		<artifactId>log4j</artifactId>\n		<version>1.2.17</version>\n		<!-- 依赖类型，可不写，默认类型是jar -->\n		<type>jar</type>\n		<!-- 依赖范围，可不写 -->\n		<scope>compile</scope>\n	</dependency>\n	<!-- 依赖配置，取用配置的版本 -->\n	<dependency>\n		<groupId>org.springframework</groupId>\n		<artifactId>spring-beans</artifactId>\n		<!-- 取用上方提供的spring版本 -->\n		<version>${spring.version}</version>\n	</dependency>\n	<!-- 依赖传递配置 -->\n	<dependency>\n		<groupId>org.springframework</groupId>\n		<artifactId>spring-core</artifactId>\n		<version>${spring.version}</version>\n		<!-- 依赖传递，用于解决版本冲突 -->\n		<exclusions>\n			<exclusion>\n				<groupId>commons-logging</groupId>\n				<artifactId>commons-logging</artifactId>\n			</exclusion>\n		</exclusions>\n	</dependency>\n	<dependency>\n		<groupId>commons-logging</groupId>\n		<artifactId>commons-logging</artifactId>\n		<version>1.2</version>\n	</dependency>\n	<!-- 外在依赖与取用 -->\n	<dependency>\n		<groupId>com.mebugsapi</groupId>\n		<artifactId>mebugsApi</artifactId>\n		<version>1.0</version>\n		<scope>system</scope>\n		<!-- 比如用于自身提供的业务jar包 -->\n		<systemPath>${project.basedir}/src/main/webapp/WEB-INF/lib/mebugsApi.jar</systemPath>\n	</dependency>\n</dependencies>\n<!-- 构建项目所需要的信息 -->\n<build>\n	<!-- 产生的构件的文件名，默认值是${artifactId}-${version} -->\n	<finalName>mebugsWeb</finalName>\n	<!-- 子项目可以引用的默认插件信息 -->\n	<pluginManagement>\n		<plugins> \n			<!-- 添加插件，编译插件 -->\n			<plugin>\n				<groupId>org.apache.maven.plugins</groupId>\n				<artifactId>maven-compiler-plugin</artifactId>\n				<version>3.0</version>\n				<configuration>\n					<source>${jdk.version}</source>\n					<target>${jdk.version}</target>\n					<showWarnings>false</showWarnings>\n				</configuration>\n			</plugin>\n		</plugins>\n	</pluginManagement>\n	<!-- 描述项目相关的所有资源路径列表，例如：属性文件，这些资源被包含在最终的打包文件里。--> \n	<resources>\n		<resource>\n			<directory>src/main/java</directory> \n			<!-- 包含 -->\n			<includes>\n				<include>**/*.xml</include>\n			</includes>\n		</resource>\n		<resource>\n			<directory>src/main/resources/</directory>\n			<includes>\n				<include>**</include> \n			</includes>\n		</resource>\n	</resources>\n</build>\n</project>\n```\n# 补充说明\n\n其他想要依赖的包，对应的dependency，在这个网站找。\n\n[http://mvnrepository.com/](http://mvnrepository.com/)\n\n可以再网站中一键生成dependency节点配置项。\n\n如下图中所示：\n\n![/static/upload/post/1646007151214.jpg](/static/upload/post/1646007151214.jpg)\n', '<h1 id=\"menu_1\">maven简介</h1><p>maven是一个用于项目管理的综合工具。</p>\n<ol>\n<li>提供了开发人员构建一个完整的生命周期框架。</li>\n<li>可以自动完成项目的基础工具建设。</li>\n<li>应对多个开发团队环境时，可以设置按标准在非常短的时间里完成配置工作。</li>\n<li>让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。</li>\n<li>最强大的功能就是能够自动下载项目依赖库，这也是最实用的地方。</li>\n<li>是专门用于构建和管理Java相关项目的管理工具。</li>\n</ol>\n<p>maven是意第绪语，依地语（犹太人使用的国际语），表示专家的意思。</p>\n<p>用maven管理Java 项目，你就是专家了，哈哈哈！</p>\n<h1 id=\"menu_2\">pom.xml</h1><p>POM代表项目对象模型，是maven中工作的基本单位，是一个xml文件，始终保存在项目根目录中的pom.xml文件。</p>\n<p>建立一个maven项目，maven会检查你的pom.xml文件，以确定哪些依赖下载。</p>\n<p>首先，maven将从本地资源库获得maven的本地资源库依赖资源。</p>\n<p>如果没有找到，会从默认的maven中央存储库查找下载。</p>\n<p>因此，pom.xml是配置项目依赖关系的重要文件。</p>\n<h2 id=\"menu_3\">实例解析</h2><p>取用一个单项目pom.xml并对其解释，便于理解其配置和运作方式。</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span>\n    <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>\n    <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">&quot;http://maven.apache.org/POM/4.0.0\n    http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 指定当前POM模型的版本，对于maven2,maven3只能是4.0.0 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 项目编号，独一无二的。可以理解为父级package --&gt;</span> \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.mebugs<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 项目名称，与项目编号组成唯一的项目标识 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>mebugsWeb<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 项目的版本 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 项目产生的构件类型，例如jar、war，插件可以创建他们自己的构件类型 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">packaging</span>&gt;</span>war<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">packaging</span>&gt;</span> \n<span class=\"hljs-comment\">&lt;!-- 项目名称，用来声明一个对用户而言比较友好的项目名称，文档使用 --&gt;</span> \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">name</span>&gt;</span>Mebugs Maven Webapp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">name</span>&gt;</span> \n<span class=\"hljs-comment\">&lt;!-- 项目主页的URL，maven产生的文档用。非必须 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">url</span>&gt;</span>http://maven.apache.org<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">url</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 项目的详细描述,文档用。非必须 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">description</span>&gt;</span>A maven project for mebugs<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">description</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 常用的版本号统一设置 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 定义spring的版本 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">spring.version</span>&gt;</span>4.3.10.RELEASE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">spring.version</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 定义jackson的版本 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">jackson.version</span>&gt;</span>2.9.3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">jackson.version</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 项目编码方式 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- jdk版本 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">jdk.version</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">jdk.version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span> \n<span class=\"hljs-comment\">&lt;!-- 依赖列表 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 基础的依赖配置，版本号自行填写 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>log4j<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>log4j<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.2.17<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- 依赖类型，可不写，默认类型是jar --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">type</span>&gt;</span>jar<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">type</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- 依赖范围，可不写 --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>compile<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 依赖配置，取用配置的版本 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-beans<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- 取用上方提供的spring版本 --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${spring.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 依赖传递配置 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-core<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${spring.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- 依赖传递，用于解决版本冲突 --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">exclusions</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">exclusion</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>commons-logging<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>commons-logging<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">exclusion</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">exclusions</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>commons-logging<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>commons-logging<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 外在依赖与取用 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.mebugsapi<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>mebugsApi<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>system<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- 比如用于自身提供的业务jar包 --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">systemPath</span>&gt;</span>${project.basedir}/src/main/webapp/WEB-INF/lib/mebugsApi.jar<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">systemPath</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 构建项目所需要的信息 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 产生的构件的文件名，默认值是${artifactId}-${version} --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">finalName</span>&gt;</span>mebugsWeb<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">finalName</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 子项目可以引用的默认插件信息 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pluginManagement</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span> \n            <span class=\"hljs-comment\">&lt;!-- 添加插件，编译插件 --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">source</span>&gt;</span>${jdk.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">source</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">target</span>&gt;</span>${jdk.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">target</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">showWarnings</span>&gt;</span>false<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">showWarnings</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pluginManagement</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 描述项目相关的所有资源路径列表，例如：属性文件，这些资源被包含在最终的打包文件里。--&gt;</span> \n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">resources</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">resource</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">directory</span>&gt;</span>src/main/java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">directory</span>&gt;</span> \n            <span class=\"hljs-comment\">&lt;!-- 包含 --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">includes</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">include</span>&gt;</span>**/*.xml<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">include</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">includes</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">resource</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">resource</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">directory</span>&gt;</span>src/main/resources/<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">directory</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">includes</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">include</span>&gt;</span>**<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">include</span>&gt;</span> \n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">includes</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">resource</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">resources</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></pre>\n<h1 id=\"menu_4\">补充说明</h1><p>其他想要依赖的包，对应的dependency，在这个网站找。</p>\n<p><a class=\"mlink\" href=\"http://mvnrepository.com/\" title=\"http://mvnrepository.com/\" target=\"_blank\">http://mvnrepository.com/</a></p>\n<p>可以再网站中一键生成dependency节点配置项。</p>\n<p>如下图中所示：</p>\n<p><img src=\"/static/upload/post/1646007151214.jpg\" alt=\"/static/upload/post/1646007151214.jpg\"/></p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">maven简介</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">pom.xml</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">实例解析</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">补充说明</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1030, '# 原生校验器\n\n我们都知道Struts2校验框架原生（自带）有不少校验规则 。\n\n有时候我们会频繁使用到某些后台参数校验逻辑，如果始终使用正则表达式，在书写校验文件的时候比较冗长。\n\n这时候我们可以针对自身需求定制一个专门的校验器。\n\n## 常见原生校验\n\n - required:必填校验器\n - requiredstring:必填字符串校验器\n - int:整数校验器\n - double:双精度浮点数校验器\n - date:日期校验器\n - email:电子邮件校验器\n - url:网址校验器\n - stringlength:字符串长度校验器\n - regex:正则表达式校验器\n \n # 校验配置文件\n \n 校验配置文件放在Action目录下，命名：Action名-方法名-validation.xml\n\n 例如：RunningManAction-createRuningMan-validation.xml\n \n ```xml\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <!DOCTYPE validators PUBLIC \"-//Apache Struts//XWork Validator 1.0.3//EN\" \n	\"http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd\">\n	<validators>\n		<!-- 本样例主要说明各类元素标签，实际应用可能仅使用部分标签 -->\n		<!-- 校验参数名 -->\n		<field name=\"runningMan.userName\">\n		<!-- 指定校验器，此处指定了自定义的校验器customer -->\n		<field-validator type=\"customer\">\n			<!-- 入参，主要分两类，值/正则 -->\n			<!-- 入参需要合法不要出现收参转换失败的情况，如给整型传字母 -->\n			<param name=\"exclusionChar\">#\'&,;\"|</param>\n			<!-- 正则入参需要注意语法，比如限制输入数字字母 -->\n			<param name=\"regex\"><![CDATA[^[A-Za-z0-9]$]]> </param>\n			<message>userName invalid format.</message>\n		</field-validator>\n		<field-validator type=\"required\">\n			<!-- 略...多个校验器 --> \n		</field-validator>\n	</field>\n</validators>\n```\n\n# 自定义校验器\n\n上文中我们使用到了一个自定义的校验器customer。\n\n这个校验器并不存在，需要定义这样一个校验器。\n\n**validators.xml**一般放在工程根目录下WBE-INFO/class。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE validators PUBLIC \"-//Apache Struts//XWork Validator Definition 1.0//EN\"\n	\"http://struts.apache.org/dtds/xwork-validator-definition-1.0.dtd\">\n	<validators>\n		<!-- 指定自定义的校验类，如检查特殊符号校验类 -->\n		<validator name=\"customer\" class=\"com.mebugs.validation.CheckSpecialSymbol\"/>\n	</validators>\n```\n\n## 代码实例\n\nCheckSpecialSymbol自定义校验器类代码实例。\n\n```java \npackage com.mebugs.validation;\nimport com.opensymphony.xwork2.validator.ValidationException;\nimport com.opensymphony.xwork2.validator.validators.FieldValidatorSupport;\npublic class CheckSpecialSymbol extends FieldValidatorSupport {\n	//校验文件中的入参，限制哪些字符不可出现\n	private String exclusionChar;\n	@Override \n	public void validate(Object object) throws ValidationException {\n		//校验参数名\n		String fieldName = getFieldName();\n		//参数名对应的参数值\n		Object value = getFieldValue(fieldName, object);\n		if ( value != null ) {\n			if (!(value instanceof String)) {\n				//不是字符串报错\n				addFieldError(fieldName, object);\n			} else {\n				String s = (String)value;\n				for (int i = 0;i < s.length(); i++) { \n					//存在了此字符串，报错\n					if (exclusionChar.indexOf(s.charAt(i)) != -1) {\n						addFieldError(fieldName, object);\n					} \n				}\n			}\n		}\n	}\n	public String getExclusionChar() {\n		return exclusionChar;\n	}\n	public void setExclusionChar(String exclusionChar) {\n		this.exclusionChar = exclusionChar;\n	}\n}\n```\n\n完成以上逻辑，可以使自定义的校验器生效。', '<h1 id=\"menu_1\">原生校验器</h1><p>我们都知道Struts2校验框架原生（自带）有不少校验规则 。</p>\n<p>有时候我们会频繁使用到某些后台参数校验逻辑，如果始终使用正则表达式，在书写校验文件的时候比较冗长。</p>\n<p>这时候我们可以针对自身需求定制一个专门的校验器。</p>\n<h2 id=\"menu_2\">常见原生校验</h2><ul>\n<li>required:必填校验器</li>\n<li>requiredstring:必填字符串校验器</li>\n<li>int:整数校验器</li>\n<li>double:双精度浮点数校验器</li>\n<li>date:日期校验器</li>\n<li>email:电子邮件校验器</li>\n<li>url:网址校验器</li>\n<li>stringlength:字符串长度校验器</li>\n<li>regex:正则表达式校验器</li>\n</ul>\n<h1 id=\"menu_3\">校验配置文件</h1><p> 校验配置文件放在Action目录下，命名：Action名-方法名-validation.xml</p>\n<p> 例如：RunningManAction-createRuningMan-validation.xml</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">validators</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//Apache Struts//XWork Validator 1.0.3//EN&quot;</span> \n   <span class=\"hljs-string\">&quot;http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd&quot;</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">validators</span>&gt;</span>\n       <span class=\"hljs-comment\">&lt;!-- 本样例主要说明各类元素标签，实际应用可能仅使用部分标签 --&gt;</span>\n       <span class=\"hljs-comment\">&lt;!-- 校验参数名 --&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">field</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;runningMan.userName&quot;</span>&gt;</span>\n       <span class=\"hljs-comment\">&lt;!-- 指定校验器，此处指定了自定义的校验器customer --&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">field-validator</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;customer&quot;</span>&gt;</span>\n           <span class=\"hljs-comment\">&lt;!-- 入参，主要分两类，值/正则 --&gt;</span>\n           <span class=\"hljs-comment\">&lt;!-- 入参需要合法不要出现收参转换失败的情况，如给整型传字母 --&gt;</span>\n           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;exclusionChar&quot;</span>&gt;</span>#&#x27;&amp;,;&quot;|<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param</span>&gt;</span>\n           <span class=\"hljs-comment\">&lt;!-- 正则入参需要注意语法，比如限制输入数字字母 --&gt;</span>\n           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;regex&quot;</span>&gt;</span>&lt;![CDATA[^[A-Za-z0-9]$]]&gt; <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param</span>&gt;</span>\n           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">message</span>&gt;</span>userName invalid format.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">message</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">field-validator</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">field-validator</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;required&quot;</span>&gt;</span>\n           <span class=\"hljs-comment\">&lt;!-- 略...多个校验器 --&gt;</span> \n       <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">field-validator</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">field</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">validators</span>&gt;</span>\n</code></pre>\n<h1 id=\"menu_4\">自定义校验器</h1><p>上文中我们使用到了一个自定义的校验器customer。</p>\n<p>这个校验器并不存在，需要定义这样一个校验器。</p>\n<p><strong>validators.xml</strong>一般放在工程根目录下WBE-INFO/class。</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">validators</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//Apache Struts//XWork Validator Definition 1.0//EN&quot;</span>\n    <span class=\"hljs-string\">&quot;http://struts.apache.org/dtds/xwork-validator-definition-1.0.dtd&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">validators</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- 指定自定义的校验类，如检查特殊符号校验类 --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">validator</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;customer&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;com.mebugs.validation.CheckSpecialSymbol&quot;</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">validators</span>&gt;</span>\n</code></pre>\n<h2 id=\"menu_5\">代码实例</h2><p>CheckSpecialSymbol自定义校验器类代码实例。</p>\n<pre><code class=\"hljs language-java\">package com.<span class=\"hljs-property\">mebugs</span>.<span class=\"hljs-property\">validation</span>;\n<span class=\"hljs-keyword\">import</span> com.<span class=\"hljs-property\">opensymphony</span>.<span class=\"hljs-property\">xwork2</span>.<span class=\"hljs-property\">validator</span>.<span class=\"hljs-property\">ValidationException</span>;\n<span class=\"hljs-keyword\">import</span> com.<span class=\"hljs-property\">opensymphony</span>.<span class=\"hljs-property\">xwork2</span>.<span class=\"hljs-property\">validator</span>.<span class=\"hljs-property\">validators</span>.<span class=\"hljs-property\">FieldValidatorSupport</span>;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CheckSpecialSymbol</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">FieldValidatorSupport</span> {\n    <span class=\"hljs-comment\">//校验文件中的入参，限制哪些字符不可出现</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">String</span> exclusionChar;\n    <span class=\"hljs-meta\">@Override</span> \n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">validate</span>(<span class=\"hljs-title class_\">Object</span> <span class=\"hljs-built_in\">object</span>) throws <span class=\"hljs-title class_\">ValidationException</span> {\n        <span class=\"hljs-comment\">//校验参数名</span>\n        <span class=\"hljs-title class_\">String</span> fieldName = <span class=\"hljs-title function_\">getFieldName</span>();\n        <span class=\"hljs-comment\">//参数名对应的参数值</span>\n        <span class=\"hljs-title class_\">Object</span> value = <span class=\"hljs-title function_\">getFieldValue</span>(fieldName, <span class=\"hljs-built_in\">object</span>);\n        <span class=\"hljs-keyword\">if</span> ( value != <span class=\"hljs-literal\">null</span> ) {\n            <span class=\"hljs-keyword\">if</span> (!(value <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">String</span>)) {\n                <span class=\"hljs-comment\">//不是字符串报错</span>\n                <span class=\"hljs-title function_\">addFieldError</span>(fieldName, <span class=\"hljs-built_in\">object</span>);\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-title class_\">String</span> s = (<span class=\"hljs-title class_\">String</span>)value;\n                <span class=\"hljs-keyword\">for</span> (int i = <span class=\"hljs-number\">0</span>;i &lt; s.<span class=\"hljs-title function_\">length</span>(); i++) { \n                    <span class=\"hljs-comment\">//存在了此字符串，报错</span>\n                    <span class=\"hljs-keyword\">if</span> (exclusionChar.<span class=\"hljs-title function_\">indexOf</span>(s.<span class=\"hljs-title function_\">charAt</span>(i)) != -<span class=\"hljs-number\">1</span>) {\n                        <span class=\"hljs-title function_\">addFieldError</span>(fieldName, <span class=\"hljs-built_in\">object</span>);\n                    } \n                }\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">String</span> <span class=\"hljs-title function_\">getExclusionChar</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">return</span> exclusionChar;\n    }\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">setExclusionChar</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span> exclusionChar</span>) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">exclusionChar</span> = exclusionChar;\n    }\n}\n</code></pre>\n<p>完成以上逻辑，可以使自定义的校验器生效。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">原生校验器</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">常见原生校验</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">校验配置文件</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">自定义校验器</a> <ul><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">代码实例</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1031, '# MVC框架\n\nMVC全名是Model View Controller，表示采用了MVC涉及模式的框架。 \n  \n是模型(model)－视图(view)－控制器(controller)的缩写。    \n\n使用业务逻辑、数据、界面显示分离的方法组织代码，业务逻辑聚集到一个部件里面。\n\n当改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。\n\n# 整合配置\n\n位于WEB应用的web.xml中配置Struts2核心Filter。\n\nStruts2框架与SpringMVC最大的区别在于转发通过过滤器，SpringMVC使用Servlet。\n\n```xml\n<filter>\n	<!-- 配置Struts2核心Filter的名字 -->\n	<filter-name>struts2</filter-name>\n	<!-- 注意：一定是org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter -->\n	<!-- 不是org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter -->\n	<!-- 也不是org.apache.struts2.dispatcher.Filterdispatcher -->\n	<!-- struts的版本不同，导致jar包目录的改变，写错了，会报找不到类的错误 -->\n	<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>\n	<init-param>\n		<!-- 多个Strust配置文件用,号隔开 -->\n		<param-name>config</param-name>\n		<param-value>struts-default.xml,conf/mebugs.struts.xml</param-value>\n	</init-param>\n	<init-param>\n		<!-- 扩展struts2的ConfigurationProvider接口，在web.xml中配置自定义的加载类 -->\n		<!-- 自定义扫描所有的Strust配置文件，实际应用中可以不配置 -->\n		<param-name>configProviders</param-name>\n		<param-value>com.mebugs.MyConfigProviders</param-value> \n	</init-param>\n</filter> \n<filter-mapping>\n	<filter-name>struts2</filter-name>\n	<url-pattern>*.action</url-pattern>\n</filter-mapping>\n```\n\n# 自定义配置文件\n\n如上文中我们使用的mebugs.struts.xml实例，以及几类比较常见的配置内容。\n\n```xml\n<!DOCTYPE struts PUBLIC \n	\"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\" \n	\"http://struts.apache.org/dtds/struts-2.0.dtd\">\n	<struts>\n		<!-- struts.devMode也就是struts的开发模式，默认值为false，改为true就是以后一旦就改这个文件中的配置就不用去重启tomcat -->\n		<constant name=\"struts.devMode\" value=\"false\" />\n		<package name=\"mebugsServices\" extends=\"struts-default\" namespace=\"/\">\n		<!-- Action -->\n		<!-- 一般情况下，**这个类也要配置在Spring的bean配置文件**，用于类对象的维护 -->\n		<!-- **此处便是与Spring框架融合的地方，我们的bean依旧统一交给Spring的IOC容器来管理** -->\n		<!-- action name便是前端请求的地址 method则绑定对应的方法入口 -->\n		<action name=\"createUser\" class=\"com.mebugs.user.action.UserAction\" method=\"createUser\">\n			<!-- 以下内容均为选用 -->\n			<!-- 绑定一个拦截器/组 -->\n			<interceptor-ref name=\"security\" />\n			<!-- 绑定一个需要传参的拦截器/组 -->\n			<interceptor-ref name=\"runMode\">\n				<param name=\"target\">https</param>\n			</interceptor-ref>\n			<!-- 特定的返回字符串标识 -->\n			<result name=\"success\">/jsp/some.jsp</result>\n			<!-- 特定的返回字符串标识，且指定为重定向 -->\n			<result name=\"main\" type=\"redirect\">main.action</result>\n		</action>\n	</package>\n</struts>\n```\n\n# Action类结构\n\n以上文配置的UserAction为例\n\n```java\npublic class UserAction extends BASCAction    {\n	/*\n	 * 序列号\n	 */\n	private static final long serialVersionUID = 373832410111011420L;\n	/*\n	 * 日志\n	*/\n   private static final DebugLog LOGGER = LogFactory.getDebugLog(UserAction.class);\n   /*\n	* 实体类，与视图交互的对象\n	*/\n   private User user;\n   /*\n	* Service层类注入\n	*/\n	private UserServ userServ;\n	/*\n	 * 通过Bean配置中<property name=\"user\" ref=\"user\"></property> 进行关联\n	 * Bean管理依旧交给Spring\n	 */\n	public User getUser() {\n		return user;\n	}\n	public void setUser(User user) {\n		this.user = user;\n	}\n	public UserServ getUserServ() {\n		return userServ;\n	}\n	public void setUserServ(UserServ userServ) {\n		this.userServ = userServ;\n	}\n	/*\n	 * action中配置指定的方法\n	 */\n	public void createUser() {\n		// step1: 调用业务处理类 获取返回体\n		// 这个返回体结构是我们自定义的通用返回体，便于Jackson解析\n		// 其结构一个返回码一个返回描述\n		ReturnDes returnDes = userServ.createUser(user);\n		// step2: 打印接口返回消息\n		List<Object> rtn = new ArrayList<Object>();\n		rtn.add(returnDes);\n		// step3: 构造返回体，建议剥离为一个公共方法\n		// 此处引用了Jacson开源Jar工具包\n		response.setCharacterEncoding(\"UTF-8\");\n		response.setContentType(\"text/html\");\n		PrintWriter out = null;\n		try {\n			ObjectMapper mapper = new ObjectMapper();\n			String json = mapper.writeValueAsString(rtn);\n			out = response.getWriter();\n			out.print(json);\n		} catch(JsonProcessingException e) {\n			LOGGER.error(e.toString(), e);\n		} catch (IOException e) {\n			LOGGER.error(e.toString(), e);\n		} finally {\n			if (null != out) {\n				out.close();\n			}\n		}\n	} \n}\n```\n\n# 小结\n\n在JAVA语言中新的WEB项目中，Struts2框架的身影也越来越少见。\n\n由于Struts2框架是一个存粹的控制层框架，Bean还需要交给Spring框架维护，增加很多的配置项。\n\n因此现在比较多见的依旧是Spring+SpringMVC的组合。\n\n尤其是注解方式配置面市后，使用其他控制层框架与Spring框架融合开发效率始终弱于Spring+SpringMVC。\n\n亲儿子毕竟是亲儿子~哈哈哈~', '<h1 id=\"menu_1\">MVC框架</h1><p>MVC全名是Model View Controller，表示采用了MVC涉及模式的框架。 </p>\n<p>是模型(model)－视图(view)－控制器(controller)的缩写。    </p>\n<p>使用业务逻辑、数据、界面显示分离的方法组织代码，业务逻辑聚集到一个部件里面。</p>\n<p>当改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p>\n<h1 id=\"menu_2\">整合配置</h1><p>位于WEB应用的web.xml中配置Struts2核心Filter。</p>\n<p>Struts2框架与SpringMVC最大的区别在于转发通过过滤器，SpringMVC使用Servlet。</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filter</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 配置Struts2核心Filter的名字 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filter-name</span>&gt;</span>struts2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filter-name</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 注意：一定是org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter --&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 不是org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter --&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 也不是org.apache.struts2.dispatcher.Filterdispatcher --&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- struts的版本不同，导致jar包目录的改变，写错了，会报找不到类的错误 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filter-class</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">init-param</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- 多个Strust配置文件用,号隔开 --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-name</span>&gt;</span>config<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-name</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-value</span>&gt;</span>struts-default.xml,conf/mebugs.struts.xml<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-value</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">init-param</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">init-param</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- 扩展struts2的ConfigurationProvider接口，在web.xml中配置自定义的加载类 --&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- 自定义扫描所有的Strust配置文件，实际应用中可以不配置 --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-name</span>&gt;</span>configProviders<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-name</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-value</span>&gt;</span>com.mebugs.MyConfigProviders<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-value</span>&gt;</span> \n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">init-param</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filter</span>&gt;</span> \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filter-mapping</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filter-name</span>&gt;</span>struts2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filter-name</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">url-pattern</span>&gt;</span>*.action<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">url-pattern</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filter-mapping</span>&gt;</span>\n</code></pre>\n<h1 id=\"menu_3\">自定义配置文件</h1><p>如上文中我们使用的mebugs.struts.xml实例，以及几类比较常见的配置内容。</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">struts</span> <span class=\"hljs-keyword\">PUBLIC</span> \n    <span class=\"hljs-string\">&quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;</span> \n    <span class=\"hljs-string\">&quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">struts</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- struts.devMode也就是struts的开发模式，默认值为false，改为true就是以后一旦就改这个文件中的配置就不用去重启tomcat --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">constant</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;struts.devMode&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;false&quot;</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">package</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;mebugsServices&quot;</span> <span class=\"hljs-attr\">extends</span>=<span class=\"hljs-string\">&quot;struts-default&quot;</span> <span class=\"hljs-attr\">namespace</span>=<span class=\"hljs-string\">&quot;/&quot;</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- Action --&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- 一般情况下，**这个类也要配置在Spring的bean配置文件**，用于类对象的维护 --&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- **此处便是与Spring框架融合的地方，我们的bean依旧统一交给Spring的IOC容器来管理** --&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- action name便是前端请求的地址 method则绑定对应的方法入口 --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">action</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;createUser&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;com.mebugs.user.action.UserAction&quot;</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">&quot;createUser&quot;</span>&gt;</span>\n            <span class=\"hljs-comment\">&lt;!-- 以下内容均为选用 --&gt;</span>\n            <span class=\"hljs-comment\">&lt;!-- 绑定一个拦截器/组 --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">interceptor-ref</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;security&quot;</span> /&gt;</span>\n            <span class=\"hljs-comment\">&lt;!-- 绑定一个需要传参的拦截器/组 --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">interceptor-ref</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;runMode&quot;</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;target&quot;</span>&gt;</span>https<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">interceptor-ref</span>&gt;</span>\n            <span class=\"hljs-comment\">&lt;!-- 特定的返回字符串标识 --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">result</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;success&quot;</span>&gt;</span>/jsp/some.jsp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">result</span>&gt;</span>\n            <span class=\"hljs-comment\">&lt;!-- 特定的返回字符串标识，且指定为重定向 --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">result</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;main&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;redirect&quot;</span>&gt;</span>main.action<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">result</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">action</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">package</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">struts</span>&gt;</span>\n</code></pre>\n<h1 id=\"menu_4\">Action类结构</h1><p>以上文配置的UserAction为例</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserAction</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BASCAction</span>    {\n    <span class=\"hljs-comment\">/*\n     * 序列号\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">serialVersionUID</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">373832410111011420L</span>;\n    <span class=\"hljs-comment\">/*\n     * 日志\n    */</span>\n   <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">DebugLog</span> <span class=\"hljs-variable\">LOGGER</span> <span class=\"hljs-operator\">=</span> LogFactory.getDebugLog(UserAction.class);\n   <span class=\"hljs-comment\">/*\n    * 实体类，与视图交互的对象\n    */</span>\n   <span class=\"hljs-keyword\">private</span> User user;\n   <span class=\"hljs-comment\">/*\n    * Service层类注入\n    */</span>\n    <span class=\"hljs-keyword\">private</span> UserServ userServ;\n    <span class=\"hljs-comment\">/*\n     * 通过Bean配置中&lt;property name=&quot;user&quot; ref=&quot;user&quot;&gt;&lt;/property&gt; 进行关联\n     * Bean管理依旧交给Spring\n     */</span>\n    <span class=\"hljs-keyword\">public</span> User <span class=\"hljs-title function_\">getUser</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> user;\n    }\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setUser</span><span class=\"hljs-params\">(User user)</span> {\n        <span class=\"hljs-built_in\">this</span>.user = user;\n    }\n    <span class=\"hljs-keyword\">public</span> UserServ <span class=\"hljs-title function_\">getUserServ</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> userServ;\n    }\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setUserServ</span><span class=\"hljs-params\">(UserServ userServ)</span> {\n        <span class=\"hljs-built_in\">this</span>.userServ = userServ;\n    }\n    <span class=\"hljs-comment\">/*\n     * action中配置指定的方法\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">createUser</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-comment\">// step1: 调用业务处理类 获取返回体</span>\n        <span class=\"hljs-comment\">// 这个返回体结构是我们自定义的通用返回体，便于Jackson解析</span>\n        <span class=\"hljs-comment\">// 其结构一个返回码一个返回描述</span>\n        <span class=\"hljs-type\">ReturnDes</span> <span class=\"hljs-variable\">returnDes</span> <span class=\"hljs-operator\">=</span> userServ.createUser(user);\n        <span class=\"hljs-comment\">// step2: 打印接口返回消息</span>\n        List&lt;Object&gt; rtn = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;Object&gt;();\n        rtn.add(returnDes);\n        <span class=\"hljs-comment\">// step3: 构造返回体，建议剥离为一个公共方法</span>\n        <span class=\"hljs-comment\">// 此处引用了Jacson开源Jar工具包</span>\n        response.setCharacterEncoding(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>);\n        response.setContentType(<span class=\"hljs-string\">&quot;text/html&quot;</span>);\n        <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-type\">ObjectMapper</span> <span class=\"hljs-variable\">mapper</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectMapper</span>();\n            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">json</span> <span class=\"hljs-operator\">=</span> mapper.writeValueAsString(rtn);\n            out = response.getWriter();\n            out.print(json);\n        } <span class=\"hljs-keyword\">catch</span>(JsonProcessingException e) {\n            LOGGER.error(e.toString(), e);\n        } <span class=\"hljs-keyword\">catch</span> (IOException e) {\n            LOGGER.error(e.toString(), e);\n        } <span class=\"hljs-keyword\">finally</span> {\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">null</span> != out) {\n                out.close();\n            }\n        }\n    } \n}\n</code></pre>\n<h1 id=\"menu_5\">小结</h1><p>在JAVA语言中新的WEB项目中，Struts2框架的身影也越来越少见。</p>\n<p>由于Struts2框架是一个存粹的控制层框架，Bean还需要交给Spring框架维护，增加很多的配置项。</p>\n<p>因此现在比较多见的依旧是Spring+SpringMVC的组合。</p>\n<p>尤其是注解方式配置面市后，使用其他控制层框架与Spring框架融合开发效率始终弱于Spring+SpringMVC。</p>\n<p>亲儿子毕竟是亲儿子<del>哈哈哈</del></p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">MVC框架</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">整合配置</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">自定义配置文件</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">Action类结构</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">小结</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1032, '# 关于预加载动画\n\n网站首页增加一个预加载动画，让用户首次访问网站的时候不会因为等待资源准备时间过长而感到枯燥。\n\nCSS3的动画效果利用的是keyframes帧动画能力，可以理解为纯代码实现了界面的动画效果。\n\n以前很多人会使用一个动态的图片作为预加载动画，效果很酷。\n\n不过gif的图片相对而言会比较大一点，如果想展现更加优秀的动画效果，就需要精细的图片+更多的帧。\n\n制作一个动态的gif本身并不困难，不太好的地方在于不能够随意更换以及自定义色彩。\n\n因此，使用Jquery+CSS3+HTML一个新的方案来替代图片是一个比较好的解决方案。\n\n# 引入Jquery \n\n99%的网站一般都会引入Jquery库，通过Chrome内核的浏览器，右击查看网站源代码。\n\nCtrl+F调出搜索框，输入Jquery，检查您的网站是否引入了Jquery库。\n\n如果没有，您需要考虑使用原生JS代码实现class的移除等。\n\n这里为了让案例简洁，直接使用Jquery库来实现。（利用原生JS也可以实现）\n\n# 实现思路\n\n1. 打开页面在默认显示加载的动画元素（因此动画元素应当浮在所有内容的上方并盖住其他内容）\n2. JS判断页面DOM是否Load完成（$(window).load 和 $(document).ready 都可以使用，虽然有差别，整体感知不明显）\n3. Load完成后对动画元素隐藏即可\n\n## 定义preloading.css\n\n由于CSS中的特效定义比较多，解释起来比较麻烦。\n\n感兴趣可以学习一些CSS3的线性动画特性。\n\n```css\n.loader{\n	position:fixed;\n	left:50%;\n	top:50%;\n	margin:-0.2em 0 0 -0.2em;\n	text-indent:-9999em;\n	border-top:.3em solid rgba(0,0,0,0.1);\n	border-right:.3em solid rgba(0,0,0,0.1);\n	border-bottom:.3em solid rgba(0,0,0,0.1);\n	border-left:.3em solid #9cc;\n	/* 篇幅原因省略了一些兼容性CSS配置 */\n	transform:translateZ(0);\n	/* 关键CSS：关联对应的动画配置loader ，篇幅原因省略了一些兼容性CSS配置 */\n	animation:loader .5s infinite linear;\n	z-index:999;\n}\n.loader,.loader:after{\n	border-radius:50%;width:2em;height:2em\n}\n.curtain{\n	position:fixed;\n	width:100%;\n	height:100%;\n	top:0;\n	left:0;\n	background-color:white;\n	filter:alpha(opacity=0);\n	opacity:0;\n	z-index:0\n}\n.sending .curtain{\n	top:0px;\n}\n/* 动画配置loader，篇幅原因省略了一些兼容性CSS配置 */\n@keyframes loader{\n	0%{\n		-webkit-transform:rotate(0deg);\n		transform:rotate(0deg);\n	}\n	100%{\n		-webkit-transform:rotate(360deg);\n		transform:rotate(360deg);\n	}\n}\n.is-loading .loader,.is-loading .curtain\n{\n	filter:progid:DXImageTransform.Microsoft.Alpha(enabled=false);\n	opacity:1\n}\n.is-loading .curtain{\n	z-index:999\n}\n/* 自定义滚动条样式，可有可无 */\n::-webkit-scrollbar\n{\n	width:12px;\n	height:12px;\n}\n::-webkit-scrollbar-thumb\n{\n	border-radius:2px;\n	background-color:#99cccc;\n	background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.2) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.2) 50%,rgba(255,255,255,.2) 75%,transparent 75%,transparent);\n}\n::-webkit-scrollbar-track\n{\n	-webkit-box-shadow:inset 0 0 6px #ddd;\n	background-color:#fbfbfb;\n	border-radius:2px;\n}\n```\n## 引入CSS文件\n\n放在head便签区域内的最下方（尽量优先加载）。\n\n```html\n<head>\n	<link rel=\"stylesheet\" type=\"text/css\" href=\"css/preloading.css\">\n</head>\n```\n\n## 定义元素并应用\n\n放在body区域最上方，主要便于浮动时可以盖住其他元素。\n\n```html\n<body>\n	<div class=\"is-loading\" id=\"load\"> \n		<div class=\"curtain\">\n			<div class=\"loader\">\n			</div>\n		</div>\n	</div>\n\n<script type=\"text/javascript\">\n//确保Jquey已加载后执行进入 \n(function($){\n	//$(window).load 和 $(document).ready 都可以使用，虽然有差别，整体感知不明显\n	$(window).on(\"load\", function() { \n		window.setTimeout(function() {\n			//隐藏或者移除Class均可以使用\n			//推荐用CSS特性实现 \n			//$(\"#load\").removeClass(\"is-loading\");\n			$(\"#load\").hide(500);\n		}, 100);\n	});\n})(jQuery);\n</script>\n</body>\n```', '<h1 id=\"menu_1\">关于预加载动画</h1><p>网站首页增加一个预加载动画，让用户首次访问网站的时候不会因为等待资源准备时间过长而感到枯燥。</p>\n<p>CSS3的动画效果利用的是keyframes帧动画能力，可以理解为纯代码实现了界面的动画效果。</p>\n<p>以前很多人会使用一个动态的图片作为预加载动画，效果很酷。</p>\n<p>不过gif的图片相对而言会比较大一点，如果想展现更加优秀的动画效果，就需要精细的图片+更多的帧。</p>\n<p>制作一个动态的gif本身并不困难，不太好的地方在于不能够随意更换以及自定义色彩。</p>\n<p>因此，使用Jquery+CSS3+HTML一个新的方案来替代图片是一个比较好的解决方案。</p>\n<h1 id=\"menu_2\">引入Jquery</h1><p>99%的网站一般都会引入Jquery库，通过Chrome内核的浏览器，右击查看网站源代码。</p>\n<p>Ctrl+F调出搜索框，输入Jquery，检查您的网站是否引入了Jquery库。</p>\n<p>如果没有，您需要考虑使用原生JS代码实现class的移除等。</p>\n<p>这里为了让案例简洁，直接使用Jquery库来实现。（利用原生JS也可以实现）</p>\n<h1 id=\"menu_3\">实现思路</h1><ol>\n<li>打开页面在默认显示加载的动画元素（因此动画元素应当浮在所有内容的上方并盖住其他内容）</li>\n<li>JS判断页面DOM是否Load完成（$(window).load 和 $(document).ready 都可以使用，虽然有差别，整体感知不明显）</li>\n<li>Load完成后对动画元素隐藏即可</li>\n</ol>\n<h2 id=\"menu_4\">定义preloading.css</h2><p>由于CSS中的特效定义比较多，解释起来比较麻烦。</p>\n<p>感兴趣可以学习一些CSS3的线性动画特性。</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.loader</span>{\n    <span class=\"hljs-attribute\">position</span>:fixed;\n    <span class=\"hljs-attribute\">left</span>:<span class=\"hljs-number\">50%</span>;\n    <span class=\"hljs-attribute\">top</span>:<span class=\"hljs-number\">50%</span>;\n    <span class=\"hljs-attribute\">margin</span>:-<span class=\"hljs-number\">0.2em</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> -<span class=\"hljs-number\">0.2em</span>;\n    <span class=\"hljs-attribute\">text-indent</span>:-<span class=\"hljs-number\">9999em</span>;\n    <span class=\"hljs-attribute\">border-top</span>:.<span class=\"hljs-number\">3em</span> solid <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0.1</span>);\n    <span class=\"hljs-attribute\">border-right</span>:.<span class=\"hljs-number\">3em</span> solid <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0.1</span>);\n    <span class=\"hljs-attribute\">border-bottom</span>:.<span class=\"hljs-number\">3em</span> solid <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0.1</span>);\n    <span class=\"hljs-attribute\">border-left</span>:.<span class=\"hljs-number\">3em</span> solid <span class=\"hljs-number\">#9cc</span>;\n    <span class=\"hljs-comment\">/* 篇幅原因省略了一些兼容性CSS配置 */</span>\n    <span class=\"hljs-attribute\">transform</span>:<span class=\"hljs-built_in\">translateZ</span>(<span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-comment\">/* 关键CSS：关联对应的动画配置loader ，篇幅原因省略了一些兼容性CSS配置 */</span>\n    <span class=\"hljs-attribute\">animation</span>:loader .<span class=\"hljs-number\">5s</span> infinite linear;\n    <span class=\"hljs-attribute\">z-index</span>:<span class=\"hljs-number\">999</span>;\n}\n<span class=\"hljs-selector-class\">.loader</span>,<span class=\"hljs-selector-class\">.loader</span>:after{\n    border-radius:<span class=\"hljs-number\">50%</span>;<span class=\"hljs-attribute\">width</span>:<span class=\"hljs-number\">2em</span>;<span class=\"hljs-attribute\">height</span>:<span class=\"hljs-number\">2em</span>\n}\n<span class=\"hljs-selector-class\">.curtain</span>{\n    <span class=\"hljs-attribute\">position</span>:fixed;\n    <span class=\"hljs-attribute\">width</span>:<span class=\"hljs-number\">100%</span>;\n    <span class=\"hljs-attribute\">height</span>:<span class=\"hljs-number\">100%</span>;\n    <span class=\"hljs-attribute\">top</span>:<span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">left</span>:<span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">background-color</span>:white;\n    <span class=\"hljs-attribute\">filter</span>:<span class=\"hljs-built_in\">alpha</span>(opacity=<span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-attribute\">opacity</span>:<span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">z-index</span>:<span class=\"hljs-number\">0</span>\n}\n<span class=\"hljs-selector-class\">.sending</span> <span class=\"hljs-selector-class\">.curtain</span>{\n    <span class=\"hljs-attribute\">top</span>:<span class=\"hljs-number\">0px</span>;\n}\n<span class=\"hljs-comment\">/* 动画配置loader，篇幅原因省略了一些兼容性CSS配置 */</span>\n<span class=\"hljs-keyword\">@keyframes</span> loader{\n    <span class=\"hljs-number\">0%</span>{\n        -webkit-<span class=\"hljs-attribute\">transform</span>:<span class=\"hljs-built_in\">rotate</span>(<span class=\"hljs-number\">0deg</span>);\n        <span class=\"hljs-attribute\">transform</span>:<span class=\"hljs-built_in\">rotate</span>(<span class=\"hljs-number\">0deg</span>);\n    }\n    <span class=\"hljs-number\">100%</span>{\n        -webkit-<span class=\"hljs-attribute\">transform</span>:<span class=\"hljs-built_in\">rotate</span>(<span class=\"hljs-number\">360deg</span>);\n        <span class=\"hljs-attribute\">transform</span>:<span class=\"hljs-built_in\">rotate</span>(<span class=\"hljs-number\">360deg</span>);\n    }\n}\n<span class=\"hljs-selector-class\">.is-loading</span> <span class=\"hljs-selector-class\">.loader</span>,<span class=\"hljs-selector-class\">.is-loading</span> <span class=\"hljs-selector-class\">.curtain</span>\n{\n    <span class=\"hljs-attribute\">filter</span>:progid:DXImageTransform.Microsoft.<span class=\"hljs-built_in\">Alpha</span>(enabled=false);\n    <span class=\"hljs-attribute\">opacity</span>:<span class=\"hljs-number\">1</span>\n}\n<span class=\"hljs-selector-class\">.is-loading</span> <span class=\"hljs-selector-class\">.curtain</span>{\n    <span class=\"hljs-attribute\">z-index</span>:<span class=\"hljs-number\">999</span>\n}\n<span class=\"hljs-comment\">/* 自定义滚动条样式，可有可无 */</span>\n::-webkit-scrollbar\n{\n    width:<span class=\"hljs-number\">12px</span>;\n    <span class=\"hljs-attribute\">height</span>:<span class=\"hljs-number\">12px</span>;\n}\n::-webkit-scrollbar-thumb\n{\n    border-radius:<span class=\"hljs-number\">2px</span>;\n    <span class=\"hljs-attribute\">background-color</span>:<span class=\"hljs-number\">#99cccc</span>;\n    <span class=\"hljs-attribute\">background-image</span>:<span class=\"hljs-built_in\">-webkit-linear-gradient</span>(<span class=\"hljs-number\">45deg</span>,<span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">255</span>,<span class=\"hljs-number\">255</span>,<span class=\"hljs-number\">255</span>,.<span class=\"hljs-number\">2</span>) <span class=\"hljs-number\">25%</span>,transparent <span class=\"hljs-number\">25%</span>,transparent <span class=\"hljs-number\">50%</span>,<span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">255</span>,<span class=\"hljs-number\">255</span>,<span class=\"hljs-number\">255</span>,.<span class=\"hljs-number\">2</span>) <span class=\"hljs-number\">50%</span>,<span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">255</span>,<span class=\"hljs-number\">255</span>,<span class=\"hljs-number\">255</span>,.<span class=\"hljs-number\">2</span>) <span class=\"hljs-number\">75%</span>,transparent <span class=\"hljs-number\">75%</span>,transparent);\n}\n::-webkit-scrollbar-track\n{\n    -webkit-box-shadow:inset <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">6px</span> <span class=\"hljs-number\">#ddd</span>;\n    <span class=\"hljs-attribute\">background-color</span>:<span class=\"hljs-number\">#fbfbfb</span>;\n    <span class=\"hljs-attribute\">border-radius</span>:<span class=\"hljs-number\">2px</span>;\n}\n</code></pre>\n<h2 id=\"menu_5\">引入CSS文件</h2><p>放在head便签区域内的最下方（尽量优先加载）。</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;css/preloading.css&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n</code></pre>\n<h2 id=\"menu_6\">定义元素并应用</h2><p>放在body区域最上方，主要便于浮动时可以盖住其他元素。</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;is-loading&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;load&quot;</span>&gt;</span> \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;curtain&quot;</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;loader&quot;</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"language-javascript\">\n<span class=\"hljs-comment\">//确保Jquey已加载后执行进入 </span>\n(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">$</span>){\n    <span class=\"hljs-comment\">//$(window).load 和 $(document).ready 都可以使用，虽然有差别，整体感知不明显</span>\n    $(<span class=\"hljs-variable language_\">window</span>).<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;load&quot;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) { \n        <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n            <span class=\"hljs-comment\">//隐藏或者移除Class均可以使用</span>\n            <span class=\"hljs-comment\">//推荐用CSS特性实现 </span>\n            <span class=\"hljs-comment\">//$(&quot;#load&quot;).removeClass(&quot;is-loading&quot;);</span>\n            $(<span class=\"hljs-string\">&quot;#load&quot;</span>).<span class=\"hljs-title function_\">hide</span>(<span class=\"hljs-number\">500</span>);\n        }, <span class=\"hljs-number\">100</span>);\n    });\n})(jQuery);\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n</code></pre>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">关于预加载动画</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">引入Jquery</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">实现思路</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">定义preloading.css</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">引入CSS文件</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">定义元素并应用</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1033, '# Xmanager\n\n米虫初次接触到Xmanager是在华为事业线的一个开发项目组。\n\n当时给米虫实用Xmanager安装包是企业旗舰版，功能完整强大。\n\nXmanager包含众多工具，包括：Xshell、Sftp、Xlpd、Xstart。\n\n对于广大用户而言，最多会接触到Xshell与Xftp工具，图形化界面，操作简单方便。\n\n## Xshell和Xftp\n\n - Xshell：\n	Xshell是一个用于MS Windows平台的强大的SSH、TELNET、和RLOGIN终端仿真软件。\n	用户能轻松和安全地从Windows PC上访问Unix/Linux主机\n - Xftp：\n	Xftp是一个用于MS Windows平台的强大的FTP和SFTP文件传输程序。\n	用户能安全地在Unix/Linux和Windows PC之间传输文件。\n\nXshell和Xftp两个工具同时安装的时候，可以在Xhell中一键跳到Xftp中。\n\n也就是说当你使用Xshell远程连接到Unix/Linux主机上，想在主机上上传或下载文件可以一键跳到Xftp工具中进行操作。\n\n同样在Xshell界面也可以通过命令下载文件。\n\n关于Xshell的更多个性化的功能就不一一赘述了。\n\n比如：选中自动复制、右键粘贴、底色等自定义调整。\n\n# 家庭版和企业版\n\n值得注意的是Xshell和Xftp都是非开源的软件，企业版是需要在线授权的。\n\n目前网络上大多数所谓的破解企业版都只是一个试用版。\n\nXmanager官方是提供家庭版免费下载，需要填写邮箱申请，然后发送一个有时效性的链接到邮箱中。\n\n家庭版和企业版最大的差别就是不能无限的开连接窗口，对于个人而言家庭版已经够用了。\n\n# 工具下载 \n\n[https://www.netsarang.com/download/free_license.html](https://www.netsarang.com/download/free_license.html)\n\n在此页面进行免费申请。\n\n# 使用界面图示\n\n![/static/upload/post/1646008983802.png](/static/upload/post/1646008983802.png)\n\n\n![/static/upload/post/1646008991852.png](/static/upload/post/1646008991852.png)\n', '<h1 id=\"menu_1\">Xmanager</h1><p>米虫初次接触到Xmanager是在华为事业线的一个开发项目组。</p>\n<p>当时给米虫实用Xmanager安装包是企业旗舰版，功能完整强大。</p>\n<p>Xmanager包含众多工具，包括：Xshell、Sftp、Xlpd、Xstart。</p>\n<p>对于广大用户而言，最多会接触到Xshell与Xftp工具，图形化界面，操作简单方便。</p>\n<h2 id=\"menu_2\">Xshell和Xftp</h2><ul>\n<li>Xshell：<br/> Xshell是一个用于MS Windows平台的强大的SSH、TELNET、和RLOGIN终端仿真软件。<br/> 用户能轻松和安全地从Windows PC上访问Unix/Linux主机</li>\n<li>Xftp：<br/> Xftp是一个用于MS Windows平台的强大的FTP和SFTP文件传输程序。<br/> 用户能安全地在Unix/Linux和Windows PC之间传输文件。</li>\n</ul>\n<p>Xshell和Xftp两个工具同时安装的时候，可以在Xhell中一键跳到Xftp中。</p>\n<p>也就是说当你使用Xshell远程连接到Unix/Linux主机上，想在主机上上传或下载文件可以一键跳到Xftp工具中进行操作。</p>\n<p>同样在Xshell界面也可以通过命令下载文件。</p>\n<p>关于Xshell的更多个性化的功能就不一一赘述了。</p>\n<p>比如：选中自动复制、右键粘贴、底色等自定义调整。</p>\n<h1 id=\"menu_3\">家庭版和企业版</h1><p>值得注意的是Xshell和Xftp都是非开源的软件，企业版是需要在线授权的。</p>\n<p>目前网络上大多数所谓的破解企业版都只是一个试用版。</p>\n<p>Xmanager官方是提供家庭版免费下载，需要填写邮箱申请，然后发送一个有时效性的链接到邮箱中。</p>\n<p>家庭版和企业版最大的差别就是不能无限的开连接窗口，对于个人而言家庭版已经够用了。</p>\n<h1 id=\"menu_4\">工具下载</h1><p><a class=\"mlink\" href=\"https://www.netsarang.com/download/free_license.html\" title=\"https://www.netsarang.com/download/free_license.html\" target=\"_blank\">https://www.netsarang.com/download/free_license.html</a></p>\n<p>在此页面进行免费申请。</p>\n<h1 id=\"menu_5\">使用界面图示</h1><p><img src=\"/static/upload/post/1646008983802.png\" alt=\"/static/upload/post/1646008983802.png\"/></p>\n<p><img src=\"/static/upload/post/1646008991852.png\" alt=\"/static/upload/post/1646008991852.png\"/></p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">Xmanager</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">Xshell和Xftp</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">家庭版和企业版</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">工具下载</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">使用界面图示</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1034, '# 诉求说明\n\n网站为了提升内容曝光率或聚合咨询，经常设计为二栏或者三栏布局。\n\n下图为常见的二栏的网站布局示意图：\n\n![/static/upload/post/1646009470433.jpg](/static/upload/post/1646009470433.jpg)\n\n除了正文区域外的侧边栏为了更多的聚合网站内容，增加用户兴趣以提升用户黏性。\n\n一般情况下侧边栏的长度是固定的，指定数量的信息列表等等。\n\n如果侧边栏过长，正文过短则会使正文下方出现大面积空白，所以通常侧边栏都相对较短。\n\n而通常正文的长度是不可预知的，或者是无法通过指定长度限制的。\n\n如果正文较短，侧边栏长一点点的话还能够说的过去。\n\n如果正文过长，当用户下拉阅读时就会感觉侧边栏区域非常空旷，体验不友好。\n\n示意效果如下：\n\n![/static/upload/post/1646009487200.jpg](/static/upload/post/1646009487200.jpg)\n\n![/static/upload/post/1646009492718.jpg](/static/upload/post/1646009492718.jpg)\n\n因此侧边栏动态固顶变得很有必要。\n\n很多时候网站的侧边栏长度高于屏幕，如果全部固顶必然导致侧边栏靠下的内容无法展示。\n\n因此我们可以选择侧边栏最后一个或多个元素为固顶的元素。\n\n并实现滚动条滑动到元素所在位置进行固顶，返回越过初始位置则恢复原位置。\n\n主要通过监听滚动事件，判断滚动是否达到阈值，对某些元素的CSS样式进行修改。\n\n效果可参考本站的左侧文章目录效果。\n\n我们更多需要了解一个实现思路。\n\n# DEMO代码&注释\n\n一个简单的DEMO，我们选择id=\"fixed_box\"的元素作为滑动固顶元素。\n\n为了明显区分各个元素，米虫使用不同的背景色。\n\n该效果只有屏幕宽度超过1000px才会生效，因为对于手机端或其他移动端而言，侧边栏固顶没有必要。\n\n可以全文COPY本代码至一个空的HTML文件中体验。\n\n实现动态固定的原理主要是计算当前滚动的位置，替换需要固顶元素的position属性来达成动态效果。\n\n实现核心：Jquery的scroll()（也可以通过监听原生的滚动事件）\n\n```html\n<html lang=\"zh_CN\">\n<head>\n	<meta charset=\"utf-8\">\n	<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n	<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n	<title>滑动指定元素位置侧边栏固定及恢复 - 米虫先生</title>\n	<meta name=\"keywords\" content=\"米虫,前端,DEMO\">\n	<meta name=\"description\" content=\"滑动指定元素位置侧边栏固定及返回原位置恢复的DEMO\">\n</head>\n<body>\n	<style>\n	body{\n		width:1000px;\n		margin:0 auto;\n		font-size:24px;\n		text-align:center;\n		color:#fff;\n		line-height:50px;\n	}\n	.left{\n		height:1500px;\n		width:700px;\n		float:left;\n		background:black;\n	}\n	.right{\n		float:left;\n	}\n	.right_box{\n		width:300px;\n		height:300px;\n	}\n	</style>\n	<div class=\"left\">\n		<br><br><br>正文区域<br><br><br>\n		<br><br><br>正文区域<br><br><br>\n		<br><br><br>正文区域<br><br><br>\n		<br><br><br>正文区域<br><br><br>\n		<br><br><br>正文区域<br><br><br>\n	</div>\n	<div class=\"right\">\n		<div class=\"right_box\" style=\"background:green;\">\n			<br><br>该区域不浮动<br><br>\n		</div>\n		<div id=\"fixed_box\" class=\"right_box\" style=\"background:blue;\">              			<br>达到区域需要浮动<br>\n			返回恢复位置<br>\n			浮动主要针对PC<br>\n			手机不需要浮动<br>\n		</div>\n	</div> \n	<!-- 加载Jquery -->\n	<script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"></script>       	<script>\n		//获取屏幕宽度\n		var width = $(window).width();\n		if(width>1000) {\n			//需要悬浮元素距离顶部的距离\n			var oTop = $(\"#fixed_box\").offset().top;\n			//当前滑动距离\n			var sTop = 0;\n			//当滑动时触发\n			$(window).scroll(function() {\n				//实时滑动距离\n				sTop = $(this).scrollTop();\n				//越过元素，悬浮\n				if(sTop >= oTop) {\n					//此处可以通过指定一个class的方式实现样式浮动\n					//通过CSS3特性还可以实现一些Class叠加后的动态线性变化\n					$(\"#fixed_box\").css({\"position\":\"fixed\",\"top\":\"0\"});             				}else{\n					//高度低于原始值，恢复原始样式\n					$(\"#fixed_box\").css({\"position\":\"static\"});\n				}\n			});\n		}\n	</script>\n</body>\n</html>\n```', '<h1 id=\"menu_1\">诉求说明</h1><p>网站为了提升内容曝光率或聚合咨询，经常设计为二栏或者三栏布局。</p>\n<p>下图为常见的二栏的网站布局示意图：</p>\n<p><img src=\"/static/upload/post/1646009470433.jpg\" alt=\"/static/upload/post/1646009470433.jpg\"/></p>\n<p>除了正文区域外的侧边栏为了更多的聚合网站内容，增加用户兴趣以提升用户黏性。</p>\n<p>一般情况下侧边栏的长度是固定的，指定数量的信息列表等等。</p>\n<p>如果侧边栏过长，正文过短则会使正文下方出现大面积空白，所以通常侧边栏都相对较短。</p>\n<p>而通常正文的长度是不可预知的，或者是无法通过指定长度限制的。</p>\n<p>如果正文较短，侧边栏长一点点的话还能够说的过去。</p>\n<p>如果正文过长，当用户下拉阅读时就会感觉侧边栏区域非常空旷，体验不友好。</p>\n<p>示意效果如下：</p>\n<p><img src=\"/static/upload/post/1646009487200.jpg\" alt=\"/static/upload/post/1646009487200.jpg\"/></p>\n<p><img src=\"/static/upload/post/1646009492718.jpg\" alt=\"/static/upload/post/1646009492718.jpg\"/></p>\n<p>因此侧边栏动态固顶变得很有必要。</p>\n<p>很多时候网站的侧边栏长度高于屏幕，如果全部固顶必然导致侧边栏靠下的内容无法展示。</p>\n<p>因此我们可以选择侧边栏最后一个或多个元素为固顶的元素。</p>\n<p>并实现滚动条滑动到元素所在位置进行固顶，返回越过初始位置则恢复原位置。</p>\n<p>主要通过监听滚动事件，判断滚动是否达到阈值，对某些元素的CSS样式进行修改。</p>\n<p>效果可参考本站的左侧文章目录效果。</p>\n<p>我们更多需要了解一个实现思路。</p>\n<h1 id=\"menu_2\">DEMO代码&amp;注释</h1><p>一个简单的DEMO，我们选择id=&quot;fixed_box&quot;的元素作为滑动固顶元素。</p>\n<p>为了明显区分各个元素，米虫使用不同的背景色。</p>\n<p>该效果只有屏幕宽度超过1000px才会生效，因为对于手机端或其他移动端而言，侧边栏固顶没有必要。</p>\n<p>可以全文COPY本代码至一个空的HTML文件中体验。</p>\n<p>实现动态固定的原理主要是计算当前滚动的位置，替换需要固顶元素的position属性来达成动态效果。</p>\n<p>实现核心：Jquery的scroll()（也可以通过监听原生的滚动事件）</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh_CN&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>滑动指定元素位置侧边栏固定及恢复 - 米虫先生<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;keywords&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;米虫,前端,DEMO&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;description&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;滑动指定元素位置侧边栏固定及返回原位置恢复的DEMO&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\">\n    <span class=\"hljs-selector-tag\">body</span>{\n        <span class=\"hljs-attribute\">width</span>:<span class=\"hljs-number\">1000px</span>;\n        <span class=\"hljs-attribute\">margin</span>:<span class=\"hljs-number\">0</span> auto;\n        <span class=\"hljs-attribute\">font-size</span>:<span class=\"hljs-number\">24px</span>;\n        <span class=\"hljs-attribute\">text-align</span>:center;\n        <span class=\"hljs-attribute\">color</span>:<span class=\"hljs-number\">#fff</span>;\n        <span class=\"hljs-attribute\">line-height</span>:<span class=\"hljs-number\">50px</span>;\n    }\n    <span class=\"hljs-selector-class\">.left</span>{\n        <span class=\"hljs-attribute\">height</span>:<span class=\"hljs-number\">1500px</span>;\n        <span class=\"hljs-attribute\">width</span>:<span class=\"hljs-number\">700px</span>;\n        <span class=\"hljs-attribute\">float</span><span class=\"hljs-selector-pseudo\">:left</span>;\n        <span class=\"hljs-attribute\">background</span>:black;\n    }\n    <span class=\"hljs-selector-class\">.right</span>{\n        <span class=\"hljs-attribute\">float</span><span class=\"hljs-selector-pseudo\">:left</span>;\n    }\n    <span class=\"hljs-selector-class\">.right_box</span>{\n        <span class=\"hljs-attribute\">width</span>:<span class=\"hljs-number\">300px</span>;\n        <span class=\"hljs-attribute\">height</span>:<span class=\"hljs-number\">300px</span>;\n    }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;left&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>正文区域<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>正文区域<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>正文区域<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>正文区域<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>正文区域<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;right&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;right_box&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;background:green;&quot;</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>该区域不浮动<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;fixed_box&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;right_box&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;background:blue;&quot;</span>&gt;</span>                          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>达到区域需要浮动<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n            返回恢复位置<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n            浮动主要针对PC<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n            手机不需要浮动<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> \n    <span class=\"hljs-comment\">&lt;!-- 加载Jquery --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n        <span class=\"hljs-comment\">//获取屏幕宽度</span>\n        <span class=\"hljs-keyword\">var</span> width = $(<span class=\"hljs-variable language_\">window</span>).<span class=\"hljs-title function_\">width</span>();\n        <span class=\"hljs-keyword\">if</span>(width&gt;<span class=\"hljs-number\">1000</span>) {\n            <span class=\"hljs-comment\">//需要悬浮元素距离顶部的距离</span>\n            <span class=\"hljs-keyword\">var</span> oTop = $(<span class=\"hljs-string\">&quot;#fixed_box&quot;</span>).<span class=\"hljs-title function_\">offset</span>().<span class=\"hljs-property\">top</span>;\n            <span class=\"hljs-comment\">//当前滑动距离</span>\n            <span class=\"hljs-keyword\">var</span> sTop = <span class=\"hljs-number\">0</span>;\n            <span class=\"hljs-comment\">//当滑动时触发</span>\n            $(<span class=\"hljs-variable language_\">window</span>).<span class=\"hljs-title function_\">scroll</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-comment\">//实时滑动距离</span>\n                sTop = $(<span class=\"hljs-variable language_\">this</span>).<span class=\"hljs-title function_\">scrollTop</span>();\n                <span class=\"hljs-comment\">//越过元素，悬浮</span>\n                <span class=\"hljs-keyword\">if</span>(sTop &gt;= oTop) {\n                    <span class=\"hljs-comment\">//此处可以通过指定一个class的方式实现样式浮动</span>\n                    <span class=\"hljs-comment\">//通过CSS3特性还可以实现一些Class叠加后的动态线性变化</span>\n                    $(<span class=\"hljs-string\">&quot;#fixed_box&quot;</span>).<span class=\"hljs-title function_\">css</span>({<span class=\"hljs-string\">&quot;position&quot;</span>:<span class=\"hljs-string\">&quot;fixed&quot;</span>,<span class=\"hljs-string\">&quot;top&quot;</span>:<span class=\"hljs-string\">&quot;0&quot;</span>});                             }<span class=\"hljs-keyword\">else</span>{\n                    <span class=\"hljs-comment\">//高度低于原始值，恢复原始样式</span>\n                    $(<span class=\"hljs-string\">&quot;#fixed_box&quot;</span>).<span class=\"hljs-title function_\">css</span>({<span class=\"hljs-string\">&quot;position&quot;</span>:<span class=\"hljs-string\">&quot;static&quot;</span>});\n                }\n            });\n        }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">诉求说明</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">DEMO代码&amp;amp;注释</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1035, '# 工具类实现\n\n实现ApplicationContextAware接口，以静态变量保存Spring ApplicationContext。\n\n可在任何代码任何地方任何时候中取出ApplicaitonContext。\n\n如此就不能不说说org.springframework.context.ApplicationContextAware这个接口。\n\n# ApplicationContextAware接口\n\n当一个类实现了这个接口（ApplicationContextAware）之后，这个类就可以方便获得ApplicationContext中的所有bean。\n\n换句话说，就是这个类可以直接获取spring配置文件中，所有有引用到的bean对象。\n\n除了以上SpringContextHolder类之外，还有不需要多次加载spring配置文件就可以取得bean的类。\n\nSpring容器会检测容器中的所有Bean，如果发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的setApplicationContextAware()方法，调用该方法时，会将容器本身作为参数传给该方法。\n\n该方法中的实现部分将Spring传入的参数（容器本身）赋给该类对象的applicationContext实例变量，因此接下来可以通过该applicationContext实例变量来访问容器本身。\n\n# 代码示例\n\n```java\n/*\n * Spring的ApplicationContext的持有者，可以用静态方法的方式获取spring容器中的bean\n * 以静态变量保存Spring ApplicationContext, 可在任何代码任何地方任何时候中取出ApplicaitonContext\n */\n//如果使用注解的方式，需要而配置@Lazy(false)表示不延迟加载（系统启动即刻加载）\n@Component\n@Lazy(false)\npublic class SpringContextHolder implements ApplicationContextAware {\n	\n	private static ApplicationContext applicationContext;\n	\n	//实现ApplicationContextAware接口的context注入函数, 将其存入静态变量\n	public void setApplicationContext(ApplicationContext applicationContext) {\n		SpringContextHolder.applicationContext = applicationContext;\n	}\n	\n	//取得存储在静态变量中的ApplicationContext\n	public static ApplicationContext getApplicationContext() {\n		checkApplicationContext();\n		return applicationContext;\n	}\n	\n	//从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型\n	@SuppressWarnings(\"unchecked\")\n	public static <T> T getBean(String name) {\n		checkApplicationContext();\n		return (T) applicationContext.getBean(name);\n	}\n	\n	//从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型\n	//如果有多个Bean符合Class, 取出第一个\n	public static <T> T getBean(Class<T> requiredType) {\n		checkApplicationContext();\n		return applicationContext.getBean(requiredType); \n	}\n	\n	//清除applicationContext静态变量\n	public static void cleanApplicationContext() {\n		applicationContext = null;\n	}\n	\n	//检查是否存在\n	private static void checkApplicationContext() {\n		if (applicationContext == null) {\n			throw new IllegalStateException(\"applicaitonContext未注入,请在applicationContext.xml中定义SpringContextHolder或配置@Lazy(false)\");\n		}\n	}\n}\n```\n\n## XML配置形式\n\n如果不是采用注解的方式配置Spring则需要在spring-context.xml，添加bean：\n\n```xml\n<bean id=\"springContextHolder\" class=\"com.mebugs.utils.SpringContextHolder\" lazy-init=\"false\"/>\n```\n\n# 实际调用示例\n\n```java\nprivate UserService userService= SpringContextHolder.getBean(UserService.class);\n```\n\n# 报错处理\n\n**启动项目后报错 \"applicaitonContext属性为null,请检查是否注入了SpringContextHolder!\"**  \n\nSpringContextHolder这个bean没有在实际调用类加载前进行加载，导致没有加载完成。\n\n所以我们需要在配置文件中首先加载SpringContextHolder。\n\n - **XML配置方式：**\n	把bean配置放在配置文件的第一行，务必要配置不延迟加载（等同于@Lazy(false)）\n - **注解配置方式：**\n	实际需要被调用的bean（如UserService），类上添加注解 @DependsOn(\"springContextHolder\")，用于确保加载此bean之前SpringContextHolder类已加载', '<h1 id=\"menu_1\">工具类实现</h1><p>实现ApplicationContextAware接口，以静态变量保存Spring ApplicationContext。</p>\n<p>可在任何代码任何地方任何时候中取出ApplicaitonContext。</p>\n<p>如此就不能不说说org.springframework.context.ApplicationContextAware这个接口。</p>\n<h1 id=\"menu_2\">ApplicationContextAware接口</h1><p>当一个类实现了这个接口（ApplicationContextAware）之后，这个类就可以方便获得ApplicationContext中的所有bean。</p>\n<p>换句话说，就是这个类可以直接获取spring配置文件中，所有有引用到的bean对象。</p>\n<p>除了以上SpringContextHolder类之外，还有不需要多次加载spring配置文件就可以取得bean的类。</p>\n<p>Spring容器会检测容器中的所有Bean，如果发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的setApplicationContextAware()方法，调用该方法时，会将容器本身作为参数传给该方法。</p>\n<p>该方法中的实现部分将Spring传入的参数（容器本身）赋给该类对象的applicationContext实例变量，因此接下来可以通过该applicationContext实例变量来访问容器本身。</p>\n<h1 id=\"menu_3\">代码示例</h1><pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">/*\n * Spring的ApplicationContext的持有者，可以用静态方法的方式获取spring容器中的bean\n * 以静态变量保存Spring ApplicationContext, 可在任何代码任何地方任何时候中取出ApplicaitonContext\n */</span>\n<span class=\"hljs-comment\">//如果使用注解的方式，需要而配置@Lazy(false)表示不延迟加载（系统启动即刻加载）</span>\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-meta\">@Lazy</span>(<span class=\"hljs-literal\">false</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SpringContextHolder</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">ApplicationContextAware</span> {\n    \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title class_\">ApplicationContext</span> applicationContext;\n    \n    <span class=\"hljs-comment\">//实现ApplicationContextAware接口的context注入函数, 将其存入静态变量</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">setApplicationContext</span>(<span class=\"hljs-params\">ApplicationContext applicationContext</span>) {\n        <span class=\"hljs-title class_\">SpringContextHolder</span>.<span class=\"hljs-property\">applicationContext</span> = applicationContext;\n    }\n    \n    <span class=\"hljs-comment\">//取得存储在静态变量中的ApplicationContext</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title class_\">ApplicationContext</span> <span class=\"hljs-title function_\">getApplicationContext</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-title function_\">checkApplicationContext</span>();\n        <span class=\"hljs-keyword\">return</span> applicationContext;\n    }\n    \n    <span class=\"hljs-comment\">//从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型</span>\n    <span class=\"hljs-meta\">@SuppressWarnings</span>(<span class=\"hljs-string\">&quot;unchecked&quot;</span>)\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; T <span class=\"hljs-title function_\">getBean</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span> name</span>) {\n        <span class=\"hljs-title function_\">checkApplicationContext</span>();\n        <span class=\"hljs-keyword\">return</span> (T) applicationContext.<span class=\"hljs-title function_\">getBean</span>(name);\n    }\n    \n    <span class=\"hljs-comment\">//从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型</span>\n    <span class=\"hljs-comment\">//如果有多个Bean符合Class, 取出第一个</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; T <span class=\"hljs-title function_\">getBean</span>(<span class=\"hljs-params\">Class&lt;T&gt; requiredType</span>) {\n        <span class=\"hljs-title function_\">checkApplicationContext</span>();\n        <span class=\"hljs-keyword\">return</span> applicationContext.<span class=\"hljs-title function_\">getBean</span>(requiredType); \n    }\n    \n    <span class=\"hljs-comment\">//清除applicationContext静态变量</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">cleanApplicationContext</span>(<span class=\"hljs-params\"></span>) {\n        applicationContext = <span class=\"hljs-literal\">null</span>;\n    }\n    \n    <span class=\"hljs-comment\">//检查是否存在</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">checkApplicationContext</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">if</span> (applicationContext == <span class=\"hljs-literal\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalStateException</span>(<span class=\"hljs-string\">&quot;applicaitonContext未注入,请在applicationContext.xml中定义SpringContextHolder或配置@Lazy(false)&quot;</span>);\n        }\n    }\n}\n</code></pre>\n<h2 id=\"menu_4\">XML配置形式</h2><p>如果不是采用注解的方式配置Spring则需要在spring-context.xml，添加bean：</p>\n<pre><code class=\"hljs language-xml\">&lt;bean <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;springContextHolder&quot;</span> <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;com.mebugs.utils.SpringContextHolder&quot;</span> lazy-init=<span class=\"hljs-string\">&quot;false&quot;</span>/&gt;\n</code></pre>\n<h1 id=\"menu_5\">实际调用示例</h1><pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">private</span> UserService userService= SpringContextHolder.getBean(UserService.<span class=\"hljs-keyword\">class</span>);\n</code></pre>\n<h1 id=\"menu_6\">报错处理</h1><p><strong>启动项目后报错 &quot;applicaitonContext属性为null,请检查是否注入了SpringContextHolder!&quot;</strong>  </p>\n<p>SpringContextHolder这个bean没有在实际调用类加载前进行加载，导致没有加载完成。</p>\n<p>所以我们需要在配置文件中首先加载SpringContextHolder。</p>\n<ul>\n<li><strong>XML配置方式：</strong><br/> 把bean配置放在配置文件的第一行，务必要配置不延迟加载（等同于@Lazy(false)）</li>\n<li><strong>注解配置方式：</strong><br/> 实际需要被调用的bean（如UserService），类上添加注解 @DependsOn(&quot;springContextHolder&quot;)，用于确保加载此bean之前SpringContextHolder类已加载</li>\n</ul>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">工具类实现</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">ApplicationContextAware接口</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">代码示例</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">XML配置形式</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">实际调用示例</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl1\">报错处理</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1036, '# 导航动态显示隐藏\n\n实现页面下滑时，固顶导航自动上滑隐藏。\n\n实现页面上滑时，固定导航自动下拉显示。\n\n需求的核心点在于判断页面当前为下滑还是上滑。\n\n此外导航的显示与隐藏不能太过于突兀，采用平滑的动画效果更好。\n\n# CSS代码\n\n```css\n/*动画样式*/\n/*当元素产生变化时，0.6S内完成此变化*/\n*{\n	-webkit-transition:all .6s;\n	-moz-transition:all .6s;\n	-ms-transition:all .6s;\n	-o-transition:all .6s;\n	/*上面四条为了兼容各个内核的浏览器，实际仅需下方一条样式*/\n	transition:all .6s;\n}\n/*固顶导航样式*/\n/*这个样式在Headroom.js小插件一文中也用到了*/\nheader{\n	height: 60px;\n	width: 100%;\n	background:#2c4762;\n	position:fixed;\n	/*顶部距离*/\n	top: 0;\n}\n/*下滑触发追加的CSS*/ \n/*追加此样式时，导航在0.6S时间内从顶部上滑至-60px负距离*/\n.down{\n	/*顶部负距离，一般和导航高度一致*/\n	top:-60px;\n}\n```\n# JS代码\n\n```js\n$(function(){\n	//记录顶部距离\n	var windowTop=0;\n	//触发页面滑动时会进入此方法\n	$(window).scroll(function(){\n		//获取当前可视区域距离页面顶端的距离\n		var scrolls = $(this).scrollTop();\n		//当scrolls>windowTop时，表示页面在向下滑动\n		if(scrolls>=windowTop){\n			//追加样式并记录新的距离\n			$(\"#header\").addClass(\"down\");\n			windowTop=scrolls;\n		}else{\n			$(\"#header\").removeClass(\"down\");\n			windowTop=scrolls;\n		}\n	});\n});\n```\n\n# Headroom.js小插件\n\n有一款轻量级、高性能的JS小工具（不依赖任何工具库），它能在页面滚动时做出响应。\n\nHeadroom.js 使得我们只需要极少的代码就能完成这项诉求。\n\n其实现思路和尚未描述的一致。\n\n## 实现原理\n响应滚动事件的页面元素增加或删除一个CSS class，已达到导航栏的显示和隐藏。\n\n```html\n<!-- 这三种状态均由headroom.js进行完成 -->\n<!-- 初始状态 -->\n<header class=\"headroom\">\n<!-- 向下滚动时 -->\n<header class=\"headroom headroom--unpinned\">\n<!-- 向上滚动时 -->\n<header class=\"headroom headroom--pinned\">\n```\n\n## Headroom调用方式\n\nHeadroom.js提供了多种调用方式，为了更能够浅显易懂的使用工具，米虫提供一个最简的Demo以便于理解。\n\n米虫比较偷懒，直接用的Jquery的写法。\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh_CN\">\n<head>\n	<meta charset=\"utf-8\">\n	<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n	<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n	<title>Headroom.js轻松实现导航动态显示隐藏DEMO - 米虫博客</title>\n	<meta name=\"keywords\" content=\"米虫,前端,DEMO\">\n	<meta name=\"description\" content=\"Headroom.js轻松实现导航动态显示隐藏的DEMO\">\n</head>\n<body>\n	<style>\n	/*导航的原始固顶样式*/\n	.header\n	{\n		position: fixed;\n		text-align: center;\n		width: 100%;\n		height: 50px;\n		background: #333;\n		color: #fff;\n		line-height: 50px;\n		font-size: 24px;\n	}\n	/*导航常规CSS*/\n	.headroom\n	{\n		top: 0px;\n		/*延时*/\n		transition: all 1s;\n	}\n	/*导航下滚CSS*/\n	.headroom--unpinned\n	{\n		top: -100px;\n	}\n	/*导航上滚CSS*/\n	.headroom--pinned\n	{\n		top: 0px;\n	}\n	.body\n	{\n		padding: 100% 40px;\n		text-align: center;\n		background: #eee;\n	}\n	</style>\n	<div id=\"header\" class=\"header headroom\">\n		顶部导航\n	</div>\n	<div class=\"body\">\n		为了便于展示，正文区域可以设计高一些，可以上下拖动测试\n	</div>\n	<!-- 加载Jquery -->\n	<script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"></script>\n	<!-- 加载Headroom -->\n	<script src=\"https://cdn.bootcss.com/headroom/0.9.4/headroom.min.js\"></script>   	<script src=\"https://cdn.bootcss.com/headroom/0.9.4/jQuery.headroom.min.js\"></script>\n	<!-- 初始化头部 -->\n	<script>\n		$(\"#header\").headroom();\n	</script>\n</body>\n</html>\n```\n## Headroom自定义Class名\n   \n米虫这里直接采用了工具默认的样式Class名，如果需要自定义Class名，可以通过官方文档查看其初始化方式！\n\n# 小结\n\n其实本功能比较简单，无需插件实现起来也很容易。', '<h1 id=\"menu_1\">导航动态显示隐藏</h1><p>实现页面下滑时，固顶导航自动上滑隐藏。</p>\n<p>实现页面上滑时，固定导航自动下拉显示。</p>\n<p>需求的核心点在于判断页面当前为下滑还是上滑。</p>\n<p>此外导航的显示与隐藏不能太过于突兀，采用平滑的动画效果更好。</p>\n<h1 id=\"menu_2\">CSS代码</h1><pre><code class=\"hljs language-css\"><span class=\"hljs-comment\">/*动画样式*/</span>\n<span class=\"hljs-comment\">/*当元素产生变化时，0.6S内完成此变化*/</span>\n*{\n    -webkit-<span class=\"hljs-attribute\">transition</span>:all .<span class=\"hljs-number\">6s</span>;\n    -moz-<span class=\"hljs-attribute\">transition</span>:all .<span class=\"hljs-number\">6s</span>;\n    -ms-<span class=\"hljs-attribute\">transition</span>:all .<span class=\"hljs-number\">6s</span>;\n    -o-<span class=\"hljs-attribute\">transition</span>:all .<span class=\"hljs-number\">6s</span>;\n    <span class=\"hljs-comment\">/*上面四条为了兼容各个内核的浏览器，实际仅需下方一条样式*/</span>\n    <span class=\"hljs-attribute\">transition</span>:all .<span class=\"hljs-number\">6s</span>;\n}\n<span class=\"hljs-comment\">/*固顶导航样式*/</span>\n<span class=\"hljs-comment\">/*这个样式在Headroom.js小插件一文中也用到了*/</span>\n<span class=\"hljs-selector-tag\">header</span>{\n    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">60px</span>;\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100%</span>;\n    <span class=\"hljs-attribute\">background</span>:<span class=\"hljs-number\">#2c4762</span>;\n    <span class=\"hljs-attribute\">position</span>:fixed;\n    <span class=\"hljs-comment\">/*顶部距离*/</span>\n    <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0</span>;\n}\n<span class=\"hljs-comment\">/*下滑触发追加的CSS*/</span> \n<span class=\"hljs-comment\">/*追加此样式时，导航在0.6S时间内从顶部上滑至-60px负距离*/</span>\n<span class=\"hljs-selector-class\">.down</span>{\n    <span class=\"hljs-comment\">/*顶部负距离，一般和导航高度一致*/</span>\n    <span class=\"hljs-attribute\">top</span>:-<span class=\"hljs-number\">60px</span>;\n}\n</code></pre>\n<h1 id=\"menu_3\">JS代码</h1><pre><code class=\"hljs language-js\">$(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n    <span class=\"hljs-comment\">//记录顶部距离</span>\n    <span class=\"hljs-keyword\">var</span> windowTop=<span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-comment\">//触发页面滑动时会进入此方法</span>\n    $(<span class=\"hljs-variable language_\">window</span>).<span class=\"hljs-title function_\">scroll</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n        <span class=\"hljs-comment\">//获取当前可视区域距离页面顶端的距离</span>\n        <span class=\"hljs-keyword\">var</span> scrolls = $(<span class=\"hljs-variable language_\">this</span>).<span class=\"hljs-title function_\">scrollTop</span>();\n        <span class=\"hljs-comment\">//当scrolls&gt;windowTop时，表示页面在向下滑动</span>\n        <span class=\"hljs-keyword\">if</span>(scrolls&gt;=windowTop){\n            <span class=\"hljs-comment\">//追加样式并记录新的距离</span>\n            $(<span class=\"hljs-string\">&quot;#header&quot;</span>).<span class=\"hljs-title function_\">addClass</span>(<span class=\"hljs-string\">&quot;down&quot;</span>);\n            windowTop=scrolls;\n        }<span class=\"hljs-keyword\">else</span>{\n            $(<span class=\"hljs-string\">&quot;#header&quot;</span>).<span class=\"hljs-title function_\">removeClass</span>(<span class=\"hljs-string\">&quot;down&quot;</span>);\n            windowTop=scrolls;\n        }\n    });\n});\n</code></pre>\n<h1 id=\"menu_4\">Headroom.js小插件</h1><p>有一款轻量级、高性能的JS小工具（不依赖任何工具库），它能在页面滚动时做出响应。</p>\n<p>Headroom.js 使得我们只需要极少的代码就能完成这项诉求。</p>\n<p>其实现思路和尚未描述的一致。</p>\n<h2 id=\"menu_5\">实现原理</h2><p>响应滚动事件的页面元素增加或删除一个CSS class，已达到导航栏的显示和隐藏。</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&lt;!-- 这三种状态均由headroom.js进行完成 --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 初始状态 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;headroom&quot;</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 向下滚动时 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;headroom headroom--unpinned&quot;</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 向上滚动时 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;headroom headroom--pinned&quot;</span>&gt;</span>\n</code></pre>\n<h2 id=\"menu_6\">Headroom调用方式</h2><p>Headroom.js提供了多种调用方式，为了更能够浅显易懂的使用工具，米虫提供一个最简的Demo以便于理解。</p>\n<p>米虫比较偷懒，直接用的Jquery的写法。</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh_CN&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Headroom.js轻松实现导航动态显示隐藏DEMO - 米虫博客<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;keywords&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;米虫,前端,DEMO&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;description&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;Headroom.js轻松实现导航动态显示隐藏的DEMO&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\">\n    <span class=\"hljs-comment\">/*导航的原始固顶样式*/</span>\n    <span class=\"hljs-selector-class\">.header</span>\n    {\n        <span class=\"hljs-attribute\">position</span>: fixed;\n        <span class=\"hljs-attribute\">text-align</span>: center;\n        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100%</span>;\n        <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">50px</span>;\n        <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#333</span>;\n        <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#fff</span>;\n        <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">50px</span>;\n        <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">24px</span>;\n    }\n    <span class=\"hljs-comment\">/*导航常规CSS*/</span>\n    <span class=\"hljs-selector-class\">.headroom</span>\n    {\n        <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0px</span>;\n        <span class=\"hljs-comment\">/*延时*/</span>\n        <span class=\"hljs-attribute\">transition</span>: all <span class=\"hljs-number\">1s</span>;\n    }\n    <span class=\"hljs-comment\">/*导航下滚CSS*/</span>\n    <span class=\"hljs-selector-class\">.headroom--unpinned</span>\n    {\n        <span class=\"hljs-attribute\">top</span>: -<span class=\"hljs-number\">100px</span>;\n    }\n    <span class=\"hljs-comment\">/*导航上滚CSS*/</span>\n    <span class=\"hljs-selector-class\">.headroom--pinned</span>\n    {\n        <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0px</span>;\n    }\n    <span class=\"hljs-selector-class\">.body</span>\n    {\n        <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">100%</span> <span class=\"hljs-number\">40px</span>;\n        <span class=\"hljs-attribute\">text-align</span>: center;\n        <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#eee</span>;\n    }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;header&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;header headroom&quot;</span>&gt;</span>\n        顶部导航\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;body&quot;</span>&gt;</span>\n        为了便于展示，正文区域可以设计高一些，可以上下拖动测试\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 加载Jquery --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 加载Headroom --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://cdn.bootcss.com/headroom/0.9.4/headroom.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://cdn.bootcss.com/headroom/0.9.4/jQuery.headroom.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 初始化头部 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n        $(<span class=\"hljs-string\">&quot;#header&quot;</span>).<span class=\"hljs-title function_\">headroom</span>();\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<h2 id=\"menu_7\">Headroom自定义Class名</h2><p>米虫这里直接采用了工具默认的样式Class名，如果需要自定义Class名，可以通过官方文档查看其初始化方式！</p>\n<h1 id=\"menu_8\">小结</h1><p>其实本功能比较简单，无需插件实现起来也很容易。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">导航动态显示隐藏</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">CSS代码</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">JS代码</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">Headroom.js小插件</a> <ul><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">实现原理</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">Headroom调用方式</a> <!----></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">Headroom自定义Class名</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl1\">小结</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1037, '# 误操作场景描述\n\n对于双击/频繁点击的场景有时候并非恶意的攻击行为。\n\n如网络延迟导致用户下意识多点击一次、又比如鼠标硬件异常出现单击变双击的情况。\n\n当功能按钮被频繁点击将意味着多次向服务端发起数据请求。\n\n在异步数据传输广泛的今天，很容易出现数据重复，数据库唯一校验失败，展示异常的情况。\n\n举个简单易懂的例子：\n\n比如在购物车中选中某个商品进行删除，如果无意间触发了频繁点击，界面可能提示商品不存在。\n\n实际上是因为第一次触发删除服务端已经删除了此商品，第二次则会提示商品不存在。\n\n这样的场景用户体验较差，此外如果一些关键性的功能没有增加频繁操作的预防措施，极有可能出现冗余的重复数据。\n\n通过JS预防频繁点击误操作有很多种方式，主要分为两种，一种是只允许操作一次和限制时间或返回数据后放开操作限制。\n\n# 只许一次\n\n如果界面中的某个按钮仅允许操作一次的实现逻辑非常简单。\n\n在需要限制的方法外，页面中定义一个变量cFlag（点击开关），默认为true。\n\n首次点击进入后，直接关闭开关，然后执行后续的操作。\n\n```js\n//默认点击开关打开\nvar cFlag = true;\n//提交方法\nfunction submitForm() {\n	if(cFlag) {\n		//首次点击进入方法直接关闭开关\n		cFlag = false;\n		//执行后续ajax提交逻辑\n		//略\n	}else{\n		//如果希望增加一些友情提示可以增加else分支\n		alert(\'请勿频繁提交\');\n	}\n}\n```\n\n# 限定时间或返回数据后放开限制\n\n如果界面的按钮可以点击多次，但是想限制重复点击的时间。\n\n我们可以在代码中增加一个恢复开关的语句\n\n实例代码如下：\n\n```js\n//默认点击开关打开\nvar cFlag = true;\n//提交方法\nfunction submitForm() {\n	if(cFlag) {\n		//首次点击进入方法直接关闭开关\n		cFlag = false;\n		//执行后续提交ajax逻辑\n		//返回数据后放开限制的场景，可以再ajax的返回方法中添加cFlag = true;\n		//代码执行完后增加定时恢复开关\n		//5秒钟恢复点击开关\n		setTimeout(function (){cFlag = true;}, 5000);\n	}else{\n		//如果希望增加一些友情提示可以增加else分支 \n		alert(\'重复提交需要等待5秒\');\n	} \n}\n```\n\n# 限制时间优化提示\n\n如某功能按钮需要间隔30秒提交一次，时间过去15秒后，用户点击了给予提示还需要等待15秒。\n\n该能力不建议完全通过JS实现（可以通过服务端来计算时间直接返回提示）。\n\n并不是JS不能够实现，如果用户在10秒的时候刷新一下页面，计时就会被重置，这个限制就相当于存在漏洞。\n\n但对于流程性强的页面实际还是可以使用的，因为这类页面一旦刷新就需要用户从头操作。\n\n```js\n//提交按钮触发\n$(\'#submit\').click(function() {\n	var nowTime = new Date().getTime();\n	//给这个按钮增加一个点击事件的属性\n	var clickTime = $(this).attr(\'clickTime\');\n	//存在点击时间说明被点击过，判断当前时间和单击时间 \n	if( clickTime != \"undefined\" && (nowTime - clickTime < 30000)) {\n		var waitTime = 30000 - nowTime + clickTime;\n		waitTime = Math.parseInt(waitTime/1000);\n		alert(\'您需要在\'+waitTime+\'秒后方可提交\');\n		return false;\n	}else{\n		//刷新最新的点击时间\n		$(this).attr(\'clickTime\', nowTime);\n		//执行后续提交逻辑\n		//略\n	}\n});\n```\n\n# 结尾小结\n\n预防频繁点击可以减少数据库产生冗余数据的风险。\n\n由于频繁点击产生的报错可能会覆盖首次点击的正常返回信息，会给用户造成很大的困扰。', '<h1 id=\"menu_1\">误操作场景描述</h1><p>对于双击/频繁点击的场景有时候并非恶意的攻击行为。</p>\n<p>如网络延迟导致用户下意识多点击一次、又比如鼠标硬件异常出现单击变双击的情况。</p>\n<p>当功能按钮被频繁点击将意味着多次向服务端发起数据请求。</p>\n<p>在异步数据传输广泛的今天，很容易出现数据重复，数据库唯一校验失败，展示异常的情况。</p>\n<p>举个简单易懂的例子：</p>\n<p>比如在购物车中选中某个商品进行删除，如果无意间触发了频繁点击，界面可能提示商品不存在。</p>\n<p>实际上是因为第一次触发删除服务端已经删除了此商品，第二次则会提示商品不存在。</p>\n<p>这样的场景用户体验较差，此外如果一些关键性的功能没有增加频繁操作的预防措施，极有可能出现冗余的重复数据。</p>\n<p>通过JS预防频繁点击误操作有很多种方式，主要分为两种，一种是只允许操作一次和限制时间或返回数据后放开操作限制。</p>\n<h1 id=\"menu_2\">只许一次</h1><p>如果界面中的某个按钮仅允许操作一次的实现逻辑非常简单。</p>\n<p>在需要限制的方法外，页面中定义一个变量cFlag（点击开关），默认为true。</p>\n<p>首次点击进入后，直接关闭开关，然后执行后续的操作。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//默认点击开关打开</span>\n<span class=\"hljs-keyword\">var</span> cFlag = <span class=\"hljs-literal\">true</span>;\n<span class=\"hljs-comment\">//提交方法</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">submitForm</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span>(cFlag) {\n        <span class=\"hljs-comment\">//首次点击进入方法直接关闭开关</span>\n        cFlag = <span class=\"hljs-literal\">false</span>;\n        <span class=\"hljs-comment\">//执行后续ajax提交逻辑</span>\n        <span class=\"hljs-comment\">//略</span>\n    }<span class=\"hljs-keyword\">else</span>{\n        <span class=\"hljs-comment\">//如果希望增加一些友情提示可以增加else分支</span>\n        <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&#x27;请勿频繁提交&#x27;</span>);\n    }\n}\n</code></pre>\n<h1 id=\"menu_3\">限定时间或返回数据后放开限制</h1><p>如果界面的按钮可以点击多次，但是想限制重复点击的时间。</p>\n<p>我们可以在代码中增加一个恢复开关的语句</p>\n<p>实例代码如下：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//默认点击开关打开</span>\n<span class=\"hljs-keyword\">var</span> cFlag = <span class=\"hljs-literal\">true</span>;\n<span class=\"hljs-comment\">//提交方法</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">submitForm</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span>(cFlag) {\n        <span class=\"hljs-comment\">//首次点击进入方法直接关闭开关</span>\n        cFlag = <span class=\"hljs-literal\">false</span>;\n        <span class=\"hljs-comment\">//执行后续提交ajax逻辑</span>\n        <span class=\"hljs-comment\">//返回数据后放开限制的场景，可以再ajax的返回方法中添加cFlag = true;</span>\n        <span class=\"hljs-comment\">//代码执行完后增加定时恢复开关</span>\n        <span class=\"hljs-comment\">//5秒钟恢复点击开关</span>\n        <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>){cFlag = <span class=\"hljs-literal\">true</span>;}, <span class=\"hljs-number\">5000</span>);\n    }<span class=\"hljs-keyword\">else</span>{\n        <span class=\"hljs-comment\">//如果希望增加一些友情提示可以增加else分支 </span>\n        <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&#x27;重复提交需要等待5秒&#x27;</span>);\n    } \n}\n</code></pre>\n<h1 id=\"menu_4\">限制时间优化提示</h1><p>如某功能按钮需要间隔30秒提交一次，时间过去15秒后，用户点击了给予提示还需要等待15秒。</p>\n<p>该能力不建议完全通过JS实现（可以通过服务端来计算时间直接返回提示）。</p>\n<p>并不是JS不能够实现，如果用户在10秒的时候刷新一下页面，计时就会被重置，这个限制就相当于存在漏洞。</p>\n<p>但对于流程性强的页面实际还是可以使用的，因为这类页面一旦刷新就需要用户从头操作。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//提交按钮触发</span>\n$(<span class=\"hljs-string\">&#x27;#submit&#x27;</span>).<span class=\"hljs-title function_\">click</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">var</span> nowTime = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>().<span class=\"hljs-title function_\">getTime</span>();\n    <span class=\"hljs-comment\">//给这个按钮增加一个点击事件的属性</span>\n    <span class=\"hljs-keyword\">var</span> clickTime = $(<span class=\"hljs-variable language_\">this</span>).<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;clickTime&#x27;</span>);\n    <span class=\"hljs-comment\">//存在点击时间说明被点击过，判断当前时间和单击时间 </span>\n    <span class=\"hljs-keyword\">if</span>( clickTime != <span class=\"hljs-string\">&quot;undefined&quot;</span> &amp;&amp; (nowTime - clickTime &lt; <span class=\"hljs-number\">30000</span>)) {\n        <span class=\"hljs-keyword\">var</span> waitTime = <span class=\"hljs-number\">30000</span> - nowTime + clickTime;\n        waitTime = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-built_in\">parseInt</span>(waitTime/<span class=\"hljs-number\">1000</span>);\n        <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&#x27;您需要在&#x27;</span>+waitTime+<span class=\"hljs-string\">&#x27;秒后方可提交&#x27;</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }<span class=\"hljs-keyword\">else</span>{\n        <span class=\"hljs-comment\">//刷新最新的点击时间</span>\n        $(<span class=\"hljs-variable language_\">this</span>).<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;clickTime&#x27;</span>, nowTime);\n        <span class=\"hljs-comment\">//执行后续提交逻辑</span>\n        <span class=\"hljs-comment\">//略</span>\n    }\n});\n</code></pre>\n<h1 id=\"menu_5\">结尾小结</h1><p>预防频繁点击可以减少数据库产生冗余数据的风险。</p>\n<p>由于频繁点击产生的报错可能会覆盖首次点击的正常返回信息，会给用户造成很大的困扰。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">误操作场景描述</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">只许一次</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">限定时间或返回数据后放开限制</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">限制时间优化提示</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">结尾小结</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1038, '# pagefile.sys文件\n\npagefile.sys是Windows系统创建的虚拟内存页面文件。\n\npagefile.sys是系统依据当前所使用的虚拟内存大小来决定的，一般来说你开启的软件程序越多，这个文件就越大。\n\npagefile.sys同时带有“系统”和“隐含”两种属性。\n\n因此只有在“文件夹”选项窗口中，同时开启显示隐含文件和系统文件的选项，才能看到此文件。\n\n## pagefile.sys文件删除？\n\n因为电脑分区时，C盘仅放了50G，发现pagefile.sys占用了16G，因此想删掉pagefile.sys文件。\n\n系统运行其间，pagefile.sys文件被系统锁定，无法被删除。\n\n如果用另一个系统启动机器，则可以删除当前不共享的pagefile.sys文件。\n\npagefile.sys文件被删除后，如果再次启动其所在系统，只要系统设置中的页面文件设置没有关闭，系统还会自动重建该文件。\n\n# 如何修改虚拟内存设置\n\n如果机器的物理内存足够可以禁用该配置（不推荐），如果不设置虚拟内存的话，系统就容易出现“虚拟内存不足”的提示。\n\n比如打开PS这类软件，会占用大量内存，物理内存未必够用。\n\n## 禁用虚拟内存（不推荐）\n\n1. regedit.exe（注册表编辑器）\n2. HKEY_LOCAL_MACHINESYSTEMCurrentControlSetControlSession ManagerMemory Management\n3. 键：DisablePagingExecutive修改数值数据为1\n\n## 修改虚拟内存配置（合理降低）\n\n1. 右击[我的电脑]-[属性]，或[控制面板]-[系统]，打开【系统属性】窗口，点击高级选项卡\n2. 点击性能中的[设置]，打开【性能选项】窗口\n3. 点击【性能选项】窗口的高级选项卡\n4. 点击虚拟内存中的[更改]，打开【虚拟内存】窗口\n5. 去勾[自动管理]，可以自定义文件大小（最小值和最大值）、托管磁盘位置（比如放到D盘）\n6. 设置完成后未必点击一下[设置]按钮为其生效，全部设置完成点击[确定]\n\n\n![/static/upload/post/1646023916300.png](/static/upload/post/1646023916300.png)\n\n![/static/upload/post/1646023922553.png](/static/upload/post/1646023922553.png)\n\n![/static/upload/post/1646023928492.png](/static/upload/post/1646023928492.png)\n\n\n# 配置实例\n\n虚拟内存文件配置到D盘，最小4000M最大20000M。\n\n# 生效说明\n\n配置完成后，重启后方可生效。\n\n![/static/upload/post/1646023939289.png](/static/upload/post/1646023939289.png)\n', '<h1 id=\"menu_1\">pagefile.sys文件</h1><p>pagefile.sys是Windows系统创建的虚拟内存页面文件。</p>\n<p>pagefile.sys是系统依据当前所使用的虚拟内存大小来决定的，一般来说你开启的软件程序越多，这个文件就越大。</p>\n<p>pagefile.sys同时带有“系统”和“隐含”两种属性。</p>\n<p>因此只有在“文件夹”选项窗口中，同时开启显示隐含文件和系统文件的选项，才能看到此文件。</p>\n<h2 id=\"menu_2\">pagefile.sys文件删除？</h2><p>因为电脑分区时，C盘仅放了50G，发现pagefile.sys占用了16G，因此想删掉pagefile.sys文件。</p>\n<p>系统运行其间，pagefile.sys文件被系统锁定，无法被删除。</p>\n<p>如果用另一个系统启动机器，则可以删除当前不共享的pagefile.sys文件。</p>\n<p>pagefile.sys文件被删除后，如果再次启动其所在系统，只要系统设置中的页面文件设置没有关闭，系统还会自动重建该文件。</p>\n<h1 id=\"menu_3\">如何修改虚拟内存设置</h1><p>如果机器的物理内存足够可以禁用该配置（不推荐），如果不设置虚拟内存的话，系统就容易出现“虚拟内存不足”的提示。</p>\n<p>比如打开PS这类软件，会占用大量内存，物理内存未必够用。</p>\n<h2 id=\"menu_4\">禁用虚拟内存（不推荐）</h2><ol>\n<li>regedit.exe（注册表编辑器）</li>\n<li>HKEY_LOCAL_MACHINESYSTEMCurrentControlSetControlSession ManagerMemory Management</li>\n<li>键：DisablePagingExecutive修改数值数据为1</li>\n</ol>\n<h2 id=\"menu_5\">修改虚拟内存配置（合理降低）</h2><ol>\n<li>右击[我的电脑]-[属性]，或[控制面板]-[系统]，打开【系统属性】窗口，点击高级选项卡</li>\n<li>点击性能中的[设置]，打开【性能选项】窗口</li>\n<li>点击【性能选项】窗口的高级选项卡</li>\n<li>点击虚拟内存中的[更改]，打开【虚拟内存】窗口</li>\n<li>去勾[自动管理]，可以自定义文件大小（最小值和最大值）、托管磁盘位置（比如放到D盘）</li>\n<li>设置完成后未必点击一下[设置]按钮为其生效，全部设置完成点击[确定]</li>\n</ol>\n<p><img src=\"/static/upload/post/1646023916300.png\" alt=\"/static/upload/post/1646023916300.png\"/></p>\n<p><img src=\"/static/upload/post/1646023922553.png\" alt=\"/static/upload/post/1646023922553.png\"/></p>\n<p><img src=\"/static/upload/post/1646023928492.png\" alt=\"/static/upload/post/1646023928492.png\"/></p>\n<h1 id=\"menu_6\">配置实例</h1><p>虚拟内存文件配置到D盘，最小4000M最大20000M。</p>\n<h1 id=\"menu_7\">生效说明</h1><p>配置完成后，重启后方可生效。</p>\n<p><img src=\"/static/upload/post/1646023939289.png\" alt=\"/static/upload/post/1646023939289.png\"/></p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">pagefile.sys文件</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">pagefile.sys文件删除？</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">如何修改虚拟内存设置</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">禁用虚拟内存（不推荐）</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">修改虚拟内存配置（合理降低）</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl1\">配置实例</a> <!----></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl1\">生效说明</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1039, '# 语句作用\n\n1. DELETE：\n	DELETE语句删除满足条件的row数据\n2. TRUNCATE：\n	TRUNCATE语句一次性地从表中删除所有的数据\n3. DROP：\n	DROP语句删除表结构以及数据\n\n## 执行方式\n\n1. DELETE语句\n	执行删除的过程是每次从表中删除一行，同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操\n2. TRUNCATE语句\n	一次性地删除所有数据，不会将删除操作记录记入日志保存，不能恢复的，不会激活与表有关的删除触发器\n3. DROP语句\n	删除表结构及所有数据，同时删除表的结构所依赖的约束、触发器、索引，依赖于该表的存储过程/函数将保留变为invalid状态\n\n## 表和索引所占空间\n\n1. DELETE语句\n	不会减少表或索引所占用的空间\n2. TRUNCATE语句\n	表和索引所占用的空间会恢复到初始大小\n3. DROP语句\n	表所占用的空间全部释放\n\n## 作用对象\n\n1. DELETE语句\n	可以是table（表）和view（视图）\n2. TRUNCATE语句\n	仅可以是table（表）\n3. DROP语句\n	可以是table（表）和view（视图）\n\n# DML和DLL\n\n- DML（data manipulation language）数据操纵语言\n- DDL（data definition language）数据库定义语言\n\nDELETE语句属于DML，可以带WHERE条件，操作会被放到 rollback segment中，事务提交后才生效\n\nTRUNCATE语句和DROP语句属于DDL，操作立即生效，隐式提交，不可回滚（因此应当谨慎使用)\n\n## DELETE和TRUNCATE\n\nDELETE语句和TRUNCATE语句都能实现删除表中的全部数据（DELETE语句不加WHERE条件时）\n\n - TRUNCATE语句\n	速度快，使用的系统和事务日志资源少。\n	因为DELETE语句每次删除一行，在事务日志中为所删除的每行记录一项。\n - TRUNCATE语句\n	通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 \n	删除表中的所有行，表结构及其列、约束、索引等保持不变，但是新行标识所用的计数值重置为该列的种子。\n\n如果想保留标识计数值，请改用DELETE语句。\n\n比如MYSQL的自增值使用TRUNCATE语句删除后新行会变成1，而DELETE语句删除后新行依旧继续+1。\n\n如果想触发trigger,需要使用DELETE语句，因为TRUNCATE语句不会激活与表有关的删除触发器。\n\n# 其他\n\n1. DROP > TRUNCATE > DELETE。\n2. 使用DROP语句和TRUNCATE语句需谨慎。\n3. 删除部分数据用DELETE语句，注意带上WHERE子句。\n4. 删除表，当然用DROP语句。\n5. 保留表而将所有数据删除，事务无关，用TRUNCATE语句，效率高。\n6. 保留表而将所有数据删除，和事务有关或想触发trigger，用DElETE语句。## ', '<h1 id=\"menu_1\">语句作用</h1><ol>\n<li>DELETE：<br/> DELETE语句删除满足条件的row数据</li>\n<li>TRUNCATE：<br/> TRUNCATE语句一次性地从表中删除所有的数据</li>\n<li>DROP：<br/> DROP语句删除表结构以及数据</li>\n</ol>\n<h2 id=\"menu_2\">执行方式</h2><ol>\n<li>DELETE语句<br/> 执行删除的过程是每次从表中删除一行，同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操</li>\n<li>TRUNCATE语句<br/> 一次性地删除所有数据，不会将删除操作记录记入日志保存，不能恢复的，不会激活与表有关的删除触发器</li>\n<li>DROP语句<br/> 删除表结构及所有数据，同时删除表的结构所依赖的约束、触发器、索引，依赖于该表的存储过程/函数将保留变为invalid状态</li>\n</ol>\n<h2 id=\"menu_3\">表和索引所占空间</h2><ol>\n<li>DELETE语句<br/> 不会减少表或索引所占用的空间</li>\n<li>TRUNCATE语句<br/> 表和索引所占用的空间会恢复到初始大小</li>\n<li>DROP语句<br/> 表所占用的空间全部释放</li>\n</ol>\n<h2 id=\"menu_4\">作用对象</h2><ol>\n<li>DELETE语句<br/> 可以是table（表）和view（视图）</li>\n<li>TRUNCATE语句<br/> 仅可以是table（表）</li>\n<li>DROP语句<br/> 可以是table（表）和view（视图）</li>\n</ol>\n<h1 id=\"menu_5\">DML和DLL</h1><ul>\n<li>DML（data manipulation language）数据操纵语言</li>\n<li>DDL（data definition language）数据库定义语言</li>\n</ul>\n<p>DELETE语句属于DML，可以带WHERE条件，操作会被放到 rollback segment中，事务提交后才生效</p>\n<p>TRUNCATE语句和DROP语句属于DDL，操作立即生效，隐式提交，不可回滚（因此应当谨慎使用)</p>\n<h2 id=\"menu_6\">DELETE和TRUNCATE</h2><p>DELETE语句和TRUNCATE语句都能实现删除表中的全部数据（DELETE语句不加WHERE条件时）</p>\n<ul>\n<li>TRUNCATE语句<br/> 速度快，使用的系统和事务日志资源少。<br/> 因为DELETE语句每次删除一行，在事务日志中为所删除的每行记录一项。</li>\n<li>TRUNCATE语句<br/> 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。<br/> 删除表中的所有行，表结构及其列、约束、索引等保持不变，但是新行标识所用的计数值重置为该列的种子。</li>\n</ul>\n<p>如果想保留标识计数值，请改用DELETE语句。</p>\n<p>比如MYSQL的自增值使用TRUNCATE语句删除后新行会变成1，而DELETE语句删除后新行依旧继续+1。</p>\n<p>如果想触发trigger,需要使用DELETE语句，因为TRUNCATE语句不会激活与表有关的删除触发器。</p>\n<h1 id=\"menu_7\">其他</h1><ol>\n<li>DROP &gt; TRUNCATE &gt; DELETE。</li>\n<li>使用DROP语句和TRUNCATE语句需谨慎。</li>\n<li>删除部分数据用DELETE语句，注意带上WHERE子句。</li>\n<li>删除表，当然用DROP语句。</li>\n<li>保留表而将所有数据删除，事务无关，用TRUNCATE语句，效率高。</li>\n<li>保留表而将所有数据删除，和事务有关或想触发trigger，用DElETE语句。## </li>\n</ol>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">语句作用</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">执行方式</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">表和索引所占空间</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">作用对象</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">DML和DLL</a> <ul><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">DELETE和TRUNCATE</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl1\">其他</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1040, '# 关于php-fpm\n\nphp-fpm(PHP FastCGI Process Manager)。\n\n - 名称：PHP FastCGI 进程管理器\n - 作用：管理PHP进程池的软件，用于接受web服务器的请求\n\nphp-fpm提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置。\n\nphp-fpm的出现全部因为php-fastcgi出现，为了很好的管理php-fastcgi而实现的一个程序。\n\nphp-fastcgi只是一个cgi程序，只会解析php请求，并且返回结果，不会管理（因此才出现了php-fpm）。\n\n# 高内存占用\n\n网站访问相应503错误，很大可能由于内存不足导致。\n\n但如像米虫是2G内存云服务器，跑一个博客网站出现内存不足，是明显不应该的。\n\n进入Linux后台发现，内存占用92%！！！\n\nWhat？黑人问号？？？\n\n使用top命令分析发现，php-fpm占用了大量的内存，启用了大量的进程，特别是大量空闲进程。\n\n一般一个php-fpm子进程约占用1%-5%的内存，50个直接就占用至少70%左右的内存。\n\n这样明显得资源浪费真是何等的卧槽...\n\n如下部分内存数据：\n\n```shell\nPID		名称		CPU		内存	读/写				状态		线程	用户\n3638	php-fpm		0%  	1.961%	4.12 MB/15.21 MB	sleeping	1		www\n3673	php-fpm		0%		4.267%	2.47 MB/12.49 MB	sleeping	1		www \n3636	php-fpm		0%		5.526%	103.24 MB/12.20 MB	sleeping	1		www\n3639	php-fpm		0%		1.884%	272.00 KB/14.80 MB	sleeping	1		www\n3640	php-fpm		0%		4.503%	1.13 MB/14.27 MB	sleeping	1		www\n3635	php-fpm		0%		4.936%	16.62 MB/11.50 MB	sleeping	1		www\n3633	php-fpm		0%		5.367%	1.53 MB/11.08 MB	sleeping	1		www   \n3637	php-fpm		0%		2.627%	1.05 MB/14.96 MB	sleeping	1		www\n3642	php-fpm		0%		2.049%	1.74 MB/8.32 MB		sleeping	1		www\n3634	php-fpm		0%		2.522%	1.13 MB/14.23MB		sleeping	1		www\n3791	php-fpm		0%		1.797%	144.00 KB/11.27 MB	sleeping	1		www\n```  \n\n# 进程配置\n\n**vi /etc/php-fpm.d/`www.conf`**\n\n```shell\n#允许创建的最大子进程数\nmax_children：25\n#起始进程数（服务启动后初始进程数量）\nstart_servers：10\n#最小空闲进程数（清理空闲进程后的保留数量）\nmin_spare_servers：8\n#最大空闲进程数（当空闲进程达到此值时清理）\nmax_spare_servers：20\n```\n\n处理完成后，减少空闲线程池数量，避免过多的空闲线程启动浪费资源，内存恢复正常\n\n## 宝塔面板修改\n\n如果您的环境通过宝塔面板配置，该面板提供了直接的入口进行修改软件管理。\n\n- 运行环境\n- 选择你启用的PHP\n- 设置\n- 性能调整', '<h1 id=\"menu_1\">关于php-fpm</h1><p>php-fpm(PHP FastCGI Process Manager)。</p>\n<ul>\n<li>名称：PHP FastCGI 进程管理器</li>\n<li>作用：管理PHP进程池的软件，用于接受web服务器的请求</li>\n</ul>\n<p>php-fpm提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置。</p>\n<p>php-fpm的出现全部因为php-fastcgi出现，为了很好的管理php-fastcgi而实现的一个程序。</p>\n<p>php-fastcgi只是一个cgi程序，只会解析php请求，并且返回结果，不会管理（因此才出现了php-fpm）。</p>\n<h1 id=\"menu_2\">高内存占用</h1><p>网站访问相应503错误，很大可能由于内存不足导致。</p>\n<p>但如像米虫是2G内存云服务器，跑一个博客网站出现内存不足，是明显不应该的。</p>\n<p>进入Linux后台发现，内存占用92%！！！</p>\n<p>What？黑人问号？？？</p>\n<p>使用top命令分析发现，php-fpm占用了大量的内存，启用了大量的进程，特别是大量空闲进程。</p>\n<p>一般一个php-fpm子进程约占用1%-5%的内存，50个直接就占用至少70%左右的内存。</p>\n<p>这样明显得资源浪费真是何等的卧槽...</p>\n<p>如下部分内存数据：</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-string\">PID</span>        <span class=\"hljs-string\">名称</span>        <span class=\"hljs-string\">CPU</span>        <span class=\"hljs-string\">内存</span>    <span class=\"hljs-string\">读/写</span>                <span class=\"hljs-string\">状态</span>        <span class=\"hljs-string\">线程</span>    <span class=\"hljs-string\">用户</span>\n<span class=\"hljs-number\">3638    </span><span class=\"hljs-string\">php-fpm</span>        <span class=\"hljs-number\">0</span><span class=\"hljs-string\">%</span>      <span class=\"hljs-number\">1.961</span><span class=\"hljs-string\">%</span>    <span class=\"hljs-number\">4.12</span> <span class=\"hljs-string\">MB/15.21</span> <span class=\"hljs-string\">MB</span>    <span class=\"hljs-string\">sleeping</span>    <span class=\"hljs-number\">1</span>        <span class=\"hljs-string\">www</span>\n<span class=\"hljs-number\">3673    </span><span class=\"hljs-string\">php-fpm</span>        <span class=\"hljs-number\">0</span><span class=\"hljs-string\">%</span>        <span class=\"hljs-number\">4.267</span><span class=\"hljs-string\">%</span>    <span class=\"hljs-number\">2.47</span> <span class=\"hljs-string\">MB/12.49</span> <span class=\"hljs-string\">MB</span>    <span class=\"hljs-string\">sleeping</span>    <span class=\"hljs-number\">1</span>        <span class=\"hljs-string\">www</span> \n<span class=\"hljs-number\">3636    </span><span class=\"hljs-string\">php-fpm</span>        <span class=\"hljs-number\">0</span><span class=\"hljs-string\">%</span>        <span class=\"hljs-number\">5.526</span><span class=\"hljs-string\">%</span>    <span class=\"hljs-number\">103.24</span> <span class=\"hljs-string\">MB/12.20</span> <span class=\"hljs-string\">MB</span>    <span class=\"hljs-string\">sleeping</span>    <span class=\"hljs-number\">1</span>        <span class=\"hljs-string\">www</span>\n<span class=\"hljs-number\">3639    </span><span class=\"hljs-string\">php-fpm</span>        <span class=\"hljs-number\">0</span><span class=\"hljs-string\">%</span>        <span class=\"hljs-number\">1.884</span><span class=\"hljs-string\">%</span>    <span class=\"hljs-number\">272.00</span> <span class=\"hljs-string\">KB/14.80</span> <span class=\"hljs-string\">MB</span>    <span class=\"hljs-string\">sleeping</span>    <span class=\"hljs-number\">1</span>        <span class=\"hljs-string\">www</span>\n<span class=\"hljs-number\">3640    </span><span class=\"hljs-string\">php-fpm</span>        <span class=\"hljs-number\">0</span><span class=\"hljs-string\">%</span>        <span class=\"hljs-number\">4.503</span><span class=\"hljs-string\">%</span>    <span class=\"hljs-number\">1.13</span> <span class=\"hljs-string\">MB/14.27</span> <span class=\"hljs-string\">MB</span>    <span class=\"hljs-string\">sleeping</span>    <span class=\"hljs-number\">1</span>        <span class=\"hljs-string\">www</span>\n<span class=\"hljs-number\">3635    </span><span class=\"hljs-string\">php-fpm</span>        <span class=\"hljs-number\">0</span><span class=\"hljs-string\">%</span>        <span class=\"hljs-number\">4.936</span><span class=\"hljs-string\">%</span>    <span class=\"hljs-number\">16.62</span> <span class=\"hljs-string\">MB/11.50</span> <span class=\"hljs-string\">MB</span>    <span class=\"hljs-string\">sleeping</span>    <span class=\"hljs-number\">1</span>        <span class=\"hljs-string\">www</span>\n<span class=\"hljs-number\">3633    </span><span class=\"hljs-string\">php-fpm</span>        <span class=\"hljs-number\">0</span><span class=\"hljs-string\">%</span>        <span class=\"hljs-number\">5.367</span><span class=\"hljs-string\">%</span>    <span class=\"hljs-number\">1.53</span> <span class=\"hljs-string\">MB/11.08</span> <span class=\"hljs-string\">MB</span>    <span class=\"hljs-string\">sleeping</span>    <span class=\"hljs-number\">1</span>        <span class=\"hljs-string\">www</span>   \n<span class=\"hljs-number\">3637    </span><span class=\"hljs-string\">php-fpm</span>        <span class=\"hljs-number\">0</span><span class=\"hljs-string\">%</span>        <span class=\"hljs-number\">2.627</span><span class=\"hljs-string\">%</span>    <span class=\"hljs-number\">1.05</span> <span class=\"hljs-string\">MB/14.96</span> <span class=\"hljs-string\">MB</span>    <span class=\"hljs-string\">sleeping</span>    <span class=\"hljs-number\">1</span>        <span class=\"hljs-string\">www</span>\n<span class=\"hljs-number\">3642    </span><span class=\"hljs-string\">php-fpm</span>        <span class=\"hljs-number\">0</span><span class=\"hljs-string\">%</span>        <span class=\"hljs-number\">2.049</span><span class=\"hljs-string\">%</span>    <span class=\"hljs-number\">1.74</span> <span class=\"hljs-string\">MB/8.32</span> <span class=\"hljs-string\">MB</span>        <span class=\"hljs-string\">sleeping</span>    <span class=\"hljs-number\">1</span>        <span class=\"hljs-string\">www</span>\n<span class=\"hljs-number\">3634    </span><span class=\"hljs-string\">php-fpm</span>        <span class=\"hljs-number\">0</span><span class=\"hljs-string\">%</span>        <span class=\"hljs-number\">2.522</span><span class=\"hljs-string\">%</span>    <span class=\"hljs-number\">1.13</span> <span class=\"hljs-string\">MB/14.23MB</span>        <span class=\"hljs-string\">sleeping</span>    <span class=\"hljs-number\">1</span>        <span class=\"hljs-string\">www</span>\n<span class=\"hljs-number\">3791    </span><span class=\"hljs-string\">php-fpm</span>        <span class=\"hljs-number\">0</span><span class=\"hljs-string\">%</span>        <span class=\"hljs-number\">1.797</span><span class=\"hljs-string\">%</span>    <span class=\"hljs-number\">144.00</span> <span class=\"hljs-string\">KB/11.27</span> <span class=\"hljs-string\">MB</span>    <span class=\"hljs-string\">sleeping</span>    <span class=\"hljs-number\">1</span>        <span class=\"hljs-string\">www</span>\n</code></pre>\n<h1 id=\"menu_3\">进程配置</h1><p><strong>vi /etc/php-fpm.d/<code>www.conf</code></strong></p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-comment\">#允许创建的最大子进程数</span>\nmax_children：<span class=\"hljs-number\">25</span>\n<span class=\"hljs-comment\">#起始进程数（服务启动后初始进程数量）</span>\nstart_servers：<span class=\"hljs-number\">10</span>\n<span class=\"hljs-comment\">#最小空闲进程数（清理空闲进程后的保留数量）</span>\nmin_spare_servers：<span class=\"hljs-number\">8</span>\n<span class=\"hljs-comment\">#最大空闲进程数（当空闲进程达到此值时清理）</span>\nmax_spare_servers：<span class=\"hljs-number\">20</span>\n</code></pre>\n<p>处理完成后，减少空闲线程池数量，避免过多的空闲线程启动浪费资源，内存恢复正常</p>\n<h2 id=\"menu_4\">宝塔面板修改</h2><p>如果您的环境通过宝塔面板配置，该面板提供了直接的入口进行修改软件管理。</p>\n<ul>\n<li>运行环境</li>\n<li>选择你启用的PHP</li>\n<li>设置</li>\n<li>性能调整</li>\n</ul>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">关于php-fpm</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">高内存占用</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">进程配置</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">宝塔面板修改</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1041, '# substr()函数\n\n语法：substr(string,start,length)\n\n说明：substr(字符串,开始坐标,长度)\n\n```php\n$str = \'米虫先生真是个大帅比\';\necho substr($str,0,12);\n//输出结果为“米虫先生”\n```\n\n上面案例中明明输入了12位但实际只出现4个字？\n\n中文UTF-8编码，每个汉字占3字节（一般情况下服务器都会习惯采用UTF编码）。\n\n当然如果GB2312编码模式先，中文占2字节。\n\n而英文则占1字节，基本上大部分编码模式下皆是如此。\n\n## 乱码问题\n\n从上面结果里看，如果我指定长度为3的倍数一般不会有问题？\n\n如果你的文本确认全是中文一般不会出现乱码问题，但如果字符串中包含英文、数字或者半角符号...\n\n那在长度结尾处，substr()函数很有可能硬生生地将一个中文字符“锯”成两半，因此就产生了乱码问题。\n\n# mb_substr()函数\n\n语法：substr(string,start,length,codetype)\n\n说明：substr(字符串,开始坐标,长度,编码方式)\n\n```php\n$str = \'米虫先生真是个大帅比\';\necho mb_substr($str,0,4,\'UTF-8\');\n//输出结果为“米虫先生”\n```\n\n## 为什么不会乱码\n\nmbstring()函数截取内容时填入的长度为真实长度，即所见即所得的长度。\n\n但需要指定正确的字符集，函数会依照字符集对具体的内容进行字节单元的截取。\n\n```php\n$str = \'米虫Sir真是个大帅比\';\n//输出结果为“米虫Sir”\n//并不会因为中英文混合场景进行长度计算\necho mb_substr($str,0,5,\'UTF-8\');\n```\n\n# 关于网页字符集指定\n\nmb_substr()函数来自mbstring扩展库，mb_strcut()也可以达成该效果。\n\n使用mb_substr()函数的时候要注意php文件的编码以及网页显示时的编码。\n\n建议统一使用UTF-8编码。\n\n尽量不要通过txt打开或编写PHP和HTML文件。\n\n```html\n<!DOCTYPE HTML>\n<html>\n<head>\n	<!-- 指定网页编码 -->\n    <meta charset=\"UTF-8\">\n</head>\n<body>\n</body>\n</html>\n```', '<h1 id=\"menu_1\">substr()函数</h1><p>语法：substr(string,start,length)</p>\n<p>说明：substr(字符串,开始坐标,长度)</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-variable\">$str</span> = <span class=\"hljs-string\">&#x27;米虫先生真是个大帅比&#x27;</span>;\n<span class=\"hljs-keyword\">echo</span> substr(<span class=\"hljs-variable\">$str</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">12</span>);\n<span class=\"hljs-comment\">//输出结果为“米虫先生”</span>\n</code></pre>\n<p>上面案例中明明输入了12位但实际只出现4个字？</p>\n<p>中文UTF-8编码，每个汉字占3字节（一般情况下服务器都会习惯采用UTF编码）。</p>\n<p>当然如果GB2312编码模式先，中文占2字节。</p>\n<p>而英文则占1字节，基本上大部分编码模式下皆是如此。</p>\n<h2 id=\"menu_2\">乱码问题</h2><p>从上面结果里看，如果我指定长度为3的倍数一般不会有问题？</p>\n<p>如果你的文本确认全是中文一般不会出现乱码问题，但如果字符串中包含英文、数字或者半角符号...</p>\n<p>那在长度结尾处，substr()函数很有可能硬生生地将一个中文字符“锯”成两半，因此就产生了乱码问题。</p>\n<h1 id=\"menu_3\">mb_substr()函数</h1><p>语法：substr(string,start,length,codetype)</p>\n<p>说明：substr(字符串,开始坐标,长度,编码方式)</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-variable\">$str</span> = <span class=\"hljs-string\">&#x27;米虫先生真是个大帅比&#x27;</span>;\n<span class=\"hljs-keyword\">echo</span> mb_substr(<span class=\"hljs-variable\">$str</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-string\">&#x27;UTF-8&#x27;</span>);\n<span class=\"hljs-comment\">//输出结果为“米虫先生”</span>\n</code></pre>\n<h2 id=\"menu_4\">为什么不会乱码</h2><p>mbstring()函数截取内容时填入的长度为真实长度，即所见即所得的长度。</p>\n<p>但需要指定正确的字符集，函数会依照字符集对具体的内容进行字节单元的截取。</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-variable\">$str</span> = <span class=\"hljs-string\">&#x27;米虫Sir真是个大帅比&#x27;</span>;\n<span class=\"hljs-comment\">//输出结果为“米虫Sir”</span>\n<span class=\"hljs-comment\">//并不会因为中英文混合场景进行长度计算</span>\n<span class=\"hljs-keyword\">echo</span> mb_substr(<span class=\"hljs-variable\">$str</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-string\">&#x27;UTF-8&#x27;</span>);\n</code></pre>\n<h1 id=\"menu_5\">关于网页字符集指定</h1><p>mb_substr()函数来自mbstring扩展库，mb_strcut()也可以达成该效果。</p>\n<p>使用mb_substr()函数的时候要注意php文件的编码以及网页显示时的编码。</p>\n<p>建议统一使用UTF-8编码。</p>\n<p>尽量不要通过txt打开或编写PHP和HTML文件。</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">HTML</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 指定网页编码 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">substr()函数</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">乱码问题</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">mb_substr()函数</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">为什么不会乱码</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">关于网页字符集指定</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1042, '# 文本超出省略目标效果\n\n我是一个超级长超级长超级长超级长超级长的标题\n\n我是一个超级长超级长超级长超级...\n\n当文本超过宽度是进行省略并追加省略号\n\n# 单行省略样式\n\n单行省略一般用于标题\n\n```css\nh1{\n	/*超出隐藏*/\n	overflow: hidden;\n	/*文本超出显示为省略号*/\n	text-overflow:ellipsis;\n	/*文本不换行*/\n	white-space: nowrap; \n}\n```\n# 多行超出省略号\n\n多行超出，可以动态设计几行进行超出省略。\n\n一般用于列表也显示描述的时候。\n\n```css\np{\n	/*超出隐藏*/\n	overflow: hidden;\n	/*文本超出显示为省略号*/\n	text-overflow: ellipsis; \n	/*自适应盒子模型*/\n	display: -webkit-box;\n	/*行数2*/\n	-webkit-line-clamp: 2;\n	/*顶部向底部垂直布置子元素*/\n	-webkit-box-orient: vertical;\n	/*为了保证准确建议增加以下配置*/\n	/*行高*/\n	line-height: 25px;\n	/*总高*/\n	height: 50px;\n}\n```\n\n## -webkit-box-orient: vertical\n\n-webkit-box-orient: vertical属性在某些时候可能不生效\n\n比如：VUE打包后-webkit-box-orient: vertical; 样式消失，原因是Vue打包的时候，过滤了部分css。\n\n```css\np{\n	/*超出隐藏*/\n	overflow: hidden;\n	/*文本超出显示为省略号*/\n	text-overflow: ellipsis; \n	/*自适应盒子模型*/\n	display: -webkit-box;\n	/*行数2*/\n	-webkit-line-clamp: 2;\n	/*顶部向底部垂直布置子元素*/\n	/* autoprefixer: off */\n	-webkit-box-orient: vertical;\n	/* autoprefixer: on */\n	/*为了保证准确建议增加以下配置*/\n	line-height: 25px;\n	height: 50px;\n}\n```', '<h1 id=\"menu_1\">文本超出省略目标效果</h1><p>我是一个超级长超级长超级长超级长超级长的标题</p>\n<p>我是一个超级长超级长超级长超级...</p>\n<p>当文本超过宽度是进行省略并追加省略号</p>\n<h1 id=\"menu_2\">单行省略样式</h1><p>单行省略一般用于标题</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">h1</span>{\n    <span class=\"hljs-comment\">/*超出隐藏*/</span>\n    <span class=\"hljs-attribute\">overflow</span>: hidden;\n    <span class=\"hljs-comment\">/*文本超出显示为省略号*/</span>\n    <span class=\"hljs-attribute\">text-overflow</span>:ellipsis;\n    <span class=\"hljs-comment\">/*文本不换行*/</span>\n    <span class=\"hljs-attribute\">white-space</span>: nowrap; \n}\n</code></pre>\n<h1 id=\"menu_3\">多行超出省略号</h1><p>多行超出，可以动态设计几行进行超出省略。</p>\n<p>一般用于列表也显示描述的时候。</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">p</span>{\n    <span class=\"hljs-comment\">/*超出隐藏*/</span>\n    <span class=\"hljs-attribute\">overflow</span>: hidden;\n    <span class=\"hljs-comment\">/*文本超出显示为省略号*/</span>\n    <span class=\"hljs-attribute\">text-overflow</span>: ellipsis; \n    <span class=\"hljs-comment\">/*自适应盒子模型*/</span>\n    <span class=\"hljs-attribute\">display</span>: -webkit-box;\n    <span class=\"hljs-comment\">/*行数2*/</span>\n    -webkit-line-clamp: <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-comment\">/*顶部向底部垂直布置子元素*/</span>\n    -webkit-box-orient: vertical;\n    <span class=\"hljs-comment\">/*为了保证准确建议增加以下配置*/</span>\n    <span class=\"hljs-comment\">/*行高*/</span>\n    <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">25px</span>;\n    <span class=\"hljs-comment\">/*总高*/</span>\n    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">50px</span>;\n}\n</code></pre>\n<h2 id=\"menu_4\">-webkit-box-orient: vertical</h2><p>-webkit-box-orient: vertical属性在某些时候可能不生效</p>\n<p>比如：VUE打包后-webkit-box-orient: vertical; 样式消失，原因是Vue打包的时候，过滤了部分css。</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">p</span>{\n    <span class=\"hljs-comment\">/*超出隐藏*/</span>\n    <span class=\"hljs-attribute\">overflow</span>: hidden;\n    <span class=\"hljs-comment\">/*文本超出显示为省略号*/</span>\n    <span class=\"hljs-attribute\">text-overflow</span>: ellipsis; \n    <span class=\"hljs-comment\">/*自适应盒子模型*/</span>\n    <span class=\"hljs-attribute\">display</span>: -webkit-box;\n    <span class=\"hljs-comment\">/*行数2*/</span>\n    -webkit-line-clamp: <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-comment\">/*顶部向底部垂直布置子元素*/</span>\n    <span class=\"hljs-comment\">/* autoprefixer: off */</span>\n    -webkit-box-orient: vertical;\n    <span class=\"hljs-comment\">/* autoprefixer: on */</span>\n    <span class=\"hljs-comment\">/*为了保证准确建议增加以下配置*/</span>\n    <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">25px</span>;\n    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">50px</span>;\n}\n</code></pre>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">文本超出省略目标效果</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">单行省略样式</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">多行超出省略号</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">-webkit-box-orient: vertical</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1043, '# 关于自适应网页\n\n所谓自适应网页，通过屏幕的宽度实现加载对应的CSS样式表，提高移动终端的访问体验。\n\n自适应网页主要用于解决，PC网页在移动端显示出现字体过小、模块错位、浮动遮挡等不良体验。\n\n实际上网页无论是否进行了自适应，通过手机/平板等移动终端都是可以访问的。\n\n但是对网页做移动端自适应适配，在如今是非常有必要的。\n\n# 自适应三要素\n\n自适应网页开发简单归纳为以下三大要素：\n\n1. **选定关键屏幕宽度判断**\n	当你要开始进行自适应网页开发的时候，你需要在内心中有大致的布局，明确需要开发几套自适应的配套模板。\n	然后通过指定min-width and max-width（选定关键屏幕判断）进行CSS覆写。\n2. **宽高尽量使用百分比**\n	自适应网页更多的时候是为了给移动终端带来更好的访问体验，但是移动终端的种类繁多，特别是屏幕尺寸应有尽有。\n	你不可能对所有的宽度都开发模板，那样工作量太大而且没有意义。\n	因此如果对元素的各项px属性均指定为百分比，就可以一套自适应模板适配于各类尺寸的屏幕中。\n3. **遵循代码聚合的原则**\n	开发自适应网页需要覆写大量的CSS，在开发过程中尽量规划某一个区域专门进行代码编写。\n	否则将有可能出现大量冗余样式（特别是大量冗余的屏幕尺寸判断语句）以及样式冲突，对于后期调试极为不利。           \n\n# 自适应开发方式\n\n实际上自适应开发是一件非常简单的事情。\n\n其麻烦并不在于技术，而是对整个网页的CSS样式进行重新编写，这是一个比较浩大的工作。\n\n那么如何进行自适应开发呢？\n\n首先网页的head区域要标注一个这样的viewport元标签。 \n\n```html\n<!DOCTYPE html>\n<html lang=\"zh_CN\">\n<head>\n	<!-- 网页的宽度自动适应手机屏幕的宽度 --> \n	<!-- width=device-width ：表示宽度是设备屏幕的宽度 --> \n	<!-- initial-scale=1.0：表示初始的缩放比例，1.0就是占网页的100% -->\n	<!-- minimum-scale=1.0：表示最小的缩放比例 -->\n	<!-- maximum-scale=1.0：表示最大的缩放比例 -->\n	<!-- user-scalable=no：表示用户不可以调整缩放比例 --> \n	<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no\">\n</head>\n</html>\n```\n\n## 传统CSS覆写\n\n在原来的CSS文件中增加覆写，举例说明。\n\n案例已经完全包括了自适应开发中应用到的所有方法，比较简单。\n\n```css\n/*原始的网页样式*/ \n.container {\n	width: 1200px;\n	margin-right: auto;\n	margin-left: auto;\n	padding-left: 15px;\n	padding-right: 15px\n}\n/*当屏幕宽度小于等于991px时，一般多为手机*/ \n/*className为container的元素宽度为100%*/\n@media (max-width: 991px) {\n	.container {\n		width: 100% \n	}\n}\n/*当屏幕宽度大于等于992px且小于等于1099px时，一般多为平板*/\n/*className为container的元素宽度为90%*/\n@media (min-width: 992px) and (max-width: 1099px) {\n	.container {\n		width: 90%\n	}\n} \n/*当屏幕宽度大于等于1100px时，常规电脑*/\n/*className为container的元素宽度为1100px*/\n/*此处用于举例，实际这个样式是多余了，默认就是>1100px*/\n@media (min-width: 1100px) {\n	.container {\n		width: 1100px\n	}\n}\n```\n\n### 关于CSS覆写\n\n我们将根据CSS样式渲染生效原则，在这里简单提一下 \n\n**浏览器缺省 < 外部样式表 < 外部样式表类选择器 < 外部样式表类派生选择器 < 外部样式表ID选择器 < 外部样式表ID派生选择器 < 内部样式表 < 内部样式表类选择器 < 内部样式表类派生选择器 < 内部样式表ID选择器 < 内部样式表ID派生选择器 < 内联样式**\n\n关于这么多种样式生效类型，就不一一介绍了，这属于CSS的基础。\n\n## 完整CSS覆写\n\n定义一个全新的文件，与原来的CSS样式文件互不干扰。\n\n值得注意的是，自适应的样式表一定要放在原始样式表的下面。\n\nCSS样式渲染生效还有一个基本原则就是，**后者覆写前者（或者又称为距离元素最近的样式生效）** 。\n\n这种方式与传统方式的差异在于不需要指定大量的@media标签在CSS文件中，与源CSS样式表分开，易读性高。\n\n在开发的时候就和正常编写CSS样式一致，更为高效。\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh_CN\">\n<head>\n	<!-- 原始的样式表 -->\n	<link rel=\"stylesheet\" href=\"/static/css/index.css\">\n	<!-- 当屏幕宽度低于768px时会加载这个CSS文件 -->\n	<link rel=\"stylesheet\" href=\"/static/css/mobile.css\" media=\"screen and (max-width:768px)\">\n</head>\n</html>\n```\n\n# 结尾小结\n\n实际开发中更加推荐使用第二种开发模式：\n\n - 不需要指定大量的@media标签（判断屏幕宽度）\n - 保留的编写CSS样式表的习惯\n - 对于需要适配多种尺寸终端，只需要引用指定的CSS文件\n - 对于旧版网页改造无需破坏原有的样式，直接引入新文件即可', '<h1 id=\"menu_1\">关于自适应网页</h1><p>所谓自适应网页，通过屏幕的宽度实现加载对应的CSS样式表，提高移动终端的访问体验。</p>\n<p>自适应网页主要用于解决，PC网页在移动端显示出现字体过小、模块错位、浮动遮挡等不良体验。</p>\n<p>实际上网页无论是否进行了自适应，通过手机/平板等移动终端都是可以访问的。</p>\n<p>但是对网页做移动端自适应适配，在如今是非常有必要的。</p>\n<h1 id=\"menu_2\">自适应三要素</h1><p>自适应网页开发简单归纳为以下三大要素：</p>\n<ol>\n<li><strong>选定关键屏幕宽度判断</strong><br/> 当你要开始进行自适应网页开发的时候，你需要在内心中有大致的布局，明确需要开发几套自适应的配套模板。<br/> 然后通过指定min-width and max-width（选定关键屏幕判断）进行CSS覆写。</li>\n<li><strong>宽高尽量使用百分比</strong><br/> 自适应网页更多的时候是为了给移动终端带来更好的访问体验，但是移动终端的种类繁多，特别是屏幕尺寸应有尽有。<br/> 你不可能对所有的宽度都开发模板，那样工作量太大而且没有意义。<br/> 因此如果对元素的各项px属性均指定为百分比，就可以一套自适应模板适配于各类尺寸的屏幕中。</li>\n<li><strong>遵循代码聚合的原则</strong><br/> 开发自适应网页需要覆写大量的CSS，在开发过程中尽量规划某一个区域专门进行代码编写。<br/> 否则将有可能出现大量冗余样式（特别是大量冗余的屏幕尺寸判断语句）以及样式冲突，对于后期调试极为不利。           </li>\n</ol>\n<h1 id=\"menu_3\">自适应开发方式</h1><p>实际上自适应开发是一件非常简单的事情。</p>\n<p>其麻烦并不在于技术，而是对整个网页的CSS样式进行重新编写，这是一个比较浩大的工作。</p>\n<p>那么如何进行自适应开发呢？</p>\n<p>首先网页的head区域要标注一个这样的viewport元标签。 </p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh_CN&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 网页的宽度自动适应手机屏幕的宽度 --&gt;</span> \n    <span class=\"hljs-comment\">&lt;!-- width=device-width ：表示宽度是设备屏幕的宽度 --&gt;</span> \n    <span class=\"hljs-comment\">&lt;!-- initial-scale=1.0：表示初始的缩放比例，1.0就是占网页的100% --&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- minimum-scale=1.0：表示最小的缩放比例 --&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- maximum-scale=1.0：表示最大的缩放比例 --&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- user-scalable=no：表示用户不可以调整缩放比例 --&gt;</span> \n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<h2 id=\"menu_4\">传统CSS覆写</h2><p>在原来的CSS文件中增加覆写，举例说明。</p>\n<p>案例已经完全包括了自适应开发中应用到的所有方法，比较简单。</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-comment\">/*原始的网页样式*/</span> \n<span class=\"hljs-selector-class\">.container</span> {\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">1200px</span>;\n    <span class=\"hljs-attribute\">margin-right</span>: auto;\n    <span class=\"hljs-attribute\">margin-left</span>: auto;\n    <span class=\"hljs-attribute\">padding-left</span>: <span class=\"hljs-number\">15px</span>;\n    <span class=\"hljs-attribute\">padding-right</span>: <span class=\"hljs-number\">15px</span>\n}\n<span class=\"hljs-comment\">/*当屏幕宽度小于等于991px时，一般多为手机*/</span> \n<span class=\"hljs-comment\">/*className为container的元素宽度为100%*/</span>\n<span class=\"hljs-keyword\">@media</span> (<span class=\"hljs-attribute\">max-width</span>: <span class=\"hljs-number\">991px</span>) {\n    <span class=\"hljs-selector-class\">.container</span> {\n        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100%</span> \n    }\n}\n<span class=\"hljs-comment\">/*当屏幕宽度大于等于992px且小于等于1099px时，一般多为平板*/</span>\n<span class=\"hljs-comment\">/*className为container的元素宽度为90%*/</span>\n<span class=\"hljs-keyword\">@media</span> (<span class=\"hljs-attribute\">min-width</span>: <span class=\"hljs-number\">992px</span>) <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">max-width</span>: <span class=\"hljs-number\">1099px</span>) {\n    <span class=\"hljs-selector-class\">.container</span> {\n        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">90%</span>\n    }\n} \n<span class=\"hljs-comment\">/*当屏幕宽度大于等于1100px时，常规电脑*/</span>\n<span class=\"hljs-comment\">/*className为container的元素宽度为1100px*/</span>\n<span class=\"hljs-comment\">/*此处用于举例，实际这个样式是多余了，默认就是&gt;1100px*/</span>\n<span class=\"hljs-keyword\">@media</span> (<span class=\"hljs-attribute\">min-width</span>: <span class=\"hljs-number\">1100px</span>) {\n    <span class=\"hljs-selector-class\">.container</span> {\n        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">1100px</span>\n    }\n}\n</code></pre>\n<h3 id=\"menu_5\">关于CSS覆写</h3><p>我们将根据CSS样式渲染生效原则，在这里简单提一下 </p>\n<p><strong>浏览器缺省 &lt; 外部样式表 &lt; 外部样式表类选择器 &lt; 外部样式表类派生选择器 &lt; 外部样式表ID选择器 &lt; 外部样式表ID派生选择器 &lt; 内部样式表 &lt; 内部样式表类选择器 &lt; 内部样式表类派生选择器 &lt; 内部样式表ID选择器 &lt; 内部样式表ID派生选择器 &lt; 内联样式</strong></p>\n<p>关于这么多种样式生效类型，就不一一介绍了，这属于CSS的基础。</p>\n<h2 id=\"menu_6\">完整CSS覆写</h2><p>定义一个全新的文件，与原来的CSS样式文件互不干扰。</p>\n<p>值得注意的是，自适应的样式表一定要放在原始样式表的下面。</p>\n<p>CSS样式渲染生效还有一个基本原则就是，<strong>后者覆写前者（或者又称为距离元素最近的样式生效）</strong> 。</p>\n<p>这种方式与传统方式的差异在于不需要指定大量的@media标签在CSS文件中，与源CSS样式表分开，易读性高。</p>\n<p>在开发的时候就和正常编写CSS样式一致，更为高效。</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh_CN&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 原始的样式表 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;/static/css/index.css&quot;</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 当屏幕宽度低于768px时会加载这个CSS文件 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;/static/css/mobile.css&quot;</span> <span class=\"hljs-attr\">media</span>=<span class=\"hljs-string\">&quot;screen and (max-width:768px)&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<h1 id=\"menu_7\">结尾小结</h1><p>实际开发中更加推荐使用第二种开发模式：</p>\n<ul>\n<li>不需要指定大量的@media标签（判断屏幕宽度）</li>\n<li>保留的编写CSS样式表的习惯</li>\n<li>对于需要适配多种尺寸终端，只需要引用指定的CSS文件</li>\n<li>对于旧版网页改造无需破坏原有的样式，直接引入新文件即可</li>\n</ul>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">关于自适应网页</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">自适应三要素</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">自适应开发方式</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">传统CSS覆写</a> <ul><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl3\">关于CSS覆写</a></li></ul></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">完整CSS覆写</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl1\">结尾小结</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1044, '# 删除错误提示\n\n在版本交付周期中，无论是自测还是SDV测试过程中需要把数据库的用户和表清理干净重新创建，以保证与客户现场环境首次安装完全一致。\n\n但实际删除Orcale用户时提示：\n\n```sql\ncannot drop a user that is currently connected\n-- 提示存在用户通过此账号连接\nSQL> drop user MEBUGSDB cascade;\ndrop user MEBUGSDB cascade \n*ERROR at line 1:\nORA-01940: cannot drop a user that is currently connected \n```\n\n实际自己检查外部连接的都是断开的，比如PLSQL、SQLPlus、WebAPP等。\n\n那只能用一些非常规手段了...emmm\n\n## 查询连接\n\n出现无法删除用户并提示已有连接时，先查询这个用户当前还在连接的sessionID。\n\n```sql\n-- SELECT SID,SERIAL# FROM V$SESSION WHERE USERNAME=\"MEBUGSDB\"; \nSQL> SELECT SID,SERIAL# FROM V$SESSION WHERE USERNAME=\"MEBUGSDB\"; \nSID		SERIAL#\n---------- ----------\n136		1807\n```\n\n如上所示，我们发现有一个连接通过此用户与数据库保持连接状态。\n\n## 干掉连接\n\n通过命令Kill掉这个session（连接线程）可能会有多个线程，注意全部Kill掉即可。\n\n```sql\n-- ALTER SYSTEM KILL SESSION \"136,1807\";\nSQL> ALTER SYSTEM KILL SESSION \"136,1807\";\nSystem altered.\n```\n\n## 重新删除用户\n\n```sql\nSQL> drop user MEBUGSDB cascade; \nUser dropped. \n```\n\n删除成功，处理完毕。\n\n# 结尾小结\n\n删除用户处理方式并不复杂。\n\n执行强制删除连接前需要确认是否已经与所有使用该数据库用户的小伙伴们均沟通完毕，避免产生数据丢失。\n\n那么在实际过程为什么我们已经确认各个应用业务已经关闭或暂停还是会存在连接呢？\n\n这里针对JAVA的Tomcat容器单独说明下情况。\n\n# Tomcat容器ShutDown\n\n关闭JAVA的Tomcat容器我们一般都是执行bin目录下的shutdown.sh脚本。\n\n实际上仅仅执行该脚本后，容器确实无法访问，但是应用并没有完全关闭掉。\n\n如果通过ps查询进程就会发现，该路径下的java程序依旧是启动的。\n\n最终我们需要通过kill -9 PID的方式完全关闭。\n\n这其中原因一般都是项目应用中可能使用了线程池一类的东西导致。\n\nTomcat的shutdown.sh脚本并不能同步关闭应用启动的一些后台线程。', '<h1 id=\"menu_1\">删除错误提示</h1><p>在版本交付周期中，无论是自测还是SDV测试过程中需要把数据库的用户和表清理干净重新创建，以保证与客户现场环境首次安装完全一致。</p>\n<p>但实际删除Orcale用户时提示：</p>\n<pre><code class=\"hljs language-sql\">cannot <span class=\"hljs-keyword\">drop</span> a <span class=\"hljs-keyword\">user</span> that <span class=\"hljs-keyword\">is</span> currently connected\n<span class=\"hljs-comment\">-- 提示存在用户通过此账号连接</span>\n<span class=\"hljs-keyword\">SQL</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">drop</span> <span class=\"hljs-keyword\">user</span> MEBUGSDB cascade;\n<span class=\"hljs-keyword\">drop</span> <span class=\"hljs-keyword\">user</span> MEBUGSDB cascade \n<span class=\"hljs-operator\">*</span>ERROR <span class=\"hljs-keyword\">at</span> line <span class=\"hljs-number\">1</span>:\nORA<span class=\"hljs-number\">-01940</span>: cannot <span class=\"hljs-keyword\">drop</span> a <span class=\"hljs-keyword\">user</span> that <span class=\"hljs-keyword\">is</span> currently connected \n</code></pre>\n<p>实际自己检查外部连接的都是断开的，比如PLSQL、SQLPlus、WebAPP等。</p>\n<p>那只能用一些非常规手段了...emmm</p>\n<h2 id=\"menu_2\">查询连接</h2><p>出现无法删除用户并提示已有连接时，先查询这个用户当前还在连接的sessionID。</p>\n<pre><code class=\"hljs language-sql\">-- <span class=\"hljs-keyword\">SELECT</span> SID,SERIAL# <span class=\"hljs-keyword\">FROM</span> V$SESSION <span class=\"hljs-keyword\">WHERE</span> USERNAME=<span class=\"hljs-string\">&quot;MEBUGSDB&quot;</span>; \nSQL&gt; <span class=\"hljs-keyword\">SELECT</span> SID,SERIAL# <span class=\"hljs-keyword\">FROM</span> V$SESSION <span class=\"hljs-keyword\">WHERE</span> USERNAME=<span class=\"hljs-string\">&quot;MEBUGSDB&quot;</span>; \nSID        SERIAL#\n---------- ----------\n<span class=\"hljs-number\">136</span>        <span class=\"hljs-number\">1807</span>\n</code></pre>\n<p>如上所示，我们发现有一个连接通过此用户与数据库保持连接状态。</p>\n<h2 id=\"menu_3\">干掉连接</h2><p>通过命令Kill掉这个session（连接线程）可能会有多个线程，注意全部Kill掉即可。</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">-- ALTER SYSTEM KILL SESSION &quot;136,1807&quot;;</span>\n<span class=\"hljs-keyword\">SQL</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">SYSTEM</span> KILL SESSION &quot;136,1807&quot;;\n<span class=\"hljs-keyword\">System</span> altered.\n</code></pre>\n<h2 id=\"menu_4\">重新删除用户</h2><pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SQL</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">drop</span> <span class=\"hljs-keyword\">user</span> MEBUGSDB cascade; \n<span class=\"hljs-keyword\">User</span> dropped. \n</code></pre>\n<p>删除成功，处理完毕。</p>\n<h1 id=\"menu_5\">结尾小结</h1><p>删除用户处理方式并不复杂。</p>\n<p>执行强制删除连接前需要确认是否已经与所有使用该数据库用户的小伙伴们均沟通完毕，避免产生数据丢失。</p>\n<p>那么在实际过程为什么我们已经确认各个应用业务已经关闭或暂停还是会存在连接呢？</p>\n<p>这里针对JAVA的Tomcat容器单独说明下情况。</p>\n<h1 id=\"menu_6\">Tomcat容器ShutDown</h1><p>关闭JAVA的Tomcat容器我们一般都是执行bin目录下的shutdown.sh脚本。</p>\n<p>实际上仅仅执行该脚本后，容器确实无法访问，但是应用并没有完全关闭掉。</p>\n<p>如果通过ps查询进程就会发现，该路径下的java程序依旧是启动的。</p>\n<p>最终我们需要通过kill -9 PID的方式完全关闭。</p>\n<p>这其中原因一般都是项目应用中可能使用了线程池一类的东西导致。</p>\n<p>Tomcat的shutdown.sh脚本并不能同步关闭应用启动的一些后台线程。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">删除错误提示</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">查询连接</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">干掉连接</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">重新删除用户</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">结尾小结</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl1\">Tomcat容器ShutDown</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1045, '# 关于filter过滤器\n\nfilter过滤器，用于过滤到servlet的request，它可以改变一个request和修改一个response。\n\nfilter不是servlet，不能产生response。\n\nfilter能够在一个request到达servlet之前预处理request，也可以在离开servlet时处理response。\n\n# 为什么使用filter\n\nWEB工程中有些页面本身是对外开放的，但是我们实际上又会要求登录才可见。\n\n虽然WEB-INFO目录可以禁止页面直接访问资源（WEB-INFO目录只能通过servlet去访问）。\n\n如果我们将资源页面文件放在WEB-INFO下也可以达到无法访问，但是这就对我们前端编码造成很大的困扰。\n\nWEB-INF是受保护目录，WEB-INF里面的文件只可以由servlet去访问，不能通过url地址栏去请求访问。\n\n所以，我们应该通过别的方式来动态判断处理资源文件是否应该被访问\n\n#web.xml配置     \n\n一个登录状态检查校验器，检查所有的向jsp文件发起的请求，并排除登录/登出/首页的访问拦截。\n\n```xml\n<filter>\n	<filter-name>checkLoginStatusFilter</filter-name>\n	<filter-class>com.mebugs.filter.CheckLoginStatusFilter</filter-class>\n	<init-param>\n		<param-name>exceptPath</param-name>\n		<param-value>login.jsp;logout.jsp;index.jsp</param-value>\n	</init-param>\n	<filter-mapping>\n		<filter-name>checkLoginStatusFilter</filter-name>\n		<url-pattern>*.jsp</url-pattern>\n	</filter-mapping>\n</filter>\n```\n\n# 自定义过滤器类\n\n依赖于服务端保存了登录后新生成的sessionID，且服务端需要实现超时注销和登出注销session的能力。\n\n```java\n/*\n * 文件名：CheckLoginStatusFilter.java\n * 描述：检查是否处于登录状态\n * check the request sessionID login status\n * @author   mebugs\n * @version  1.0\n */\npublic class CheckLoginStatusFilter implements Filter{\n	//定义除外的访问PATH\n	private String exceptPath;\n	\n	//初始化参数，获取web.xml中配置的忽略校验地址\n	public void init(FilterConfig config) throws ServletException     { \n		this.exceptPath = config.getInitParameter(\"exceptPath\");\n	}\n	\n	public void destroy(){\n		//销毁方法\n	}\n	\n	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { \n		HttpServletRequest httpRequest = null;\n		if (request instanceof HttpServletRequest){\n			httpRequest = (HttpServletRequest)request;\n		}\n		HttpServletResponse httpResponse = null; \n		if (response instanceof HttpServletResponse){\n			httpResponse = (HttpServletResponse)response;\n		} \n		if (null == httpRequest || null == httpResponse) {\n			return;\n		} \n		String requestURI = httpRequest.getRequestURI();\n		String contextPath = httpRequest.getContextPath();\n		String sessionID = httpRequest.getSession().getId();\n		String userName = null;\n		//Constants.SEMICOLON分号，针对配置多种排除的地址的时候\n		String[] exceptPathList =  this.exceptPath.split(Constants.SEMICOLON);\n		for (int i = 0; i < exceptPathList.length; i++){\n			if (requestURI.endsWith(exceptPathList[i]){\n				//如果请求是忽略的地址\n				chain.doFilter(request, response);\n				return;\n			}\n		}\n		if(null != sessionID){\n			userName = (String) httpRequest.getSession().getAttribute(\"username\");\n		}\n		if (null != userName){\n			//检查浏览器sessionID与服务器中缓存的登录后sessionID是否一致\n			if(sessionID.equals(UserSessionData.sessionMap.get(userName)){\n				//登录状态 sessionID一致\n				chain.doFilter(request, response);\n				return;\n			}\n		}\n		\n		//其他场景通通非法\n		httpResponse.setStatus(911);\n		httpResponse.setHeader(\"sessionstatus\", \"timeout\");\n		httpResponse.addHeader(\"loginPath\", contextPath + \"/login.jsp\");\n		httpResponse.setCharacterEncoding(\"UTF-8\");\n		httpResponse.setContentType(\"text/html\");\n		PrintWriter out = httpResponse.getWriter();\n		out.println(\"<script>\");\n		out.println(\"top.location.href = \'\" + contextPath + \"/login.jsp\'\");\n		out.println(\"</script>\");\n		return;\n	}\n}\n\n```\n\n# 结尾小结\n\n通过自定义过滤器可以更加人性化的对客户端发起的请求进行过滤。\n\n对于资源请求限制为已登录用户才能访问，这样可以避免绝大多数非法攻击。', '<h1 id=\"menu_1\">关于filter过滤器</h1><p>filter过滤器，用于过滤到servlet的request，它可以改变一个request和修改一个response。</p>\n<p>filter不是servlet，不能产生response。</p>\n<p>filter能够在一个request到达servlet之前预处理request，也可以在离开servlet时处理response。</p>\n<h1 id=\"menu_2\">为什么使用filter</h1><p>WEB工程中有些页面本身是对外开放的，但是我们实际上又会要求登录才可见。</p>\n<p>虽然WEB-INFO目录可以禁止页面直接访问资源（WEB-INFO目录只能通过servlet去访问）。</p>\n<p>如果我们将资源页面文件放在WEB-INFO下也可以达到无法访问，但是这就对我们前端编码造成很大的困扰。</p>\n<p>WEB-INF是受保护目录，WEB-INF里面的文件只可以由servlet去访问，不能通过url地址栏去请求访问。</p>\n<p>所以，我们应该通过别的方式来动态判断处理资源文件是否应该被访问</p>\n<p>#web.xml配置     </p>\n<p>一个登录状态检查校验器，检查所有的向jsp文件发起的请求，并排除登录/登出/首页的访问拦截。</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filter</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filter-name</span>&gt;</span>checkLoginStatusFilter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filter-name</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filter-class</span>&gt;</span>com.mebugs.filter.CheckLoginStatusFilter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filter-class</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">init-param</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-name</span>&gt;</span>exceptPath<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-name</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-value</span>&gt;</span>login.jsp;logout.jsp;index.jsp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-value</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">init-param</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filter-mapping</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filter-name</span>&gt;</span>checkLoginStatusFilter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filter-name</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">url-pattern</span>&gt;</span>*.jsp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">url-pattern</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filter-mapping</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filter</span>&gt;</span>\n</code></pre>\n<h1 id=\"menu_3\">自定义过滤器类</h1><p>依赖于服务端保存了登录后新生成的sessionID，且服务端需要实现超时注销和登出注销session的能力。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">/*\n * 文件名：CheckLoginStatusFilter.java\n * 描述：检查是否处于登录状态\n * check the request sessionID login status\n * @author   mebugs\n * @version  1.0\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CheckLoginStatusFilter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Filter</span>{\n    <span class=\"hljs-comment\">//定义除外的访问PATH</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">String</span> exceptPath;\n    \n    <span class=\"hljs-comment\">//初始化参数，获取web.xml中配置的忽略校验地址</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-title class_\">FilterConfig</span> config) throws <span class=\"hljs-title class_\">ServletException</span>     { \n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">exceptPath</span> = config.<span class=\"hljs-title function_\">getInitParameter</span>(<span class=\"hljs-string\">&quot;exceptPath&quot;</span>);\n    }\n    \n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">destroy</span>(<span class=\"hljs-params\"></span>){\n        <span class=\"hljs-comment\">//销毁方法</span>\n    }\n    \n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">doFilter</span>(<span class=\"hljs-title class_\">ServletRequest</span> request, <span class=\"hljs-title class_\">ServletResponse</span> response, <span class=\"hljs-title class_\">FilterChain</span> chain) throws IOException, <span class=\"hljs-title class_\">ServletException</span> { \n        <span class=\"hljs-title class_\">HttpServletRequest</span> httpRequest = <span class=\"hljs-literal\">null</span>;\n        <span class=\"hljs-keyword\">if</span> (request <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">HttpServletRequest</span>){\n            httpRequest = (<span class=\"hljs-title class_\">HttpServletRequest</span>)request;\n        }\n        <span class=\"hljs-title class_\">HttpServletResponse</span> httpResponse = <span class=\"hljs-literal\">null</span>; \n        <span class=\"hljs-keyword\">if</span> (response <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">HttpServletResponse</span>){\n            httpResponse = (<span class=\"hljs-title class_\">HttpServletResponse</span>)response;\n        } \n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">null</span> == httpRequest || <span class=\"hljs-literal\">null</span> == httpResponse) {\n            <span class=\"hljs-keyword\">return</span>;\n        } \n        <span class=\"hljs-title class_\">String</span> requestURI = httpRequest.<span class=\"hljs-title function_\">getRequestURI</span>();\n        <span class=\"hljs-title class_\">String</span> contextPath = httpRequest.<span class=\"hljs-title function_\">getContextPath</span>();\n        <span class=\"hljs-title class_\">String</span> sessionID = httpRequest.<span class=\"hljs-title function_\">getSession</span>().<span class=\"hljs-title function_\">getId</span>();\n        <span class=\"hljs-title class_\">String</span> userName = <span class=\"hljs-literal\">null</span>;\n        <span class=\"hljs-comment\">//Constants.SEMICOLON分号，针对配置多种排除的地址的时候</span>\n        <span class=\"hljs-title class_\">String</span>[] exceptPathList =  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">exceptPath</span>.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-title class_\">Constants</span>.<span class=\"hljs-property\">SEMICOLON</span>);\n        <span class=\"hljs-keyword\">for</span> (int i = <span class=\"hljs-number\">0</span>; i &lt; exceptPathList.<span class=\"hljs-property\">length</span>; i++){\n            <span class=\"hljs-keyword\">if</span> (requestURI.<span class=\"hljs-title function_\">endsWith</span>(<span class=\"hljs-params\">exceptPathList[i]</span>){\n                <span class=\"hljs-comment\">//如果请求是忽略的地址</span>\n                chain.<span class=\"hljs-title function_\">doFilter</span>(request, response);\n                <span class=\"hljs-keyword\">return</span>;\n            }\n        }\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-literal\">null</span> != sessionID){\n            userName = (<span class=\"hljs-title class_\">String</span>) httpRequest.<span class=\"hljs-title function_\">getSession</span>().<span class=\"hljs-title function_\">getAttribute</span>(<span class=\"hljs-string\">&quot;username&quot;</span>);\n        }\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">null</span> != userName){\n            <span class=\"hljs-comment\">//检查浏览器sessionID与服务器中缓存的登录后sessionID是否一致</span>\n            <span class=\"hljs-keyword\">if</span>(sessionID.<span class=\"hljs-title function_\">equals</span>(<span class=\"hljs-params\">UserSessionData.sessionMap.get(userName)</span>){\n                <span class=\"hljs-comment\">//登录状态 sessionID一致</span>\n                chain.<span class=\"hljs-title function_\">doFilter</span>(request, response);\n                <span class=\"hljs-keyword\">return</span>;\n            }\n        }\n        \n        <span class=\"hljs-comment\">//其他场景通通非法</span>\n        httpResponse.<span class=\"hljs-title function_\">setStatus</span>(<span class=\"hljs-number\">911</span>);\n        httpResponse.<span class=\"hljs-title function_\">setHeader</span>(<span class=\"hljs-string\">&quot;sessionstatus&quot;</span>, <span class=\"hljs-string\">&quot;timeout&quot;</span>);\n        httpResponse.<span class=\"hljs-title function_\">addHeader</span>(<span class=\"hljs-string\">&quot;loginPath&quot;</span>, contextPath + <span class=\"hljs-string\">&quot;/login.jsp&quot;</span>);\n        httpResponse.<span class=\"hljs-title function_\">setCharacterEncoding</span>(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>);\n        httpResponse.<span class=\"hljs-title function_\">setContentType</span>(<span class=\"hljs-string\">&quot;text/html&quot;</span>);\n        <span class=\"hljs-title class_\">PrintWriter</span> out = httpResponse.<span class=\"hljs-title function_\">getWriter</span>();\n        out.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;&lt;script&gt;&quot;</span>);\n        out.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;top.location.href = &#x27;&quot;</span> + contextPath + <span class=\"hljs-string\">&quot;/login.jsp&#x27;&quot;</span>);\n        out.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;&lt;/script&gt;&quot;</span>);\n        <span class=\"hljs-keyword\">return</span>;\n    }\n}\n</code></pre>\n<h1 id=\"menu_4\">结尾小结</h1><p>通过自定义过滤器可以更加人性化的对客户端发起的请求进行过滤。</p>\n<p>对于资源请求限制为已登录用户才能访问，这样可以避免绝大多数非法攻击。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">关于filter过滤器</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">为什么使用filter</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">自定义过滤器类</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">结尾小结</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1046, '# MERGE INTO应用场景\n\n米虫最近在做老系统跨版本升级，在整理升级SQL的时候，无意中学习到Oracle中的MERGE INTO语法。\n\nMERGE INTO主要用于解决对于已有数据更新升级的情况。\n\n一般我们升级数据库记录，都是直接写update语句，如果这个记录压根不存在，那就尴尬了。\n\n比较常见的做法是，先delete记录在insert记录，这样可以保证执行不出错。\n\n比如:\n\n```sql\nDELETE FROM mebugs_run WHERE runid = \"GOINDOWN\";\ncommit;\nINSERT INTO mebugs_run (runid, runname) VALUES (\"GOINDOWN\", \"THIS_IS_NEW\");\ncommit;\n```\n\nSQL Sever可以通过IF...ELSE...实现条件入库。\n\nMySQL可以通过REPLACE INTO实现条件入库（有特殊约束体条件）。\n\nOracle 9i引入INSERT INTO语句，语法这里不贴了，直接用实例来讲解。\n\n# MERGE INTO实例\n\nINSERT INTO语句的强大之处在于可以任意判断某个字段是否存在某个值。\n\n```sql\nMERGE INTO mebugs_run T1\n--检查GOINDOWN这个字符串在mebugs_run表的runid列是否存在\n--此处用FROM dual实际上是为了提取一个\"GOINDOWN\"的字符串，具体原因在下方有解释\nUSING (SELECT \"GOINDOWN\" runid FROM dual) T2\n--判断mebugs_run T1中的runid字段是不是有\"GOINDOWN\"\nON ( T1.runid=T2.runid)\nWHEN MATCHED THEN\n    --存在进行UPDATE\n	--这里更新的是mebugs_run T1中的runid字段是\"GOINDOWN\"的记录\n	--需要注意UPDATE的条数不一定是一条\n    UPDATE SET T1.runname = \"MAX_OPEN_FLAG\"\nWHEN NOT MATCHED THEN\n    --不存在进行INSERT\n    INSERT (runid, runname) VALUES (\"GOINDOWN\", \"MAX_OPEN_FLAG\");\ncommit;\n```\n\n## USING特别说明\n\n在一个同时存在INSERT和UPDATE语法的MERGE INTO语句中，总共INSERT/UPDATE的记录数，就是USING语句中alias2（T2）的记录数（alias2就是上面实例的T2）。\n\n一定要注意USING后面的条件语句，上文实例FROM dual最终只会update表中runid = \"GOINDOWN\"的记录，因为T2只会返回一个结果。\n\n如果把\n\n - USING (SELECT \"GOINDOWN\" runid FROM dual) T2\n\n改成\n\n - USING (SELECT runid FROM mebugs_run WHERE runid = \"GOINDOWN\") T2\n \n那么这个句子就不一定能够INSERT了，因为ON ( T1.runid=T2.runid)如果不存在该记录的时候条件语句返回直接是空。\n\n所以，MERGE INTO还是很危险的，说不得本来想更新一条记录，一不小把整个表刷个遍（那你就要绝望了）\n\n重点关注USING ON条件语句返回的情况。\n\n# 结尾小结\n\n使用MERGE INTO语句需要清晰理解一个执行过程。\n\n1. 查询表中满足条件的数据是否存在\n2. 如果存在则走UPDATE逻辑，且更新的数据为步骤1中满足条件的数据\n3. 如果不存在则走INSERT逻辑\n4. UPDATE和INSERT均是可选择使用的，无需的执行的部分可以直接不写\n\n因此，在MERGE INTO语句中梳理条件（USING ON条件语句）是一个非常关键的事情。', '<h1 id=\"menu_1\">MERGE INTO应用场景</h1><p>米虫最近在做老系统跨版本升级，在整理升级SQL的时候，无意中学习到Oracle中的MERGE INTO语法。</p>\n<p>MERGE INTO主要用于解决对于已有数据更新升级的情况。</p>\n<p>一般我们升级数据库记录，都是直接写update语句，如果这个记录压根不存在，那就尴尬了。</p>\n<p>比较常见的做法是，先delete记录在insert记录，这样可以保证执行不出错。</p>\n<p>比如:</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">DELETE</span> <span class=\"hljs-keyword\">FROM</span> mebugs_run <span class=\"hljs-keyword\">WHERE</span> runid <span class=\"hljs-operator\">=</span> &quot;GOINDOWN&quot;;\n<span class=\"hljs-keyword\">commit</span>;\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> mebugs_run (runid, runname) <span class=\"hljs-keyword\">VALUES</span> (&quot;GOINDOWN&quot;, &quot;THIS_IS_NEW&quot;);\n<span class=\"hljs-keyword\">commit</span>;\n</code></pre>\n<p>SQL Sever可以通过IF...ELSE...实现条件入库。</p>\n<p>MySQL可以通过REPLACE INTO实现条件入库（有特殊约束体条件）。</p>\n<p>Oracle 9i引入INSERT INTO语句，语法这里不贴了，直接用实例来讲解。</p>\n<h1 id=\"menu_2\">MERGE INTO实例</h1><p>INSERT INTO语句的强大之处在于可以任意判断某个字段是否存在某个值。</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">MERGE</span> <span class=\"hljs-keyword\">INTO</span> mebugs_run T1\n<span class=\"hljs-comment\">--检查GOINDOWN这个字符串在mebugs_run表的runid列是否存在</span>\n<span class=\"hljs-comment\">--此处用FROM dual实际上是为了提取一个&quot;GOINDOWN&quot;的字符串，具体原因在下方有解释</span>\n<span class=\"hljs-keyword\">USING</span> (<span class=\"hljs-keyword\">SELECT</span> &quot;GOINDOWN&quot; runid <span class=\"hljs-keyword\">FROM</span> dual) T2\n<span class=\"hljs-comment\">--判断mebugs_run T1中的runid字段是不是有&quot;GOINDOWN&quot;</span>\n<span class=\"hljs-keyword\">ON</span> ( T1.runid<span class=\"hljs-operator\">=</span>T2.runid)\n<span class=\"hljs-keyword\">WHEN</span> MATCHED <span class=\"hljs-keyword\">THEN</span>\n    <span class=\"hljs-comment\">--存在进行UPDATE</span>\n    <span class=\"hljs-comment\">--这里更新的是mebugs_run T1中的runid字段是&quot;GOINDOWN&quot;的记录</span>\n    <span class=\"hljs-comment\">--需要注意UPDATE的条数不一定是一条</span>\n    <span class=\"hljs-keyword\">UPDATE</span> <span class=\"hljs-keyword\">SET</span> T1.runname <span class=\"hljs-operator\">=</span> &quot;MAX_OPEN_FLAG&quot;\n<span class=\"hljs-keyword\">WHEN</span> <span class=\"hljs-keyword\">NOT</span> MATCHED <span class=\"hljs-keyword\">THEN</span>\n    <span class=\"hljs-comment\">--不存在进行INSERT</span>\n    <span class=\"hljs-keyword\">INSERT</span> (runid, runname) <span class=\"hljs-keyword\">VALUES</span> (&quot;GOINDOWN&quot;, &quot;MAX_OPEN_FLAG&quot;);\n<span class=\"hljs-keyword\">commit</span>;\n</code></pre>\n<h2 id=\"menu_3\">USING特别说明</h2><p>在一个同时存在INSERT和UPDATE语法的MERGE INTO语句中，总共INSERT/UPDATE的记录数，就是USING语句中alias2（T2）的记录数（alias2就是上面实例的T2）。</p>\n<p>一定要注意USING后面的条件语句，上文实例FROM dual最终只会update表中runid = &quot;GOINDOWN&quot;的记录，因为T2只会返回一个结果。</p>\n<p>如果把</p>\n<ul>\n<li>USING (SELECT &quot;GOINDOWN&quot; runid FROM dual) T2</li>\n</ul>\n<p>改成</p>\n<ul>\n<li>USING (SELECT runid FROM mebugs_run WHERE runid = &quot;GOINDOWN&quot;) T2</li>\n</ul>\n<p>那么这个句子就不一定能够INSERT了，因为ON ( T1.runid=T2.runid)如果不存在该记录的时候条件语句返回直接是空。</p>\n<p>所以，MERGE INTO还是很危险的，说不得本来想更新一条记录，一不小把整个表刷个遍（那你就要绝望了）</p>\n<p>重点关注USING ON条件语句返回的情况。</p>\n<h1 id=\"menu_4\">结尾小结</h1><p>使用MERGE INTO语句需要清晰理解一个执行过程。</p>\n<ol>\n<li>查询表中满足条件的数据是否存在</li>\n<li>如果存在则走UPDATE逻辑，且更新的数据为步骤1中满足条件的数据</li>\n<li>如果不存在则走INSERT逻辑</li>\n<li>UPDATE和INSERT均是可选择使用的，无需的执行的部分可以直接不写</li>\n</ol>\n<p>因此，在MERGE INTO语句中梳理条件（USING ON条件语句）是一个非常关键的事情。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">MERGE&nbsp;INTO应用场景</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">MERGE&nbsp;INTO实例</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">USING特别说明</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">结尾小结</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1047, '# EOF自定义终止符\n\nEOF自定义终止符，在Shell脚本非常常见的语法格式。\n\n一般情况EOF会与重定向符号组合使用，如：<< EOF 接下来的内容为标准输入。\n\nEOF配合几中重定向符号可以实现众多功能，如写入文件、追加写入、执行命令等。\n\n```shell\n# 开始\n<<EOF        \n# 中间的命令\n# 结束\nEOF\n```\n\n# 修改密码脚本\n\n修改密码脚本主要用于解决密码过期问题，将密码修改为当前密码即可再次生效。\n\n脚本正文，根据命令中传入的数据进行密码修改。\n\n脚本利用了 EOF+<<标准输入 实现自动输入新密码实现密码修改。\n\n```shell\n#!/bin/bash \n#filename: resetPwd.sh\n#Author: mebugs\n\n#Get Name And PassWord From Script\nuser=$1\npswd=$2\n# EOF内输入的是密码，实际相当于手工执行密码修改操作。\npasswd ${user} << EOF\n${pswd}\n${pswd}\nEOF\necho \"OK\"\nexit\n```\n\n## 脚本调用形式\n\n```shell\nsh resetPwd.sh test mebugs123\n```\n\n# 修改密码操作\n\n```shell\n#修改密码 \n#root用户修改自己的密码，不需要携带用户名\npasswd [NAME]\n#查询用户密码的有效期\nchage -l [NAME]\n#修改密码过期时间\n#密码到期的日期，过了这天，此账号将不可用。0表示马上过期，-1表示永不过期\nchage -E -1 [NAME]\n#密码可以更改的最小天数，设置9999永不需要修改\nchage -m 9999 用户名\n#密码保持有效的最大天数。设置9999意味着永远有效\nchage -M 9999 用户名\n```\n\n# 应用说明\n一键修改密码可以使用这种形式。\n\n如果密码同时含有单引号和双引号，那么则无法通过这种方法修改。\n\n可以通过history命令看到修改记录。\n\n```shell\necho new_passwd@000 | passwd --stdin root\n```\n\n该脚本的主要作用用于大批量维护环境时采用远程投放脚本来实现批量修改密码。', '<h1 id=\"menu_1\">EOF自定义终止符</h1><p>EOF自定义终止符，在Shell脚本非常常见的语法格式。</p>\n<p>一般情况EOF会与重定向符号组合使用，如：&lt;&lt; EOF 接下来的内容为标准输入。</p>\n<p>EOF配合几中重定向符号可以实现众多功能，如写入文件、追加写入、执行命令等。</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-comment\"># 开始</span>\n&lt;&lt;<span class=\"hljs-string\">EOF        \n# 中间的命令\n# 结束\nEOF</span>\n</code></pre>\n<h1 id=\"menu_2\">修改密码脚本</h1><p>修改密码脚本主要用于解决密码过期问题，将密码修改为当前密码即可再次生效。</p>\n<p>脚本正文，根据命令中传入的数据进行密码修改。</p>\n<p>脚本利用了 EOF+&lt;&lt;标准输入 实现自动输入新密码实现密码修改。</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\">#!/bin/bash </span>\n<span class=\"hljs-comment\">#filename: resetPwd.sh</span>\n<span class=\"hljs-comment\">#Author: mebugs</span>\n\n<span class=\"hljs-comment\">#Get Name And PassWord From Script</span>\nuser=<span class=\"hljs-variable\">$1</span>\npswd=<span class=\"hljs-variable\">$2</span>\n<span class=\"hljs-comment\"># EOF内输入的是密码，实际相当于手工执行密码修改操作。</span>\npasswd <span class=\"hljs-variable\">${user}</span> &lt;&lt; <span class=\"hljs-string\">EOF\n${pswd}\n${pswd}\nEOF</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;OK&quot;</span>\n<span class=\"hljs-built_in\">exit</span>\n</code></pre>\n<h2 id=\"menu_3\">脚本调用形式</h2><pre><code class=\"hljs language-shell\">sh resetPwd.sh <span class=\"hljs-built_in\">test</span> mebugs123\n</code></pre>\n<h1 id=\"menu_4\">修改密码操作</h1><pre><code class=\"hljs language-shell\"><span class=\"hljs-comment\">#修改密码 </span>\n<span class=\"hljs-comment\">#root用户修改自己的密码，不需要携带用户名</span>\n<span class=\"hljs-string\">passwd</span> [<span class=\"hljs-string\">NAME</span>]\n<span class=\"hljs-comment\">#查询用户密码的有效期</span>\n<span class=\"hljs-string\">chage</span> <span class=\"hljs-string\">-l</span> [<span class=\"hljs-string\">NAME</span>]\n<span class=\"hljs-comment\">#修改密码过期时间</span>\n<span class=\"hljs-comment\">#密码到期的日期，过了这天，此账号将不可用。0表示马上过期，-1表示永不过期</span>\n<span class=\"hljs-string\">chage</span> <span class=\"hljs-string\">-E</span> <span class=\"hljs-number\">-1</span> [<span class=\"hljs-string\">NAME</span>]\n<span class=\"hljs-comment\">#密码可以更改的最小天数，设置9999永不需要修改</span>\n<span class=\"hljs-string\">chage</span> <span class=\"hljs-string\">-m</span> <span class=\"hljs-number\">9999</span> <span class=\"hljs-string\">用户名</span>\n<span class=\"hljs-comment\">#密码保持有效的最大天数。设置9999意味着永远有效</span>\n<span class=\"hljs-string\">chage</span> <span class=\"hljs-string\">-M</span> <span class=\"hljs-number\">9999</span> <span class=\"hljs-string\">用户名</span>\n</code></pre>\n<h1 id=\"menu_5\">应用说明</h1><p>一键修改密码可以使用这种形式。</p>\n<p>如果密码同时含有单引号和双引号，那么则无法通过这种方法修改。</p>\n<p>可以通过history命令看到修改记录。</p>\n<pre><code class=\"hljs language-shell\">echo new_passwd<span class=\"hljs-variable\">@000</span> <span class=\"hljs-operator\">|</span> passwd <span class=\"hljs-comment\">--stdin root</span>\n</code></pre>\n<p>该脚本的主要作用用于大批量维护环境时采用远程投放脚本来实现批量修改密码。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">EOF自定义终止符</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">修改密码脚本</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">脚本调用形式</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">修改密码操作</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">应用说明</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1048, '# 关于on()方法\n\n自Jquery1.7起，on()方法是 bind()、live()、delegate() 方法的新的替代品。\n\non()方法带来很多便利，应用过程中推荐使用该方法，简化了Jquery代码库。\n\non()方法添加的事件处理程序适用于当前及未来的元素（比如动态创建的元素）。\n\n如需移除事件处理程序，请使用 off() 方法。\n\n如需添加只运行一次的事件然后移除，请使用 one() 方法。\n\n# 方法参数\n\n```js\n$(selector).on(event,childSelector,data,function)\n//selector（必须）元素选择器（必须）\n//event（必须）绑定事件，支持多个事件（空格分隔多个事件值，也可以是数组）\n//childSelector（选用）子元素选择器\n//data（选用）传递到函数的额外数据\n//function（选用）事件发生时运行的函数\n```\n\n# 基本实例\n\n```js\n$(document).ready(function(){\n	//一般情况下on用于页面dom初始化完成进行绑定\n	//支持绑定动态产生的节点\n	$(\"p\").on(\"click\",function(){\n		alert(\"段落被点击了。\");\n	});\n});\n```\n\n# 组合实例\n\n```js\n//绑定点击事件\n$(\"p\").on(\"click\",function(){\n	alert(\"段落被点击了。\");\n});\n\n//绑定多个事件1\n$(\"p\").on(\"click change\",function(){\n	alert(\"段落被点击或修改。\");\n});\n\n//绑定多个事件2\n$(\"p\").on([\"click\",\"change\"],function(){\n	alert(\"段落被点击或修改。\");\n});\n\n//绑定子元素\n$(\"p\").on(\"click\",\"span\",function(){\n	alert(\"段落的SPAN子元素被点击了。\");\n});\n\n//绑定传递参数\n$(\"p\").on(\"click\",\"span\",{\"name\":123},callBack);\nfunction callBack(e)\n{\n	alert(\"接受参数：\"+event.data.name);\n}\n```\n\n# 小结\n\nJquery中的.on(\"click\")和.click()二者在绑定静态控件时没有区别。\n\n但是如果面对动态产生的控件，只有on()能成功的绑定到动态控件中。\n\n```js\n$(\"#add\").click(function(){ \n    $(\".li\").append(\'<li>动态添加元素on<button class=\"del\">del</button></li>\'); \n});\n\n//无法绑定成功\n$(\".del\").click(function(){ \n    $(this).parent().remove(); \n}); \n\n//可以绑定并触发\n$(\".li\").on(“click“, \".del\", function(){\n    $(this).parent().remove(); \n})\n```', '<h1 id=\"menu_1\">关于on()方法</h1><p>自Jquery1.7起，on()方法是 bind()、live()、delegate() 方法的新的替代品。</p>\n<p>on()方法带来很多便利，应用过程中推荐使用该方法，简化了Jquery代码库。</p>\n<p>on()方法添加的事件处理程序适用于当前及未来的元素（比如动态创建的元素）。</p>\n<p>如需移除事件处理程序，请使用 off() 方法。</p>\n<p>如需添加只运行一次的事件然后移除，请使用 one() 方法。</p>\n<h1 id=\"menu_2\">方法参数</h1><pre><code class=\"hljs language-js\">$(selector).<span class=\"hljs-title function_\">on</span>(event,childSelector,data,<span class=\"hljs-keyword\">function</span>)\n<span class=\"hljs-comment\">//selector（必须）元素选择器（必须）</span>\n<span class=\"hljs-comment\">//event（必须）绑定事件，支持多个事件（空格分隔多个事件值，也可以是数组）</span>\n<span class=\"hljs-comment\">//childSelector（选用）子元素选择器</span>\n<span class=\"hljs-comment\">//data（选用）传递到函数的额外数据</span>\n<span class=\"hljs-comment\">//function（选用）事件发生时运行的函数</span>\n</code></pre>\n<h1 id=\"menu_3\">基本实例</h1><pre><code class=\"hljs language-js\">$(<span class=\"hljs-variable language_\">document</span>).<span class=\"hljs-title function_\">ready</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n    <span class=\"hljs-comment\">//一般情况下on用于页面dom初始化完成进行绑定</span>\n    <span class=\"hljs-comment\">//支持绑定动态产生的节点</span>\n    $(<span class=\"hljs-string\">&quot;p&quot;</span>).<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n        <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;段落被点击了。&quot;</span>);\n    });\n});\n</code></pre>\n<h1 id=\"menu_4\">组合实例</h1><pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//绑定点击事件</span>\n$(<span class=\"hljs-string\">&quot;p&quot;</span>).<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n    <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;段落被点击了。&quot;</span>);\n});\n\n<span class=\"hljs-comment\">//绑定多个事件1</span>\n$(<span class=\"hljs-string\">&quot;p&quot;</span>).<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;click change&quot;</span>,<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n    <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;段落被点击或修改。&quot;</span>);\n});\n\n<span class=\"hljs-comment\">//绑定多个事件2</span>\n$(<span class=\"hljs-string\">&quot;p&quot;</span>).<span class=\"hljs-title function_\">on</span>([<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-string\">&quot;change&quot;</span>],<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n    <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;段落被点击或修改。&quot;</span>);\n});\n\n<span class=\"hljs-comment\">//绑定子元素</span>\n$(<span class=\"hljs-string\">&quot;p&quot;</span>).<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-string\">&quot;span&quot;</span>,<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n    <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;段落的SPAN子元素被点击了。&quot;</span>);\n});\n\n<span class=\"hljs-comment\">//绑定传递参数</span>\n$(<span class=\"hljs-string\">&quot;p&quot;</span>).<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-string\">&quot;span&quot;</span>,{<span class=\"hljs-string\">&quot;name&quot;</span>:<span class=\"hljs-number\">123</span>},callBack);\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">callBack</span>(<span class=\"hljs-params\">e</span>)\n{\n    <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;接受参数：&quot;</span>+event.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">name</span>);\n}\n</code></pre>\n<h1 id=\"menu_5\">小结</h1><p>Jquery中的.on(&quot;click&quot;)和.click()二者在绑定静态控件时没有区别。</p>\n<p>但是如果面对动态产生的控件，只有on()能成功的绑定到动态控件中。</p>\n<pre><code class=\"hljs language-js\">$(<span class=\"hljs-string\">&quot;#add&quot;</span>).<span class=\"hljs-title function_\">click</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){ \n    $(<span class=\"hljs-string\">&quot;.li&quot;</span>).<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-string\">&#x27;&lt;li&gt;动态添加元素on&lt;button class=&quot;del&quot;&gt;del&lt;/button&gt;&lt;/li&gt;&#x27;</span>); \n});\n\n<span class=\"hljs-comment\">//无法绑定成功</span>\n$(<span class=\"hljs-string\">&quot;.del&quot;</span>).<span class=\"hljs-title function_\">click</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){ \n    $(<span class=\"hljs-variable language_\">this</span>).<span class=\"hljs-title function_\">parent</span>().<span class=\"hljs-title function_\">remove</span>(); \n}); \n\n<span class=\"hljs-comment\">//可以绑定并触发</span>\n$(<span class=\"hljs-string\">&quot;.li&quot;</span>).<span class=\"hljs-title function_\">on</span>(“click“, <span class=\"hljs-string\">&quot;.del&quot;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n    $(<span class=\"hljs-variable language_\">this</span>).<span class=\"hljs-title function_\">parent</span>().<span class=\"hljs-title function_\">remove</span>(); \n})\n</code></pre>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">关于on()方法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">方法参数</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">基本实例</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">组合实例</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">小结</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1049, '# 关于on()方法\n\n自Jquery1.7起，on()方法是 bind()、live()、delegate() 方法的新的替代品。\n\n但这不并意味着其他处理事件绑定的方法没有意义，实际开发过程中可以依照场景选择某些方法。\n\n# bind()方法\n\nbind()方法将事件类型和一个事件处理函数直接注册到了被选中的DOM元素中。\n\n当使用它来连接事件处理函数时,它仍然非常简洁,但是也存在着一些性能方面的问题\n\n```js\n//bind() 方法将事件类型和一个事件处理函数直接注册到了被选中的DOM元素中。 \n//常见的click()方法是bind()方法的简写\n$(\"#add\").bind(\"click\",function(e){}); \n//等效\n$(\"#add\").click(function(e){});\n```\n\n优点:\n\n - 适用于各种浏览器\n - 连接事件处理函数非常方便快捷\n - 可以使用.click()、.hover()等简写方法来更方面地连接事件处理函数\n - 对于简单的ID选择器，使用bind()方法可以很快地连接事件处理函数，而且当事件被触发时，事件处理函数几乎是马上就被调用了\n\n缺点:\n\n - 当匹配多个元素时，会将所有的事件处理函数附加到所有匹配的元素\n - **不可以动态地匹配相同选择器的元素**\n - 操作大量匹配的元素时会有性能方面的问题\n - 附加操作是在前期完成的,这可能导致页面加载时存在性能问题\n\n# live()方法\n\nlive()方法在使用时与bind()方法一致，但在实际处理时，存在一个委托机制。\n\n方法将与事件处理函数关联的选择器和事件信息一起附加到文档的根级元素（即document）。\n\n通过将事件信息注册到document上，这个事件处理函数将允许所有冒泡到document的事件调用它。\n\n一旦有一个事件冒泡到document元素上，Jquery会根据选择器或者事件的元数据来决定哪一个事件处理函数应该被调用。\n\n这个工作在用户交互时对性能方面造成一定的影响，但是初始化注册事件的过程相当地快。\n\n```js\n$(\"#add\").live(\"click\",function(e){}); \n```\n\n优点:\n\n - 所有事件处理函数都只注册一次，不像bind()那样进行多次注册\n - 将bind()方法升级到live()方法非常方便，你仅需要将\"bind\"替代为\"live\"\n - 动态添加到DOM的元素也将被神奇的匹配到，真实的事件信息是被注册到document元素上的\n - 可以在文档加载完之前连接事件处理函数，这样可以更好地利用时间\n\n缺点:\n\n - Jquery1.7以后的版本被弃用，应该在代码里逐步放弃使用它\n - 使用这个方法时链式操作没有得到正确的支持，可能会出错\n - 所做的匹配操作基本上没用，因为它只用于在document元素上注册事件处理函数\n - 使用event.stopPropogation()方法将会没用，事件已经被委托到了document\n - 所有的选择器或者事件信息都被附加到document元素上了，所以一旦有一个事件要调用某个事件处理函数，Jquery会在一大堆储存的元数据中使用matchesSelector方法来决定哪一个事件处理函数将会被调用\n - 所连接的事件总是被委托到document上，所如果你的DOM的层级很深的话，会导致一定的性能问题\n\n# delegate()方法\n\ndelegate()方法与live()方式实现方式相类似，但不是将选择器或者事件信息附加到document，而是让你指定附加的元素\n与live()方法类似的地方在于，这个方法也是使用事件委托来完成\n\n```js\n//#add将作为根元素进行事件委托\n$(\"#add\").delegate(\"a\",\"click\",function(e){});\n```\n\n优点:\n\n - 可以选择将选择器或者事件信息附加到指定的元素\n - 匹配操作实际上在前面并没有执行，而是用来注册到指定的元素\n - 链式操作可以得到正确的支持\n - Jquery仍然需要迭代这些选择器或者事件信息来匹配元素，不过选择的元素作为根元素，所以筛选的量会大幅减少\n - 使用了事件委托机制，可以匹配到被动态地添加到DOM的元素\n - 可以在文档加载完之前连接事件处理函数\n\n缺点:\n\n - bind()方法不可以直接升级到delegate()方法\n - Jquery仍然需要使用marchesSelector方法在附加到指定根元素的选择器或者事件信息中筛选决定哪一个事件处理函数会被调用\n - 当操作大量匹配的元素时会有性能方面的问题\n\n# on()方法\n\n在Jquery1.7版本后bind()、live()和delegate()方法只需要使用on()方法一种方式来调用它们\n\n```js\n//基本实例\n$(\"p\").on(\"click\",function(e){});\n```\n\n优点:\n\n - 使各种事件绑定方法一致\n - 在Jquery源码中bind()、live()、delegate()方法实际上是调用了此方法，简化了jQuery代码库并删除了一级重定向\n - 提供了使用delegate()方法的优点，并且仍然提供对bind()方法的支持\n\n缺点:\n\n - 给人带来了一些疑惑，因为方法的实际执行方式将根据你如何调用方法而改变\n\n# 小结\n\n1. 减少使用bind()方法，因为它把同一个事件处理函数附加到了每一个匹配的元素上\n2. 停用live()方法，因为它已经被弃用了同时也会带来很多问题\n3. delegate()方法会给你带来很多好处当你需要解决一些性能上的问题和对动态添加的元素作出处理\n4. on()方法其实就是模拟bind()、live()、delegate()实现的语法糖，具体取决于你如何调用它\n5. 尽量使用新的on()方法，尤其在Jquery1.7版本后尽情使用该方法！', '<h1 id=\"menu_1\">关于on()方法</h1><p>自Jquery1.7起，on()方法是 bind()、live()、delegate() 方法的新的替代品。</p>\n<p>但这不并意味着其他处理事件绑定的方法没有意义，实际开发过程中可以依照场景选择某些方法。</p>\n<h1 id=\"menu_2\">bind()方法</h1><p>bind()方法将事件类型和一个事件处理函数直接注册到了被选中的DOM元素中。</p>\n<p>当使用它来连接事件处理函数时,它仍然非常简洁,但是也存在着一些性能方面的问题</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//bind() 方法将事件类型和一个事件处理函数直接注册到了被选中的DOM元素中。 </span>\n<span class=\"hljs-comment\">//常见的click()方法是bind()方法的简写</span>\n$(<span class=\"hljs-string\">&quot;#add&quot;</span>).<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>){}); \n<span class=\"hljs-comment\">//等效</span>\n$(<span class=\"hljs-string\">&quot;#add&quot;</span>).<span class=\"hljs-title function_\">click</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>){});\n</code></pre>\n<p>优点:</p>\n<ul>\n<li>适用于各种浏览器</li>\n<li>连接事件处理函数非常方便快捷</li>\n<li>可以使用.click()、.hover()等简写方法来更方面地连接事件处理函数</li>\n<li>对于简单的ID选择器，使用bind()方法可以很快地连接事件处理函数，而且当事件被触发时，事件处理函数几乎是马上就被调用了</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>当匹配多个元素时，会将所有的事件处理函数附加到所有匹配的元素</li>\n<li><strong>不可以动态地匹配相同选择器的元素</strong></li>\n<li>操作大量匹配的元素时会有性能方面的问题</li>\n<li>附加操作是在前期完成的,这可能导致页面加载时存在性能问题</li>\n</ul>\n<h1 id=\"menu_3\">live()方法</h1><p>live()方法在使用时与bind()方法一致，但在实际处理时，存在一个委托机制。</p>\n<p>方法将与事件处理函数关联的选择器和事件信息一起附加到文档的根级元素（即document）。</p>\n<p>通过将事件信息注册到document上，这个事件处理函数将允许所有冒泡到document的事件调用它。</p>\n<p>一旦有一个事件冒泡到document元素上，Jquery会根据选择器或者事件的元数据来决定哪一个事件处理函数应该被调用。</p>\n<p>这个工作在用户交互时对性能方面造成一定的影响，但是初始化注册事件的过程相当地快。</p>\n<pre><code class=\"hljs language-js\">$(<span class=\"hljs-string\">&quot;#add&quot;</span>).<span class=\"hljs-title function_\">live</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>){}); \n</code></pre>\n<p>优点:</p>\n<ul>\n<li>所有事件处理函数都只注册一次，不像bind()那样进行多次注册</li>\n<li>将bind()方法升级到live()方法非常方便，你仅需要将&quot;bind&quot;替代为&quot;live&quot;</li>\n<li>动态添加到DOM的元素也将被神奇的匹配到，真实的事件信息是被注册到document元素上的</li>\n<li>可以在文档加载完之前连接事件处理函数，这样可以更好地利用时间</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>Jquery1.7以后的版本被弃用，应该在代码里逐步放弃使用它</li>\n<li>使用这个方法时链式操作没有得到正确的支持，可能会出错</li>\n<li>所做的匹配操作基本上没用，因为它只用于在document元素上注册事件处理函数</li>\n<li>使用event.stopPropogation()方法将会没用，事件已经被委托到了document</li>\n<li>所有的选择器或者事件信息都被附加到document元素上了，所以一旦有一个事件要调用某个事件处理函数，Jquery会在一大堆储存的元数据中使用matchesSelector方法来决定哪一个事件处理函数将会被调用</li>\n<li>所连接的事件总是被委托到document上，所如果你的DOM的层级很深的话，会导致一定的性能问题</li>\n</ul>\n<h1 id=\"menu_4\">delegate()方法</h1><p>delegate()方法与live()方式实现方式相类似，但不是将选择器或者事件信息附加到document，而是让你指定附加的元素<br/>与live()方法类似的地方在于，这个方法也是使用事件委托来完成</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//#add将作为根元素进行事件委托</span>\n$(<span class=\"hljs-string\">&quot;#add&quot;</span>).<span class=\"hljs-title function_\">delegate</span>(<span class=\"hljs-string\">&quot;a&quot;</span>,<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>){});\n</code></pre>\n<p>优点:</p>\n<ul>\n<li>可以选择将选择器或者事件信息附加到指定的元素</li>\n<li>匹配操作实际上在前面并没有执行，而是用来注册到指定的元素</li>\n<li>链式操作可以得到正确的支持</li>\n<li>Jquery仍然需要迭代这些选择器或者事件信息来匹配元素，不过选择的元素作为根元素，所以筛选的量会大幅减少</li>\n<li>使用了事件委托机制，可以匹配到被动态地添加到DOM的元素</li>\n<li>可以在文档加载完之前连接事件处理函数</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>bind()方法不可以直接升级到delegate()方法</li>\n<li>Jquery仍然需要使用marchesSelector方法在附加到指定根元素的选择器或者事件信息中筛选决定哪一个事件处理函数会被调用</li>\n<li>当操作大量匹配的元素时会有性能方面的问题</li>\n</ul>\n<h1 id=\"menu_5\">on()方法</h1><p>在Jquery1.7版本后bind()、live()和delegate()方法只需要使用on()方法一种方式来调用它们</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//基本实例</span>\n$(<span class=\"hljs-string\">&quot;p&quot;</span>).<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>){});\n</code></pre>\n<p>优点:</p>\n<ul>\n<li>使各种事件绑定方法一致</li>\n<li>在Jquery源码中bind()、live()、delegate()方法实际上是调用了此方法，简化了jQuery代码库并删除了一级重定向</li>\n<li>提供了使用delegate()方法的优点，并且仍然提供对bind()方法的支持</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>给人带来了一些疑惑，因为方法的实际执行方式将根据你如何调用方法而改变</li>\n</ul>\n<h1 id=\"menu_6\">小结</h1><ol>\n<li>减少使用bind()方法，因为它把同一个事件处理函数附加到了每一个匹配的元素上</li>\n<li>停用live()方法，因为它已经被弃用了同时也会带来很多问题</li>\n<li>delegate()方法会给你带来很多好处当你需要解决一些性能上的问题和对动态添加的元素作出处理</li>\n<li>on()方法其实就是模拟bind()、live()、delegate()实现的语法糖，具体取决于你如何调用它</li>\n<li>尽量使用新的on()方法，尤其在Jquery1.7版本后尽情使用该方法！</li>\n</ol>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">关于on()方法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">bind()方法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">live()方法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">delegate()方法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">on()方法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl1\">小结</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1050, '# 前言说明\n\n前端界面中经常需要获取事件的源节点以便进行后续的操作。\n\n由于在前端界面中经常处理的是click事件，本文均已click事件进行举例。\n\n其他事件类似，使用对应的方法即可。\n\n比较常见的事件有：\n\n - change		元素/内容改变\n - scroll		滚动\n - blur			失去焦点\n - focus		聚焦\n - input		输入\n - drag			拖动\n - click		点击\n - mousedown	鼠标按下\n - mousemove	鼠标移动\n - mouseup		鼠标松开\n - keydown		键盘按键按下\n\n# 直接绑定方法\n\nHTML部分\n\n```html\n<a onclick=\"deleteNo(this)\">DelBtn</a>\n```\n\nJS部分\n\n```js\nfunction deleteNo(this)\n{\n	//this便是该a标签节点\n}\n```\n\n - 优点：节点获取精准，不易与其他内容冲突\n - 缺点：HTML绑定事件的写法不易与通过动态生成\n\n# Jquery绑定方式\n\n引入Jquery有两种常见的获取源节点的方式，两者有轻微差异，请阅代码\n\nHTML部分\n\n```html\n<button id=\"del_btn\">DelBtn</button>\n```\n\nJS部分\n\n```js\n//方式1直接绑定click事件\n$(\"#del_btn\").click(function(){ \n	//$(this)便是触发的节点\n    var obj = $(this);\n});\n//方式2通过on进行事件绑定（推荐）\n//方法2支持对动态生成的HTML元素节点进行绑定（关键）\n//方法2支持对子级元素的绑定\n$(\"#del_btn\").on(\"click\", function(){\n    //$(this)便是触发的节点\n    var obj = $(this);\n});\n```\n\n - 优点：提供更高的自定义能力\n - 缺点：由于元素重叠冒泡事件触发，可能导致源节点获取不准确\n\n# event对象\n\n需要考虑火狐兼容性，通过事件本身获取源节点\n\nJS部分\n\n```js\nvar event = window.event || arguments.callee.caller.arguments[0];\n//obj就是我们要获取的节点\nvar obj = event.srcElement || event.target;\n//可以转成Jquery对象，方便各种使用\nvar useObj = $(obj);\n```\n\n - 优点：具有更高的自定义能力\n - 缺点：由于元素重叠冒泡事件触发，可能导致源节点获取不准确', '<h1 id=\"menu_1\">前言说明</h1><p>前端界面中经常需要获取事件的源节点以便进行后续的操作。</p>\n<p>由于在前端界面中经常处理的是click事件，本文均已click事件进行举例。</p>\n<p>其他事件类似，使用对应的方法即可。</p>\n<p>比较常见的事件有：</p>\n<ul>\n<li>change        元素/内容改变</li>\n<li>scroll        滚动</li>\n<li>blur            失去焦点</li>\n<li>focus        聚焦</li>\n<li>input        输入</li>\n<li>drag            拖动</li>\n<li>click        点击</li>\n<li>mousedown    鼠标按下</li>\n<li>mousemove    鼠标移动</li>\n<li>mouseup        鼠标松开</li>\n<li>keydown        键盘按键按下</li>\n</ul>\n<h1 id=\"menu_2\">直接绑定方法</h1><p>HTML部分</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">onclick</span>=<span class=\"hljs-string\">&quot;deleteNo(this)&quot;</span>&gt;</span>DelBtn<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n</code></pre>\n<p>JS部分</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">deleteNo</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">this</span></span>)\n{\n    <span class=\"hljs-comment\">//this便是该a标签节点</span>\n}\n</code></pre>\n<ul>\n<li>优点：节点获取精准，不易与其他内容冲突</li>\n<li>缺点：HTML绑定事件的写法不易与通过动态生成</li>\n</ul>\n<h1 id=\"menu_3\">Jquery绑定方式</h1><p>引入Jquery有两种常见的获取源节点的方式，两者有轻微差异，请阅代码</p>\n<p>HTML部分</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;del_btn&quot;</span>&gt;</span>DelBtn<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</code></pre>\n<p>JS部分</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//方式1直接绑定click事件</span>\n$(<span class=\"hljs-string\">&quot;#del_btn&quot;</span>).<span class=\"hljs-title function_\">click</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){ \n    <span class=\"hljs-comment\">//$(this)便是触发的节点</span>\n    <span class=\"hljs-keyword\">var</span> obj = $(<span class=\"hljs-variable language_\">this</span>);\n});\n<span class=\"hljs-comment\">//方式2通过on进行事件绑定（推荐）</span>\n<span class=\"hljs-comment\">//方法2支持对动态生成的HTML元素节点进行绑定（关键）</span>\n<span class=\"hljs-comment\">//方法2支持对子级元素的绑定</span>\n$(<span class=\"hljs-string\">&quot;#del_btn&quot;</span>).<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n    <span class=\"hljs-comment\">//$(this)便是触发的节点</span>\n    <span class=\"hljs-keyword\">var</span> obj = $(<span class=\"hljs-variable language_\">this</span>);\n});\n</code></pre>\n<ul>\n<li>优点：提供更高的自定义能力</li>\n<li>缺点：由于元素重叠冒泡事件触发，可能导致源节点获取不准确</li>\n</ul>\n<h1 id=\"menu_4\">event对象</h1><p>需要考虑火狐兼容性，通过事件本身获取源节点</p>\n<p>JS部分</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> event = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">event</span> || <span class=\"hljs-variable language_\">arguments</span>.<span class=\"hljs-property\">callee</span>.<span class=\"hljs-property\">caller</span>.<span class=\"hljs-property\">arguments</span>[<span class=\"hljs-number\">0</span>];\n<span class=\"hljs-comment\">//obj就是我们要获取的节点</span>\n<span class=\"hljs-keyword\">var</span> obj = event.<span class=\"hljs-property\">srcElement</span> || event.<span class=\"hljs-property\">target</span>;\n<span class=\"hljs-comment\">//可以转成Jquery对象，方便各种使用</span>\n<span class=\"hljs-keyword\">var</span> useObj = $(obj);\n</code></pre>\n<ul>\n<li>优点：具有更高的自定义能力</li>\n<li>缺点：由于元素重叠冒泡事件触发，可能导致源节点获取不准确</li>\n</ul>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">前言说明</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">直接绑定方法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">Jquery绑定方式</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">event对象</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1051, '# 场景描述\n\n关于单点登录场景有很多解决，比如常见的CAS统一鉴权中心，但这依赖于一个统一的CAS服务。\n\n而本文当时所遇到的场景是，鉴权中心仅能提供一个接口供调用。\n\n实现站点间交互、需要获取他人的鉴权返回信息实现同步登录等场景。\n\n最简单是直接使用ajax进行跨域请求，并获取返回进行处理。\n\n鉴权中心同意开放跨域访问，后来通过评审我们一致认为这种方式有很大的安全隐患。\n\n稍微懂点技术的Hacker使用一个开源的BurpSuite就能篡改请求&返回进行伪造登陆。\n\n# HttpClient\n\nApache Jakarta Common下的子项目，可以用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包。\n\n实现了所有 HTTP 的方法GET,POST,PUT,HEAD等。\n\n - 支持自动转向\n - 支持 HTTPS 协议\n - 支持代理服务器等\n\n简而言之，HttpClient最大的作用是为了实现在服务端发送Http请求\n\n## POST发送\n\n```java\npublic class MyTestServiceRequest extends HttpServlet\n{\n\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\n{\n    this.doPost(req, resp);\n}\n\n@Override\nprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\n{\n    System.setProperty(\"org.apache.commons.logging.Log\", \"org.apache.commons.logging.impl.SimpleLog\");\n    System.setProperty(\"org.apache.commons.logging.simplelog.showdatetime\", \"true\");\n    System.setProperty(\"org.apache.commons.logging.simplelog.log.org.apache.commons.httpclient\", \"stdout\");\n    String url = 请求地址;\n    String xmlString = 需要发送的XML格式信息;\n    HttpClient client = new HttpClient();\n    PostMethod myPost = new PostMethod(url);\n	//超时时间\n    client.getParams().setSoTimeout(300*1000);  \n    String responseString = null;\n    try{\n		//设置请求头\n        myPost.setRequestEntity(new StringRequestEntity(xmlString,\"text/xml\",\"utf-8\")); \n        //执行发送\n		int statusCode = client.executeMethod(myPost);\n		//如果返回码200，成功\n        if(statusCode == HttpStatus.SC_OK)   \n        {\n            BufferedInputStream bis = new BufferedInputStream(myPost.getResponseBodyAsStream());  //读取rsp的body体\n            byte[] bytes = new byte[1024];\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            int count = 0;\n            while((count = bis.read(bytes))!= -1)\n            {\n                bos.write(bytes, 0, count);\n            }\n            byte[] strByte = bos.toByteArray();\n            responseString = new String(strByte,0,strByte.length,\"utf-8\");  //转成String\n            Map<String,String> authMap = new HashMap<String,String>();\n            if(null!=responseString&&!\"\".equals(responseString))\n            {\n				//String转XML\n                authMap = xmlElements(responseString); \n				//鉴权成功       \n                if(\"true\".equals(authMap.get(\"result\")))  \n                {\n                    //远程鉴权成功的后续操作\n                }else{\n                    //远程鉴权失败的后续操作\n                }\n            }\n            bos.close();\n            bis.close();\n        }\n    }catch (Exception e) {\n        //异常处理 \n    }\n    myPost.releaseConnection();\n    client.getHttpConnectionManager().closeIdleConnections(0);\n}\n\n/**\n * 解析返回的XMLBody体\n */\npublic Map<String,String> xmlElements(String xmlDoc) {…略…}\n\n\n@Override\nprotected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\n{\n    this.doPost(req, resp);\n}\n}\n```\n\n## POST接收\n\n这个实例意义不大，JAVA服务端接受POST请求直接用常规Servlet即可。\n\n```java\npublic class MyTestServiceResponse extends HttpServlet\n{\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\n{\n  this.doPost(req, resp);\n}\n@Override\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n{\n    try\n    {\n        InputStream is = request.getInputStream(); //获取HTTP请求的输入流        \n        BufferedReader br = new BufferedReader(new InputStreamReader(is,\"UTF-8\"));  //以HTTP请求输入流建立一个BufferedReader对象       \n        String buffer = null; //读取HTTP请求内容 \n        StringBuffer sb = new StringBuffer();\n        while ((buffer = br.readLine()) != null)\n        {\n            sb.append(buffer+\"n\"); //读取所有的信息，并追加 转行\n        }\n        PrintWriter out = response.getWriter();\n        StringBuffer stringBuffer = new StringBuffer(\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\");//建议返回体\n        stringBuffer.append(\"返回信息\");\n        ……\n        stringBuffer.append(\"返回信息\");\n        out.write(stringBuffer.toString());\n        out.flush();\n        out.close();\n    } catch (Exception e) {\n        //异常处理\n    }\n}\n}\n```\n\n# 结语\n\n本质上来讲采用HttpClient实现服务端处理http请求的意义不是很大，现在SpringMVC和struts相当易用。', '<h1 id=\"menu_1\">场景描述</h1><p>关于单点登录场景有很多解决，比如常见的CAS统一鉴权中心，但这依赖于一个统一的CAS服务。</p>\n<p>而本文当时所遇到的场景是，鉴权中心仅能提供一个接口供调用。</p>\n<p>实现站点间交互、需要获取他人的鉴权返回信息实现同步登录等场景。</p>\n<p>最简单是直接使用ajax进行跨域请求，并获取返回进行处理。</p>\n<p>鉴权中心同意开放跨域访问，后来通过评审我们一致认为这种方式有很大的安全隐患。</p>\n<p>稍微懂点技术的Hacker使用一个开源的BurpSuite就能篡改请求&amp;返回进行伪造登陆。</p>\n<h1 id=\"menu_2\">HttpClient</h1><p>Apache Jakarta Common下的子项目，可以用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包。</p>\n<p>实现了所有 HTTP 的方法GET,POST,PUT,HEAD等。</p>\n<ul>\n<li>支持自动转向</li>\n<li>支持 HTTPS 协议</li>\n<li>支持代理服务器等</li>\n</ul>\n<p>简而言之，HttpClient最大的作用是为了实现在服务端发送Http请求</p>\n<h2 id=\"menu_3\">POST发送</h2><pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyTestServiceRequest</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">HttpServlet</span>\n{\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doGet</span><span class=\"hljs-params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"hljs-keyword\">throws</span> ServletException, IOException\n{\n    <span class=\"hljs-built_in\">this</span>.doPost(req, resp);\n}\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doPost</span><span class=\"hljs-params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"hljs-keyword\">throws</span> ServletException, IOException\n{\n    System.setProperty(<span class=\"hljs-string\">&quot;org.apache.commons.logging.Log&quot;</span>, <span class=\"hljs-string\">&quot;org.apache.commons.logging.impl.SimpleLog&quot;</span>);\n    System.setProperty(<span class=\"hljs-string\">&quot;org.apache.commons.logging.simplelog.showdatetime&quot;</span>, <span class=\"hljs-string\">&quot;true&quot;</span>);\n    System.setProperty(<span class=\"hljs-string\">&quot;org.apache.commons.logging.simplelog.log.org.apache.commons.httpclient&quot;</span>, <span class=\"hljs-string\">&quot;stdout&quot;</span>);\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">url</span> <span class=\"hljs-operator\">=</span> 请求地址;\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">xmlString</span> <span class=\"hljs-operator\">=</span> 需要发送的XML格式信息;\n    <span class=\"hljs-type\">HttpClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HttpClient</span>();\n    <span class=\"hljs-type\">PostMethod</span> <span class=\"hljs-variable\">myPost</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PostMethod</span>(url);\n    <span class=\"hljs-comment\">//超时时间</span>\n    client.getParams().setSoTimeout(<span class=\"hljs-number\">300</span>*<span class=\"hljs-number\">1000</span>);  \n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">responseString</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n    <span class=\"hljs-keyword\">try</span>{\n        <span class=\"hljs-comment\">//设置请求头</span>\n        myPost.setRequestEntity(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringRequestEntity</span>(xmlString,<span class=\"hljs-string\">&quot;text/xml&quot;</span>,<span class=\"hljs-string\">&quot;utf-8&quot;</span>)); \n        <span class=\"hljs-comment\">//执行发送</span>\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">statusCode</span> <span class=\"hljs-operator\">=</span> client.executeMethod(myPost);\n        <span class=\"hljs-comment\">//如果返回码200，成功</span>\n        <span class=\"hljs-keyword\">if</span>(statusCode == HttpStatus.SC_OK)   \n        {\n            <span class=\"hljs-type\">BufferedInputStream</span> <span class=\"hljs-variable\">bis</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedInputStream</span>(myPost.getResponseBodyAsStream());  <span class=\"hljs-comment\">//读取rsp的body体</span>\n            <span class=\"hljs-type\">byte</span>[] bytes = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">byte</span>[<span class=\"hljs-number\">1024</span>];\n            <span class=\"hljs-type\">ByteArrayOutputStream</span> <span class=\"hljs-variable\">bos</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ByteArrayOutputStream</span>();\n            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n            <span class=\"hljs-keyword\">while</span>((count = bis.read(bytes))!= -<span class=\"hljs-number\">1</span>)\n            {\n                bos.write(bytes, <span class=\"hljs-number\">0</span>, count);\n            }\n            <span class=\"hljs-type\">byte</span>[] strByte = bos.toByteArray();\n            responseString = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(strByte,<span class=\"hljs-number\">0</span>,strByte.length,<span class=\"hljs-string\">&quot;utf-8&quot;</span>);  <span class=\"hljs-comment\">//转成String</span>\n            Map&lt;String,String&gt; authMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;String,String&gt;();\n            <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-literal\">null</span>!=responseString&amp;&amp;!<span class=\"hljs-string\">&quot;&quot;</span>.equals(responseString))\n            {\n                <span class=\"hljs-comment\">//String转XML</span>\n                authMap = xmlElements(responseString); \n                <span class=\"hljs-comment\">//鉴权成功       </span>\n                <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-string\">&quot;true&quot;</span>.equals(authMap.get(<span class=\"hljs-string\">&quot;result&quot;</span>)))  \n                {\n                    <span class=\"hljs-comment\">//远程鉴权成功的后续操作</span>\n                }<span class=\"hljs-keyword\">else</span>{\n                    <span class=\"hljs-comment\">//远程鉴权失败的后续操作</span>\n                }\n            }\n            bos.close();\n            bis.close();\n        }\n    }<span class=\"hljs-keyword\">catch</span> (Exception e) {\n        <span class=\"hljs-comment\">//异常处理 </span>\n    }\n    myPost.releaseConnection();\n    client.getHttpConnectionManager().closeIdleConnections(<span class=\"hljs-number\">0</span>);\n}\n\n<span class=\"hljs-comment\">/**\n * 解析返回的XMLBody体\n */</span>\n<span class=\"hljs-keyword\">public</span> Map&lt;String,String&gt; <span class=\"hljs-title function_\">xmlElements</span><span class=\"hljs-params\">(String xmlDoc)</span> {…略…}\n\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doPut</span><span class=\"hljs-params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"hljs-keyword\">throws</span> ServletException, IOException\n{\n    <span class=\"hljs-built_in\">this</span>.doPost(req, resp);\n}\n}\n</code></pre>\n<h2 id=\"menu_4\">POST接收</h2><p>这个实例意义不大，JAVA服务端接受POST请求直接用常规Servlet即可。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyTestServiceResponse</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">HttpServlet</span>\n{\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doGet</span><span class=\"hljs-params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"hljs-keyword\">throws</span> ServletException, IOException\n{\n  <span class=\"hljs-built_in\">this</span>.doPost(req, resp);\n}\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doPost</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"hljs-keyword\">throws</span> ServletException, IOException\n{\n    <span class=\"hljs-keyword\">try</span>\n    {\n        <span class=\"hljs-type\">InputStream</span> <span class=\"hljs-variable\">is</span> <span class=\"hljs-operator\">=</span> request.getInputStream(); <span class=\"hljs-comment\">//获取HTTP请求的输入流        </span>\n        <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">br</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(is,<span class=\"hljs-string\">&quot;UTF-8&quot;</span>));  <span class=\"hljs-comment\">//以HTTP请求输入流建立一个BufferedReader对象       </span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">//读取HTTP请求内容 </span>\n        <span class=\"hljs-type\">StringBuffer</span> <span class=\"hljs-variable\">sb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuffer</span>();\n        <span class=\"hljs-keyword\">while</span> ((buffer = br.readLine()) != <span class=\"hljs-literal\">null</span>)\n        {\n            sb.append(buffer+<span class=\"hljs-string\">&quot;n&quot;</span>); <span class=\"hljs-comment\">//读取所有的信息，并追加 转行</span>\n        }\n        <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">out</span> <span class=\"hljs-operator\">=</span> response.getWriter();\n        <span class=\"hljs-type\">StringBuffer</span> <span class=\"hljs-variable\">stringBuffer</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuffer</span>(<span class=\"hljs-string\">&quot;&lt;?xml version=&quot;</span><span class=\"hljs-number\">1.0</span><span class=\"hljs-string\">&quot; encoding=&quot;</span>UTF-<span class=\"hljs-number\">8</span><span class=\"hljs-string\">&quot;?&gt;&quot;</span>);<span class=\"hljs-comment\">//建议返回体</span>\n        stringBuffer.append(<span class=\"hljs-string\">&quot;返回信息&quot;</span>);\n        ……\n        stringBuffer.append(<span class=\"hljs-string\">&quot;返回信息&quot;</span>);\n        out.write(stringBuffer.toString());\n        out.flush();\n        out.close();\n    } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n        <span class=\"hljs-comment\">//异常处理</span>\n    }\n}\n}\n</code></pre>\n<h1 id=\"menu_5\">结语</h1><p>本质上来讲采用HttpClient实现服务端处理http请求的意义不是很大，现在SpringMVC和struts相当易用。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">场景描述</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">HttpClient</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">POST发送</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">POST接收</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">结语</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1052, '# 关于磁盘挂载\n\n在Linux环境中的磁盘与Windows系统最大的差别就是可以自由挂载。\n\n可以将磁盘理解为即插即用的U盘或者移动硬盘。\n\n通常我们会比较习惯将大储存的磁盘挂载在/home路径下，如下所示：\n\n```shell\nFilesystem	Size	Used	Avail	Use%	Mounted on\n/dev/xvda2	36G	16G	19G	46%	/\ndevtmpfs	3.9G	96K	3.9G	1%	/dev\ntmpfs		5.0G	616M	4.4G	13%	/dev/shm\n/dev/xvde	289G	29.0G	270G 	10%	/home\nshmfs		5.0G	616M	4.4G	13%	/dev/shm\n```\n\n# 问题说明\n\n在Linux环境中比较标准的做法是新建单独的用户进行软件安装和配置，尽量减少root用户的直接使用。\n\n而有时候运维人员为了图省事会直接用root用户安装Oracle数据库。\n\n而root用户安装Oracle如果没有特别配置的化一般默认安装在/opt目录下。\n\n这种情况我们很快就会发现/opt目录被塞满，后期去安装其他软件时提示磁盘空间不足。\n\n**重申：建议安装Oracle数据库是新建一个oracle用户去操作（此账号是Linux用户）**\n\n那如果遇到上面提到的情况如何解决呢？\n\nOracle数据库的alert、trace已经监听日志都超级大，而我们一般不建议把日志能力关闭掉。\n\n对于已经安装好的Oracle而言的解决方案，迁移日志存放目录。\n\n# 操作流程\n\n1. 登陆oracle用户（或root用户）\n2. 先创建一个用于移植的目录 **mkdir /home/oracle/oradb**\n3. SYSDBA连接数据库 **sqlplus / as sysdba**\n\n```sql\n--查询各种日志当前存放目录（可以忽视这一步）\nshow parameter dump;\nshow parameter diagnostic_dest\nselect * from v$diag_info;\nselect * from v$diag_info where name =’Diag Alert’;\n--迁移日志存放根目录（diag的目录整体迁移）\nalter system set diagnostic_dest = ‘/home/oracle/oradb’;\n```\n\n迁移完成后，Oracle后期产生的日志就可以出现在/home/oracle/oradb。\n\n主要迁移diag目录下的所有日志。\n\n# 结语\n\n实际上无论是否通过root用户安装Oracle数据库，均可以采用上文方式进行目录的配置。', '<h1 id=\"menu_1\">关于磁盘挂载</h1><p>在Linux环境中的磁盘与Windows系统最大的差别就是可以自由挂载。</p>\n<p>可以将磁盘理解为即插即用的U盘或者移动硬盘。</p>\n<p>通常我们会比较习惯将大储存的磁盘挂载在/home路径下，如下所示：</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-title class_\">Filesystem</span>    <span class=\"hljs-title class_\">Size</span>    <span class=\"hljs-title class_\">Used</span>    <span class=\"hljs-title class_\">Avail</span>    <span class=\"hljs-title class_\">Use</span>%    <span class=\"hljs-title class_\">Mounted</span> on\n/dev/xvda2    36G    16G    19G    <span class=\"hljs-number\">46</span>%    /\ndevtmpfs    <span class=\"hljs-number\">3.</span>9G    96K    <span class=\"hljs-number\">3.</span>9G    <span class=\"hljs-number\">1</span>%    /dev\ntmpfs        <span class=\"hljs-number\">5.</span>0G    616M    <span class=\"hljs-number\">4.</span>4G    <span class=\"hljs-number\">13</span>%    <span class=\"hljs-regexp\">/dev/</span>shm\n/dev/xvde    289G    <span class=\"hljs-number\">29.</span>0G    270G     <span class=\"hljs-number\">10</span>%    /home\nshmfs        <span class=\"hljs-number\">5.</span>0G    616M    <span class=\"hljs-number\">4.</span>4G    <span class=\"hljs-number\">13</span>%    <span class=\"hljs-regexp\">/dev/</span>shm\n</code></pre>\n<h1 id=\"menu_2\">问题说明</h1><p>在Linux环境中比较标准的做法是新建单独的用户进行软件安装和配置，尽量减少root用户的直接使用。</p>\n<p>而有时候运维人员为了图省事会直接用root用户安装Oracle数据库。</p>\n<p>而root用户安装Oracle如果没有特别配置的化一般默认安装在/opt目录下。</p>\n<p>这种情况我们很快就会发现/opt目录被塞满，后期去安装其他软件时提示磁盘空间不足。</p>\n<p><strong>重申：建议安装Oracle数据库是新建一个oracle用户去操作（此账号是Linux用户）</strong></p>\n<p>那如果遇到上面提到的情况如何解决呢？</p>\n<p>Oracle数据库的alert、trace已经监听日志都超级大，而我们一般不建议把日志能力关闭掉。</p>\n<p>对于已经安装好的Oracle而言的解决方案，迁移日志存放目录。</p>\n<h1 id=\"menu_3\">操作流程</h1><ol>\n<li>登陆oracle用户（或root用户）</li>\n<li>先创建一个用于移植的目录 <strong>mkdir /home/oracle/oradb</strong></li>\n<li>SYSDBA连接数据库 <strong>sqlplus / as sysdba</strong></li>\n</ol>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">--查询各种日志当前存放目录（可以忽视这一步）</span>\n<span class=\"hljs-keyword\">show</span> <span class=\"hljs-keyword\">parameter</span> dump;\n<span class=\"hljs-keyword\">show</span> <span class=\"hljs-keyword\">parameter</span> diagnostic_dest\n<span class=\"hljs-keyword\">select</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">from</span> v$diag_info;\n<span class=\"hljs-keyword\">select</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">from</span> v$diag_info <span class=\"hljs-keyword\">where</span> name <span class=\"hljs-operator\">=</span>’Diag Alert’;\n<span class=\"hljs-comment\">--迁移日志存放根目录（diag的目录整体迁移）</span>\n<span class=\"hljs-keyword\">alter</span> <span class=\"hljs-keyword\">system</span> <span class=\"hljs-keyword\">set</span> diagnostic_dest <span class=\"hljs-operator\">=</span> ‘<span class=\"hljs-operator\">/</span>home<span class=\"hljs-operator\">/</span>oracle<span class=\"hljs-operator\">/</span>oradb’;\n</code></pre>\n<p>迁移完成后，Oracle后期产生的日志就可以出现在/home/oracle/oradb。</p>\n<p>主要迁移diag目录下的所有日志。</p>\n<h1 id=\"menu_4\">结语</h1><p>实际上无论是否通过root用户安装Oracle数据库，均可以采用上文方式进行目录的配置。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">关于磁盘挂载</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">问题说明</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">操作流程</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">结语</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1053, '# 关于.bat脚本说明\n\n.bat脚本主要用于Windows系统执行的脚本文件。\n\n实际就是将人为的系统操作使用DOS命令集合起来，通过脚本来完成自己想做的事情。\n\n只需要整理清自己执行任务的步骤，一步步写命令，附带一些控制语句，一个.bat脚本就完成了。\n\n当然，本文脚本仅作为抛砖引玉作用，可以提供一个制作.bat脚本的思路\n\n# 基本关键字\n\n本文不会详细描述系统行为所对应的DOS命令，主要针对bat脚本中一些关键字和词做解释。\n\n1. REM 和 :: （注释，以此开头的字符串会被认为脚本注释）\n2. ECHO 和 @ （打开或关闭执行回显，格式echo [{ on|off }]，注意@字符放在命令前将关闭该命令回显，无论此时echo是否为打开状态）\n3. PAUSE （暂停，停止系统命令的执行并显示下面的内容，一般用作按键提示）\n4. ERRORLEVEL （程序返回码，通过%errorlevel%可以取到上一句命令的返回码）\n5. TITLE （设置窗口标题，title 窗口标题名）\n6. COLOR （设置默认的控制台前景和背景颜色，color fc 白色背景红色前景）\n7. mode  （配置系统设备，该命令具备很多功能）\n8. GOTO 和 : （跳转，于:搭配使用，如goto jump和:jump，程序执行到goto jump会直接调到:jump向后执行，可用此做循环）\n9. FIND （文件中搜索字符串，基础用法 find 字符串 文件名）\n10. START （批处理中调用外部程序的命令，start gogo.exe，一般情况脚本不会因此停止会继续向下执行）\n11. assoc 和 ftype （设置文件拓展名和文件类型的关联，一般会用于编辑器或者播放器等设置脚本）\n12. pushd 和 popd （切换当前目录，pushd d:mp4保存一个目录，popd恢复并切换到该目录，一般会用于如记住安装目录）\n13. CALL （调用另一个批处理，当另一个批处理执行完后，再继续执行原来的批处理）\n14. shift （更改批处理文件中可替换参数的位置）\n15. IF （条件判断语句，这个不用多解释）\n16. setlocal 与 变量延迟 （建议单独深入了解）\n17. ATTRIB （显示或更改文件属性）\n\n# 实例代码\n\n在bat脚本中:号后面跟的内容是注释，执行的时候是会跳过。\n\n```bash\n:关闭控制台打印\n@echo off\n:获取当前日期，date获取日期DOS命令：2015–11–09星期四，~0,4表示截取第0位的后四位(2015)，~5,2(11)，~8,2(09)\nset ThisDay=%date:~0,4%%date:~5,2%%date:~8,2%\nset /a YestDays=%ThisDay%-1\n:ThisDay结果是20151109，昨天的日期字符20151108(跨月的时候有问题)\nmd D:MebugsPackageHistory%YestDays%Service\n:进入归档路径\ncd /d D:MebugsPackageService\n:如果识别到昨天的归档包，进行拷贝到创建好的昨日备份\nif exist MEBUGS_PLUS_%YestDays%.zip (\ncopy /y MEBUGS_PLUS_%YestDays%.zip D:MebugsPackageHistory%YestDays%Service\n)\n:删除昨天的文件\ndel *_%YestDays%.zip\n```\n\n## 主要作用\n\n实际上我一开始使用ANT编译脚本实现归档之前的备份，那样操作是非常Easy的。\n\n但是由于逻辑组网(WLAN)的原因，编译环境没有办法跨子网进行文件操作。\n\n这个.bat脚本最终通过Windows定时任务，在每天00:05自动执行。\n\n## 待处理BUG\n\n跨月的时候，%ThisDay%-1这个计算结果有问题，但是，懒得改了Orz', '<h1 id=\"menu_1\">关于.bat脚本说明</h1><p>.bat脚本主要用于Windows系统执行的脚本文件。</p>\n<p>实际就是将人为的系统操作使用DOS命令集合起来，通过脚本来完成自己想做的事情。</p>\n<p>只需要整理清自己执行任务的步骤，一步步写命令，附带一些控制语句，一个.bat脚本就完成了。</p>\n<p>当然，本文脚本仅作为抛砖引玉作用，可以提供一个制作.bat脚本的思路</p>\n<h1 id=\"menu_2\">基本关键字</h1><p>本文不会详细描述系统行为所对应的DOS命令，主要针对bat脚本中一些关键字和词做解释。</p>\n<ol>\n<li>REM 和 :: （注释，以此开头的字符串会被认为脚本注释）</li>\n<li>ECHO 和 @ （打开或关闭执行回显，格式echo [{ on|off }]，注意@字符放在命令前将关闭该命令回显，无论此时echo是否为打开状态）</li>\n<li>PAUSE （暂停，停止系统命令的执行并显示下面的内容，一般用作按键提示）</li>\n<li>ERRORLEVEL （程序返回码，通过%errorlevel%可以取到上一句命令的返回码）</li>\n<li>TITLE （设置窗口标题，title 窗口标题名）</li>\n<li>COLOR （设置默认的控制台前景和背景颜色，color fc 白色背景红色前景）</li>\n<li>mode  （配置系统设备，该命令具备很多功能）</li>\n<li>GOTO 和 : （跳转，于:搭配使用，如goto jump和:jump，程序执行到goto jump会直接调到:jump向后执行，可用此做循环）</li>\n<li>FIND （文件中搜索字符串，基础用法 find 字符串 文件名）</li>\n<li>START （批处理中调用外部程序的命令，start gogo.exe，一般情况脚本不会因此停止会继续向下执行）</li>\n<li>assoc 和 ftype （设置文件拓展名和文件类型的关联，一般会用于编辑器或者播放器等设置脚本）</li>\n<li>pushd 和 popd （切换当前目录，pushd d:mp4保存一个目录，popd恢复并切换到该目录，一般会用于如记住安装目录）</li>\n<li>CALL （调用另一个批处理，当另一个批处理执行完后，再继续执行原来的批处理）</li>\n<li>shift （更改批处理文件中可替换参数的位置）</li>\n<li>IF （条件判断语句，这个不用多解释）</li>\n<li>setlocal 与 变量延迟 （建议单独深入了解）</li>\n<li>ATTRIB （显示或更改文件属性）</li>\n</ol>\n<h1 id=\"menu_3\">实例代码</h1><p>在bat脚本中:号后面跟的内容是注释，执行的时候是会跳过。</p>\n<pre><code class=\"hljs language-bash\">:关闭控制台打印\n<span class=\"hljs-variable\">@echo</span> off\n:获取当前日期，<span class=\"hljs-type\">date</span>获取日期DOS命令：<span class=\"hljs-number\">2015</span>–<span class=\"hljs-number\">11</span>–<span class=\"hljs-number\">09</span>星期四，<span class=\"hljs-operator\">~</span><span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">4</span>表示截取第<span class=\"hljs-number\">0</span>位的后四位(<span class=\"hljs-number\">2015</span>)，<span class=\"hljs-operator\">~</span><span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>(<span class=\"hljs-number\">11</span>)，<span class=\"hljs-operator\">~</span><span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">2</span>(<span class=\"hljs-number\">09</span>)\n<span class=\"hljs-keyword\">set</span> ThisDay<span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">%</span><span class=\"hljs-type\">date</span>:<span class=\"hljs-operator\">~</span><span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">4</span><span class=\"hljs-operator\">%</span><span class=\"hljs-operator\">%</span><span class=\"hljs-type\">date</span>:<span class=\"hljs-operator\">~</span><span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span><span class=\"hljs-operator\">%</span><span class=\"hljs-operator\">%</span><span class=\"hljs-type\">date</span>:<span class=\"hljs-operator\">~</span><span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">2</span><span class=\"hljs-operator\">%</span>\n<span class=\"hljs-keyword\">set</span> <span class=\"hljs-operator\">/</span>a YestDays<span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">%</span>ThisDay<span class=\"hljs-operator\">%</span><span class=\"hljs-number\">-1</span>\n:ThisDay结果是<span class=\"hljs-number\">20151109</span>，昨天的日期字符<span class=\"hljs-number\">20151108</span>(跨月的时候有问题)\nmd D:MebugsPackageHistory<span class=\"hljs-operator\">%</span>YestDays<span class=\"hljs-operator\">%</span>Service\n:进入归档路径\ncd <span class=\"hljs-operator\">/</span>d D:MebugsPackageService\n:如果识别到昨天的归档包，进行拷贝到创建好的昨日备份\nif exist MEBUGS_PLUS_<span class=\"hljs-operator\">%</span>YestDays<span class=\"hljs-operator\">%</span>.zip (\n<span class=\"hljs-keyword\">copy</span> <span class=\"hljs-operator\">/</span>y MEBUGS_PLUS_<span class=\"hljs-operator\">%</span>YestDays<span class=\"hljs-operator\">%</span>.zip D:MebugsPackageHistory<span class=\"hljs-operator\">%</span>YestDays<span class=\"hljs-operator\">%</span>Service\n)\n:删除昨天的文件\ndel <span class=\"hljs-operator\">*</span>_<span class=\"hljs-operator\">%</span>YestDays<span class=\"hljs-operator\">%</span>.zip\n</code></pre>\n<h2 id=\"menu_4\">主要作用</h2><p>实际上我一开始使用ANT编译脚本实现归档之前的备份，那样操作是非常Easy的。</p>\n<p>但是由于逻辑组网(WLAN)的原因，编译环境没有办法跨子网进行文件操作。</p>\n<p>这个.bat脚本最终通过Windows定时任务，在每天00:05自动执行。</p>\n<h2 id=\"menu_5\">待处理BUG</h2><p>跨月的时候，%ThisDay%-1这个计算结果有问题，但是，懒得改了Orz</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">关于.bat脚本说明</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">基本关键字</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">实例代码</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">主要作用</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">待处理BUG</a> <!----></li></ul></li></ul>');
INSERT INTO `post_info` VALUES (1054, '# 问题描述\n\n无论从安全性还是前后端数据处理的便捷性来说，使用POST请求会是绝大多数程序猿的首选。\n\n不过有时候中途投入某些项目的时候，你会发现整个项目的前后端结构已经固化。\n\n程序猿在时间不充裕的情况下只能去适应项目的现有风格。\n\n使用GET请求直接传递关键参数至服务端是比较不安全的做法，考虑到这个WEB项目是内网工程，倒也无可厚非。\n\n因此问题出现了，GET请求直接携带中文，后台接受时会出现乱码。\n\n# 前端encodeURI编码\n\n处理中文参数乱码的第一个步骤是在前端界面对参数进行encodeURI编码。\n\n实验表明需要编两次，具体原因似乎是编码类型。\n\n第二次编码的数据无论你原来是什么编码类型，都会变成UTF-8。\n\n```javascript\n//请求url拼接\nvar url = \"www.mebugs.com/getUser.go?id=\"+id+\"&name=\"+encodeURI(encodeURI(name));\n```\n\n> 题外话：假设页面端输入的中文是一个“中”，按照下面步骤进行解：\n> 第一次encodeURI，按照utf-8方式获取字节数组变成[-28,-72-83]，对字节码数组进行遍历，把每个字节转化成对应的16进制数，这样就变成了[E4,B8,AD],最后变成[%E4,%B8,%AD]，此时已经没有了多字节字符，全部是单字节字符。\n> 第二次encodeURI，进行编码会把%看成一个转义字符，并不编码%以后字符，会把%编码成%25.把数组最后变成[%25E4,%25B8,%25AD]然后就把处理后的数据[%25E4,%25B8,%25AD]发往服务器端。\n> 应用服务器调用getParameter方法，getParameter方法会去向应用服务器请求参数。\n> 应用服务器最初获得的就是发送来的[%25E4,%25B8,%25AD]，应用服务器会对这个数据进行URLdecode操作进行解码，不管是按照UTF-8，还是GBK，还是ISO-8859，都能得到[%E4,%B8,%AD]，因为都会把%25解析成%，并把这个值返回给getParameter方法。\n> 再用UTF-8解码一次，就得到\"中\"了。\n> 如果不编码两次，当服务器自动解码的时候，假如是按照ISO-8859去解码UTF-8编码的东西，就是会出现乱码。\n\n# 服务端解码\n\n服务端使用URLDecoder.decode对get请求携带的参数进行解码。\n\n```java\nString name = \"\";\ntry{\n	name = URLDecoder.decode(request.getParameter(\"name\")!=null?request.getParameter(\"name\"):\"\",\"UTF-8\");       \n} catch (UnsupportedEncodingException e)\n{ \n	//追加捕获异常的后续处理逻辑\n}\n```\n\n# 结尾小结\n\n非常不建议在GET请求中传递重要的参数，特别是中文类的参数。\n\n我们在编码过程中必然会遇到GET请求的地方，建议用于传递ID类的主键参数。', '<h1 id=\"menu_1\">问题描述</h1><p>无论从安全性还是前后端数据处理的便捷性来说，使用POST请求会是绝大多数程序猿的首选。</p>\n<p>不过有时候中途投入某些项目的时候，你会发现整个项目的前后端结构已经固化。</p>\n<p>程序猿在时间不充裕的情况下只能去适应项目的现有风格。</p>\n<p>使用GET请求直接传递关键参数至服务端是比较不安全的做法，考虑到这个WEB项目是内网工程，倒也无可厚非。</p>\n<p>因此问题出现了，GET请求直接携带中文，后台接受时会出现乱码。</p>\n<h1 id=\"menu_2\">前端encodeURI编码</h1><p>处理中文参数乱码的第一个步骤是在前端界面对参数进行encodeURI编码。</p>\n<p>实验表明需要编两次，具体原因似乎是编码类型。</p>\n<p>第二次编码的数据无论你原来是什么编码类型，都会变成UTF-8。</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">//请求url拼接</span>\n<span class=\"hljs-keyword\">var</span> url = <span class=\"hljs-string\">&quot;www.mebugs.com/getUser.go?id=&quot;</span>+id+<span class=\"hljs-string\">&quot;&amp;name=&quot;</span>+<span class=\"hljs-built_in\">encodeURI</span>(<span class=\"hljs-built_in\">encodeURI</span>(name));\n</code></pre>\n<blockquote>\n<p>题外话：假设页面端输入的中文是一个“中”，按照下面步骤进行解：<br/>第一次encodeURI，按照utf-8方式获取字节数组变成[-28,-72-83]，对字节码数组进行遍历，把每个字节转化成对应的16进制数，这样就变成了[E4,B8,AD],最后变成[%E4,%B8,%AD]，此时已经没有了多字节字符，全部是单字节字符。<br/>第二次encodeURI，进行编码会把%看成一个转义字符，并不编码%以后字符，会把%编码成%25.把数组最后变成[%25E4,%25B8,%25AD]然后就把处理后的数据[%25E4,%25B8,%25AD]发往服务器端。<br/>应用服务器调用getParameter方法，getParameter方法会去向应用服务器请求参数。<br/>应用服务器最初获得的就是发送来的[%25E4,%25B8,%25AD]，应用服务器会对这个数据进行URLdecode操作进行解码，不管是按照UTF-8，还是GBK，还是ISO-8859，都能得到[%E4,%B8,%AD]，因为都会把%25解析成%，并把这个值返回给getParameter方法。<br/>再用UTF-8解码一次，就得到&quot;中&quot;了。<br/>如果不编码两次，当服务器自动解码的时候，假如是按照ISO-8859去解码UTF-8编码的东西，就是会出现乱码。</p>\n</blockquote>\n<h1 id=\"menu_3\">服务端解码</h1><p>服务端使用URLDecoder.decode对get请求携带的参数进行解码。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-title class_\">String</span> name = <span class=\"hljs-string\">&quot;&quot;</span>;\n<span class=\"hljs-keyword\">try</span>{\n    name = URLDecoder.<span class=\"hljs-title function_\">decode</span>(request.<span class=\"hljs-title function_\">getParameter</span>(<span class=\"hljs-string\">&quot;name&quot;</span>)!=<span class=\"hljs-literal\">null</span>?request.<span class=\"hljs-title function_\">getParameter</span>(<span class=\"hljs-string\">&quot;name&quot;</span>):<span class=\"hljs-string\">&quot;&quot;</span>,<span class=\"hljs-string\">&quot;UTF-8&quot;</span>);       \n} <span class=\"hljs-keyword\">catch</span> (<span class=\"hljs-title class_\">UnsupportedEncodingException</span> e)\n{ \n    <span class=\"hljs-comment\">//追加捕获异常的后续处理逻辑</span>\n}\n</code></pre>\n<h1 id=\"menu_4\">结尾小结</h1><p>非常不建议在GET请求中传递重要的参数，特别是中文类的参数。</p>\n<p>我们在编码过程中必然会遇到GET请求的地方，建议用于传递ID类的主键参数。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">问题描述</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">前端encodeURI编码</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">服务端解码</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">结尾小结</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1055, '# 构造初始化\n\nBigDecimal类提供了四种构造方法进行对象的初始化。\n\n分别可以传入：int、double、long、string。\n\n**特别注意：即使表面上看起来一样的值，不同类型传入的最终值是不一样，比如doule类型的数据小数位会变得很长**\n\nBigDecimal类对象可以与int、double、long、string进行互转。\n\n```java\n//创建BigDecimal类对象\nBigDecimal intBD = new BigDecimal(123);\nBigDecimal douBD = new BigDecimal(123.123);\nBigDecimal strBD = new BigDecimal(\"123\");\nBigDecimal sdrBD = new BigDecimal(\"123.123\");\n```\n\n# 四类基本运算\n\nBigDecimal类提供了数学世界中的四类基本运算方法。\n\n```java\n//创建两个运算值\nBigDecimal noOne = new BigDecimal(123);\nBigDecimal noTwo = new BigDecimal(123);\n//加法\nBigDecimal addAs = noOne.add(noTwo);\n//减法\nBigDecimal subAs = noOne.subtract(noTwo); \n//乘法\nBigDecimal mulAs = noOne.multiply(noTwo);\n//除法\n//需要注意除法被除数不能为0哦\nBigDecimal divAs = noOne.divide(noTwo);\n//另一种写法（直接新建构造类）\nBigDecimal othAs = noOne.add(new BigDecimal(123));\n```\n\n# 除法精度控制\n\nBigDecimal类除法可以提供精度控制能力，具有三个入参分别是：被除数、小数位数、尾数取值模式。\n\n```java\n//除法实例，保留三位小数，四舍五入模式\nBigDecimal divAs = noOne.divide(noTwo,3,BigDecimal.ROUND_HALF_UP);\n//BigDecimal.ROUND_DOWN			删除多余位数\n//BigDecimal.ROUND_UP			删除多余位数，最后一位进一位\n//BigDecimal.ROUND_HALF_UP		四舍五入\n//BigDecimal.ROUND_HALF_DOWN	五舍六入\n```\n\n# 数据精度控制\n\nBigDecimal类独立提供了对数据进行精度控制的方法。\n\n```java\n//对已有数据进行精度控制，逡巡上方的几类模式，保留三位四舍五入\nnoTwo = noTwo.setScale(3,BigDecimal.ROUND_HALF_UP);\n//此处与上方相同支持多种形式\n```\n\n# 数值格式化\n\n```java\n//建立货币格式化引用\nNumberFormat currency = NumberFormat.getCurrencyInstance();\n//建立百分比格式化用\nNumberFormat percent = NumberFormat.getPercentInstance();\n//百分比小数点最多3位\npercent.setMaximumFractionDigits(3);\n//对数据进行货币格式化\ncurrency.format(mulAs);\n//对数据进行百分比格式化\npercent.format(divAs);\n```\n\n# 数值大小比较\n\nBigDecimal类的大小比较，返回一个int结果，有三个结果  1表示大于，0表示等于，-1表示小于。\n\n```java\nint cpAs = noOne.compareTo(noTwo);\n//BigDecimal类还提供了一些用于比较的常量，比如BigDecimal.ZERO\n//与零进行比较\nint cpAs = noOne.compareTo(BigDecimal.ZERO);\n```\n\n# 结尾小结\n\n实际上没什么需要小结的，常用实例已在上方列举出来了！', '<h1 id=\"menu_1\">构造初始化</h1><p>BigDecimal类提供了四种构造方法进行对象的初始化。</p>\n<p>分别可以传入：int、double、long、string。</p>\n<p><strong>特别注意：即使表面上看起来一样的值，不同类型传入的最终值是不一样，比如doule类型的数据小数位会变得很长</strong></p>\n<p>BigDecimal类对象可以与int、double、long、string进行互转。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//创建BigDecimal类对象</span>\n<span class=\"hljs-type\">BigDecimal</span> <span class=\"hljs-variable\">intBD</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BigDecimal</span>(<span class=\"hljs-number\">123</span>);\n<span class=\"hljs-type\">BigDecimal</span> <span class=\"hljs-variable\">douBD</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BigDecimal</span>(<span class=\"hljs-number\">123.123</span>);\n<span class=\"hljs-type\">BigDecimal</span> <span class=\"hljs-variable\">strBD</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BigDecimal</span>(<span class=\"hljs-string\">&quot;123&quot;</span>);\n<span class=\"hljs-type\">BigDecimal</span> <span class=\"hljs-variable\">sdrBD</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BigDecimal</span>(<span class=\"hljs-string\">&quot;123.123&quot;</span>);\n</code></pre>\n<h1 id=\"menu_2\">四类基本运算</h1><p>BigDecimal类提供了数学世界中的四类基本运算方法。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//创建两个运算值</span>\n<span class=\"hljs-type\">BigDecimal</span> <span class=\"hljs-variable\">noOne</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BigDecimal</span>(<span class=\"hljs-number\">123</span>);\n<span class=\"hljs-type\">BigDecimal</span> <span class=\"hljs-variable\">noTwo</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BigDecimal</span>(<span class=\"hljs-number\">123</span>);\n<span class=\"hljs-comment\">//加法</span>\n<span class=\"hljs-type\">BigDecimal</span> <span class=\"hljs-variable\">addAs</span> <span class=\"hljs-operator\">=</span> noOne.add(noTwo);\n<span class=\"hljs-comment\">//减法</span>\n<span class=\"hljs-type\">BigDecimal</span> <span class=\"hljs-variable\">subAs</span> <span class=\"hljs-operator\">=</span> noOne.subtract(noTwo); \n<span class=\"hljs-comment\">//乘法</span>\n<span class=\"hljs-type\">BigDecimal</span> <span class=\"hljs-variable\">mulAs</span> <span class=\"hljs-operator\">=</span> noOne.multiply(noTwo);\n<span class=\"hljs-comment\">//除法</span>\n<span class=\"hljs-comment\">//需要注意除法被除数不能为0哦</span>\n<span class=\"hljs-type\">BigDecimal</span> <span class=\"hljs-variable\">divAs</span> <span class=\"hljs-operator\">=</span> noOne.divide(noTwo);\n<span class=\"hljs-comment\">//另一种写法（直接新建构造类）</span>\n<span class=\"hljs-type\">BigDecimal</span> <span class=\"hljs-variable\">othAs</span> <span class=\"hljs-operator\">=</span> noOne.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BigDecimal</span>(<span class=\"hljs-number\">123</span>));\n</code></pre>\n<h1 id=\"menu_3\">除法精度控制</h1><p>BigDecimal类除法可以提供精度控制能力，具有三个入参分别是：被除数、小数位数、尾数取值模式。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//除法实例，保留三位小数，四舍五入模式</span>\n<span class=\"hljs-type\">BigDecimal</span> <span class=\"hljs-variable\">divAs</span> <span class=\"hljs-operator\">=</span> noOne.divide(noTwo,<span class=\"hljs-number\">3</span>,BigDecimal.ROUND_HALF_UP);\n<span class=\"hljs-comment\">//BigDecimal.ROUND_DOWN            删除多余位数</span>\n<span class=\"hljs-comment\">//BigDecimal.ROUND_UP            删除多余位数，最后一位进一位</span>\n<span class=\"hljs-comment\">//BigDecimal.ROUND_HALF_UP        四舍五入</span>\n<span class=\"hljs-comment\">//BigDecimal.ROUND_HALF_DOWN    五舍六入</span>\n</code></pre>\n<h1 id=\"menu_4\">数据精度控制</h1><p>BigDecimal类独立提供了对数据进行精度控制的方法。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//对已有数据进行精度控制，逡巡上方的几类模式，保留三位四舍五入</span>\nnoTwo = noTwo.<span class=\"hljs-title function_\">setScale</span>(<span class=\"hljs-number\">3</span>,<span class=\"hljs-title class_\">BigDecimal</span>.<span class=\"hljs-property\">ROUND_HALF_UP</span>);\n<span class=\"hljs-comment\">//此处与上方相同支持多种形式</span>\n</code></pre>\n<h1 id=\"menu_5\">数值格式化</h1><pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//建立货币格式化引用</span>\n<span class=\"hljs-type\">NumberFormat</span> <span class=\"hljs-variable\">currency</span> <span class=\"hljs-operator\">=</span> NumberFormat.getCurrencyInstance();\n<span class=\"hljs-comment\">//建立百分比格式化用</span>\n<span class=\"hljs-type\">NumberFormat</span> <span class=\"hljs-variable\">percent</span> <span class=\"hljs-operator\">=</span> NumberFormat.getPercentInstance();\n<span class=\"hljs-comment\">//百分比小数点最多3位</span>\npercent.setMaximumFractionDigits(<span class=\"hljs-number\">3</span>);\n<span class=\"hljs-comment\">//对数据进行货币格式化</span>\ncurrency.format(mulAs);\n<span class=\"hljs-comment\">//对数据进行百分比格式化</span>\npercent.format(divAs);\n</code></pre>\n<h1 id=\"menu_6\">数值大小比较</h1><p>BigDecimal类的大小比较，返回一个int结果，有三个结果  1表示大于，0表示等于，-1表示小于。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">cpAs</span> <span class=\"hljs-operator\">=</span> noOne.compareTo(noTwo);\n<span class=\"hljs-comment\">//BigDecimal类还提供了一些用于比较的常量，比如BigDecimal.ZERO</span>\n<span class=\"hljs-comment\">//与零进行比较</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">cpAs</span> <span class=\"hljs-operator\">=</span> noOne.compareTo(BigDecimal.ZERO);\n</code></pre>\n<h1 id=\"menu_7\">结尾小结</h1><p>实际上没什么需要小结的，常用实例已在上方列举出来了！</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">构造初始化</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">四类基本运算</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">除法精度控制</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">数据精度控制</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">数值格式化</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl1\">数值大小比较</a> <!----></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl1\">结尾小结</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1056, '# 单例设计模式\n\n单例设计模式：顾名思义，保证一个类在内存中有且只有一个对象。\n\n比如常见的Spring框架中Bean默认都是采用的单例设计模式。\n\n# 设计思路\n\n定义私有的构造方法，不让程序使用new创建。\n\n该类的对象类在自己内部就要创建一个对象。\n\n类将创建的对象对外(整个系统)提供方法，让其他程序获取并使用。**\n\n# 懒汉模式\n\nSpring框架中如果配置的延迟加载就是采用懒汉模式。\n\n程序启动的时候，默认**先不创建对象**，当**需要使用的时候才进行对象创建**。\n\n```java\n//懒汉类\npublic class Lazy {\n    //私有构造器\n    private Lazy() {}\n\n    //创建一个私有的对象，但是不进行初始化\n    private static Lazy lazy = null;\n\n    //得到自己的实例，判断是否为空，为空则创建\n    public static Lazy getInstance() {\n        if (lazy == null) {\n            lazy = new Lazy();\n        }\n        return lazy;\n    }\n}\n\n//外部调用\nLazy lazy = Lazy.getInstance();\n```\n\n# 饿汉模式\n\nSpring默认的单例模式是在创建applicationContext容器的时候，预初始化所有的该作用域实例。\n\n因此可以理解为，Spring默认采用的是饿汉模式。\n\n饿汉模式与懒汉模式区别在于，**程序启动的时候，先创建对象，当需要使用的时候直接取**。\n\n```java\n//饿汉类\npublic class Hungry {\n    //私有构造器\n    private Hungry() {}\n    \n    //类加载的时候进行初始化\n    private static  Hungry hungry = new Hungry();\n\n    public Hungry getInstance(){\n        //返回一个对象实例\n        return hungry;\n    }\n}\n\n//外部调用\nHungry hungry = Hungry.getInstance();\n```\n\n# 懒汉模式优化\n\n懒汉模式在**多线程中使用的时候，可能会创建多个实例对象**。\n\n可以在获取对象的方法上加锁，以保证同一时刻仅可被某一线程访问。\n\n```java\npublic class Lazy {\n    //私有构造器\n    private Lazy() {}\n\n    //创建一个私有的对象，但是不进行初始化\n    private static Lazy lazy = null;\n\n    //得到自己的实例，判断是否为空，为空则创建（方法加锁操作）\n    public static synchronized Lazy getInstance() {\n        if (lazy == null) {\n            lazy = new Lazy();\n        }\n        return lazy;\n    }\n}\n```\n\n# 备注\n\n饿汉模式是线程安全的，在类创建的同时就已经创建好一个静态的对象供系统使用,以后不在改变。\n\n懒汉模式如果在创建实例对象时不加上synchronized则会导致重复创建对象，因此不是线程安全的。\n\n懒汉模式的实现方式是延时加载,需要的时候才创建对象。\n\n饿汉模式的实现方式是在加载类的时候就会创建，饿汉模式无需关注多线程问题、写法简单明了、能用则用。\n\n在工厂模式中，如果工厂实现类引用很多实例，采用饿汉模式可能需要考虑效率问题，工厂类加载时会把所有实例不管用不用一块创建。\n', '<h1 id=\"menu_1\">单例设计模式</h1><p>单例设计模式：顾名思义，保证一个类在内存中有且只有一个对象。</p>\n<p>比如常见的Spring框架中Bean默认都是采用的单例设计模式。</p>\n<h1 id=\"menu_2\">设计思路</h1><p>定义私有的构造方法，不让程序使用new创建。</p>\n<p>该类的对象类在自己内部就要创建一个对象。</p>\n<p>类将创建的对象对外(整个系统)提供方法，让其他程序获取并使用。**</p>\n<h1 id=\"menu_3\">懒汉模式</h1><p>Spring框架中如果配置的延迟加载就是采用懒汉模式。</p>\n<p>程序启动的时候，默认<strong>先不创建对象</strong>，当<strong>需要使用的时候才进行对象创建</strong>。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//懒汉类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Lazy</span> {\n    <span class=\"hljs-comment\">//私有构造器</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">Lazy</span><span class=\"hljs-params\">()</span> {}\n\n    <span class=\"hljs-comment\">//创建一个私有的对象，但是不进行初始化</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">Lazy</span> <span class=\"hljs-variable\">lazy</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n\n    <span class=\"hljs-comment\">//得到自己的实例，判断是否为空，为空则创建</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Lazy <span class=\"hljs-title function_\">getInstance</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">if</span> (lazy == <span class=\"hljs-literal\">null</span>) {\n            lazy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Lazy</span>();\n        }\n        <span class=\"hljs-keyword\">return</span> lazy;\n    }\n}\n\n<span class=\"hljs-comment\">//外部调用</span>\n<span class=\"hljs-type\">Lazy</span> <span class=\"hljs-variable\">lazy</span> <span class=\"hljs-operator\">=</span> Lazy.getInstance();\n</code></pre>\n<h1 id=\"menu_4\">饿汉模式</h1><p>Spring默认的单例模式是在创建applicationContext容器的时候，预初始化所有的该作用域实例。</p>\n<p>因此可以理解为，Spring默认采用的是饿汉模式。</p>\n<p>饿汉模式与懒汉模式区别在于，<strong>程序启动的时候，先创建对象，当需要使用的时候直接取</strong>。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//饿汉类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Hungry</span> {\n    <span class=\"hljs-comment\">//私有构造器</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">Hungry</span><span class=\"hljs-params\">()</span> {}\n    \n    <span class=\"hljs-comment\">//类加载的时候进行初始化</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span>  <span class=\"hljs-type\">Hungry</span> <span class=\"hljs-variable\">hungry</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Hungry</span>();\n\n    <span class=\"hljs-keyword\">public</span> Hungry <span class=\"hljs-title function_\">getInstance</span><span class=\"hljs-params\">()</span>{\n        <span class=\"hljs-comment\">//返回一个对象实例</span>\n        <span class=\"hljs-keyword\">return</span> hungry;\n    }\n}\n\n<span class=\"hljs-comment\">//外部调用</span>\n<span class=\"hljs-type\">Hungry</span> <span class=\"hljs-variable\">hungry</span> <span class=\"hljs-operator\">=</span> Hungry.getInstance();\n</code></pre>\n<h1 id=\"menu_5\">懒汉模式优化</h1><p>懒汉模式在<strong>多线程中使用的时候，可能会创建多个实例对象</strong>。</p>\n<p>可以在获取对象的方法上加锁，以保证同一时刻仅可被某一线程访问。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Lazy</span> {\n    <span class=\"hljs-comment\">//私有构造器</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">Lazy</span><span class=\"hljs-params\">()</span> {}\n\n    <span class=\"hljs-comment\">//创建一个私有的对象，但是不进行初始化</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">Lazy</span> <span class=\"hljs-variable\">lazy</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n\n    <span class=\"hljs-comment\">//得到自己的实例，判断是否为空，为空则创建（方法加锁操作）</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">synchronized</span> Lazy <span class=\"hljs-title function_\">getInstance</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">if</span> (lazy == <span class=\"hljs-literal\">null</span>) {\n            lazy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Lazy</span>();\n        }\n        <span class=\"hljs-keyword\">return</span> lazy;\n    }\n}\n</code></pre>\n<h1 id=\"menu_6\">备注</h1><p>饿汉模式是线程安全的，在类创建的同时就已经创建好一个静态的对象供系统使用,以后不在改变。</p>\n<p>懒汉模式如果在创建实例对象时不加上synchronized则会导致重复创建对象，因此不是线程安全的。</p>\n<p>懒汉模式的实现方式是延时加载,需要的时候才创建对象。</p>\n<p>饿汉模式的实现方式是在加载类的时候就会创建，饿汉模式无需关注多线程问题、写法简单明了、能用则用。</p>\n<p>在工厂模式中，如果工厂实现类引用很多实例，采用饿汉模式可能需要考虑效率问题，工厂类加载时会把所有实例不管用不用一块创建。</p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">单例设计模式</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">设计思路</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">懒汉模式</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">饿汉模式</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl1\">懒汉模式优化</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl1\">备注</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1057, '# 前言\n\n我们在实际写代码过程中往往不会过度强调在用哪种设计模式。\n\n但了解学习优秀的设计模式能够便于我们写出更为优质的代码。\n\n采用设计模式编写代码可以具备易用、拓展、清晰等多种特质。\n\n既便如此，在实际编写过程中，不能被设计模式所束缚，因地制宜才是最好的。\n\n本文主要讲述的是，创建者模式中的工厂模式。\n\n# 模式介绍\n\n创建者模式：为了用更加优雅的方式创建对象。\n\n工厂模式：字如其意，用于创建对象的中心，主要为了生产出需要的对象。\n\n## 简单工厂模式\n\n该模式使用的频次较少，简单来说就是你需要什么，我创建什么。 \n\n该设计模式主要为了将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。\n\n简单工厂方法是静态方法，可通过工厂类类名直接调用，只需要传入一个简单的参数即可，无须知道对象的创建细节。\n\n可以将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码。\n\n但是，工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，违背开闭原则。\n\n```java\n//产品接口\ninterface Person{\n    void create();\n}\n//产品实现类\npublic class Man implements Person {\n    @Override\n    public String create() {\n        return \"Create Man\";\n    }\n}\npublic class Woman implements Person {\n    @Override\n    public String create() {\n        return \"Create Woman\";\n    }\n}\n//工厂类\npublic class PersonFactory {\n    public static Person create(String what)\n    {\n        Person person = null;\n        switch (what)\n        {\n            case \"M\" :\n                person = new Man();\n                break;\n            case \"W\" :\n                person = new Woman();\n                break;\n        }\n        return person;\n    }\n}\n//最终调用\nPerson man = PersonFactory.create(\"M\");\nPerson woman = PersonFactory.create(\"W\");\n```\n\n**优点：**\n\n - 实现了对象创建和使用的分离\n - 一定程度上提高了系统的灵活性，对象使用者无需知晓创建对象的细节\n\n**缺点：**\n\n - 工厂类集中了所有产品的创建逻辑，过度依赖工厂类，实际上提高了代码耦合度\n - 增加了系统的复杂度和理解难度\n - 系统扩展困难，添加新产品不得不修改工厂逻辑，重构频次过高\n - 使用静态工厂方法，工厂无法基于继承的等级结构，不能得到很好地扩展\n\n**场景：**\n\n - 少类型的对象创建，不会造成工厂方法中的业务逻辑太过复杂\n - 使用者不想过多关心对象创建细节，想快速达成对象创建\n\n\n## 工厂方法\n\n工厂方法模式(Factory Method Pattern)简称工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式。\n\n工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n\n工厂方法模式是简单工厂模式的进一步抽象和推广，保持了简单工厂模式的优点，并克服了它的缺点。\n\n核心工厂类不再负责所有产品的创建，而是将具体创建工作交给其子类去完成，允许系统在不修改工厂角色的情况下引进新产品。\n\n实际过程为：增加具体产品-->增加具体工厂，符合开闭原则。\n\n```java\n//产品接口\ninterface Person{\n    void create();\n}\n//产品实现类\npublic class Man implements Person {\n    @Override\n    public String create() {\n        return \"Create Man\";\n    }\n}\n//以上与简单工厂一致\n//工厂方法父类（接口类）\ninterface PersonFactory {\n    Person createPerson();\n}\n//工厂方法子类（实现类）\npublic class ManFactory implements PersonFactory {\n    @Override\n    public Person createPerson() {\n        return new Man();\n    }\n}\n//实际调用\nPersonFactory manFactory = new ManFactory();\nPerson man = manFactory.createPerson();\n```\n\n**优点：**\n\n - 工厂方法用来创建客户所需要的产品，隐藏了哪种具体产品类将被实例化的细节\n - 自主选择需要使用的子类工厂，创建对象的细节封装在具体工厂内部\n - 在系统中加入新产品时，增加对应的子类（实现）工厂\n\n**缺点：**\n\n - 一定程度上增加了系统的复杂度，会给系统带来一些额外的开销，增加了对应工厂类\n - 增加了系统的抽象性和理解难度\n\n**场景：**\n\n - 使用者只需要知道所对应的工厂即可创建对象\n - 较多的细分产品类适用于工厂方法创建\n\n## 抽象工厂模式\n\n抽象工厂模式(Abstract Factory Pattern)，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类，抽象工厂模式又称为Kit模式。\n\n抽象工厂模式中存在着产品族和产品等级两大概念。\n\n产品族：同一个工厂生产的，位于不同产品等级结构中的一组产品，如下方代码的女人、女孩\n\n产品等级：产品等级结构即产品的继承结构，如下方代码的女性->女人，女性->女孩\n\n```java\n//产品族 男性\npublic interface Male {\n}\n//男性产品等级下男人\npublic class Man implements Male {\n}\n//男性产品等级下男孩\npublic class Boy implements Male {\n}\n//同理女性产品族\npublic interface Female {\n}\npublic class Woman implements Female {\n}\npublic class Girl implements Female {\n}\n//抽象工厂\ninterface PersonFactory {\n    public Male createMale();\n    public Female createFemale();\n}\n//实现工厂 成年生产工厂\npublic class AdultFactory implements PersonFactory {\n    @Override\n    public Male createMale() {\n        return new Man();\n    }\n    @Override\n    public Female createFemale() {\n        return new Woman();\n    }\n}\n//实现工厂 幼年生产工厂\npublic class ChildFactroy implements PersonFactory {\n    @Override\n    public Male createMale() {\n        return new Boy();\n    }\n    @Override\n    public Female createFemale() {\n        return new Girl();\n    }\n}\n//最终调用\nPersonFactory adultFactory = new AdultFactory();\nMale man = adultFactory.createMale();\nFemale woman = adultFactory.createFemale();\nPersonFactory childFactory = new ChildFactroy();\nMale boy = childFactory.createMale();\nFemale girl = childFactory.createFemale();\n```\n\n**优点：**\n\n - 使用者无需知晓具体对象的生成\n - 产品族中的多个对象被设计成一起工作时，能够保证使用者只使用同一个产品族中的对象\n - 增加新的产品族很方便，无须修改已有系统，符合开闭原则\n\n**缺点：**\n\n - 当增加新的产品等级，需大改，甚至修改抽象层代码，重构成本高，违背了开闭原则\n\n**场景：**\n\n - 系统不依赖于产品类实例如何被创建、组合和表达的细节\n - 系统中有多于一个的产品族，每次只使用其中某一产品族\n - 属于同一个产品族的产品将在一起使用时\n - 产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构\n\n# 备注\n\n实际编写代码并不会局限于使用某一种设计模式。\n\n代码在不断优化升级重构过程中会出现模式的迁移情况。\n\n无论采用何种设计模式，编码时我们要考虑这些特质：\n\n - 逻辑清晰，模块划分合理\n - 可读性高\n - 健壮性高\n - 灵活，易扩展和易迁移。\n', '<h1 id=\"menu_1\">前言</h1><p>我们在实际写代码过程中往往不会过度强调在用哪种设计模式。</p>\n<p>但了解学习优秀的设计模式能够便于我们写出更为优质的代码。</p>\n<p>采用设计模式编写代码可以具备易用、拓展、清晰等多种特质。</p>\n<p>既便如此，在实际编写过程中，不能被设计模式所束缚，因地制宜才是最好的。</p>\n<p>本文主要讲述的是，创建者模式中的工厂模式。</p>\n<h1 id=\"menu_2\">模式介绍</h1><p>创建者模式：为了用更加优雅的方式创建对象。</p>\n<p>工厂模式：字如其意，用于创建对象的中心，主要为了生产出需要的对象。</p>\n<h2 id=\"menu_3\">简单工厂模式</h2><p>该模式使用的频次较少，简单来说就是你需要什么，我创建什么。 </p>\n<p>该设计模式主要为了将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。</p>\n<p>简单工厂方法是静态方法，可通过工厂类类名直接调用，只需要传入一个简单的参数即可，无须知道对象的创建细节。</p>\n<p>可以将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码。</p>\n<p>但是，工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，违背开闭原则。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//产品接口</span>\n<span class=\"hljs-keyword\">interface</span> Person{\n    <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">create</span>();\n}\n<span class=\"hljs-comment\">//产品实现类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Man</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">String</span> <span class=\"hljs-title function_\">create</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Create Man&quot;</span>;\n    }\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Woman</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">String</span> <span class=\"hljs-title function_\">create</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Create Woman&quot;</span>;\n    }\n}\n<span class=\"hljs-comment\">//工厂类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PersonFactory</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title class_\">Person</span> <span class=\"hljs-title function_\">create</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span> what</span>)\n    {\n        <span class=\"hljs-title class_\">Person</span> person = <span class=\"hljs-literal\">null</span>;\n        <span class=\"hljs-keyword\">switch</span> (what)\n        {\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;M&quot;</span> :\n                person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Man</span>();\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;W&quot;</span> :\n                person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Woman</span>();\n                <span class=\"hljs-keyword\">break</span>;\n        }\n        <span class=\"hljs-keyword\">return</span> person;\n    }\n}\n<span class=\"hljs-comment\">//最终调用</span>\n<span class=\"hljs-title class_\">Person</span> man = <span class=\"hljs-title class_\">PersonFactory</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-string\">&quot;M&quot;</span>);\n<span class=\"hljs-title class_\">Person</span> woman = <span class=\"hljs-title class_\">PersonFactory</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-string\">&quot;W&quot;</span>);\n</code></pre>\n<p><strong>优点：</strong></p>\n<ul>\n<li>实现了对象创建和使用的分离</li>\n<li>一定程度上提高了系统的灵活性，对象使用者无需知晓创建对象的细节</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>工厂类集中了所有产品的创建逻辑，过度依赖工厂类，实际上提高了代码耦合度</li>\n<li>增加了系统的复杂度和理解难度</li>\n<li>系统扩展困难，添加新产品不得不修改工厂逻辑，重构频次过高</li>\n<li>使用静态工厂方法，工厂无法基于继承的等级结构，不能得到很好地扩展</li>\n</ul>\n<p><strong>场景：</strong></p>\n<ul>\n<li>少类型的对象创建，不会造成工厂方法中的业务逻辑太过复杂</li>\n<li>使用者不想过多关心对象创建细节，想快速达成对象创建</li>\n</ul>\n<h2 id=\"menu_4\">工厂方法</h2><p>工厂方法模式(Factory Method Pattern)简称工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式。</p>\n<p>工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>\n<p>工厂方法模式是简单工厂模式的进一步抽象和推广，保持了简单工厂模式的优点，并克服了它的缺点。</p>\n<p>核心工厂类不再负责所有产品的创建，而是将具体创建工作交给其子类去完成，允许系统在不修改工厂角色的情况下引进新产品。</p>\n<p>实际过程为：增加具体产品--&gt;增加具体工厂，符合开闭原则。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//产品接口</span>\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span>{\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">create</span><span class=\"hljs-params\">()</span>;\n}\n<span class=\"hljs-comment\">//产品实现类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Man</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">create</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Create Man&quot;</span>;\n    }\n}\n<span class=\"hljs-comment\">//以上与简单工厂一致</span>\n<span class=\"hljs-comment\">//工厂方法父类（接口类）</span>\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">PersonFactory</span> {\n    Person <span class=\"hljs-title function_\">createPerson</span><span class=\"hljs-params\">()</span>;\n}\n<span class=\"hljs-comment\">//工厂方法子类（实现类）</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ManFactory</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">PersonFactory</span> {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> Person <span class=\"hljs-title function_\">createPerson</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Man</span>();\n    }\n}\n<span class=\"hljs-comment\">//实际调用</span>\n<span class=\"hljs-type\">PersonFactory</span> <span class=\"hljs-variable\">manFactory</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ManFactory</span>();\n<span class=\"hljs-type\">Person</span> <span class=\"hljs-variable\">man</span> <span class=\"hljs-operator\">=</span> manFactory.createPerson();\n</code></pre>\n<p><strong>优点：</strong></p>\n<ul>\n<li>工厂方法用来创建客户所需要的产品，隐藏了哪种具体产品类将被实例化的细节</li>\n<li>自主选择需要使用的子类工厂，创建对象的细节封装在具体工厂内部</li>\n<li>在系统中加入新产品时，增加对应的子类（实现）工厂</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>一定程度上增加了系统的复杂度，会给系统带来一些额外的开销，增加了对应工厂类</li>\n<li>增加了系统的抽象性和理解难度</li>\n</ul>\n<p><strong>场景：</strong></p>\n<ul>\n<li>使用者只需要知道所对应的工厂即可创建对象</li>\n<li>较多的细分产品类适用于工厂方法创建</li>\n</ul>\n<h2 id=\"menu_5\">抽象工厂模式</h2><p>抽象工厂模式(Abstract Factory Pattern)，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类，抽象工厂模式又称为Kit模式。</p>\n<p>抽象工厂模式中存在着产品族和产品等级两大概念。</p>\n<p>产品族：同一个工厂生产的，位于不同产品等级结构中的一组产品，如下方代码的女人、女孩</p>\n<p>产品等级：产品等级结构即产品的继承结构，如下方代码的女性-&gt;女人，女性-&gt;女孩</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//产品族 男性</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Male</span> {\n}\n<span class=\"hljs-comment\">//男性产品等级下男人</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Man</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Male</span> {\n}\n<span class=\"hljs-comment\">//男性产品等级下男孩</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Boy</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Male</span> {\n}\n<span class=\"hljs-comment\">//同理女性产品族</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Female</span> {\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Woman</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Female</span> {\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Girl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Female</span> {\n}\n<span class=\"hljs-comment\">//抽象工厂</span>\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">PersonFactory</span> {\n    <span class=\"hljs-keyword\">public</span> Male <span class=\"hljs-title function_\">createMale</span><span class=\"hljs-params\">()</span>;\n    <span class=\"hljs-keyword\">public</span> Female <span class=\"hljs-title function_\">createFemale</span><span class=\"hljs-params\">()</span>;\n}\n<span class=\"hljs-comment\">//实现工厂 成年生产工厂</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AdultFactory</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">PersonFactory</span> {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> Male <span class=\"hljs-title function_\">createMale</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Man</span>();\n    }\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> Female <span class=\"hljs-title function_\">createFemale</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Woman</span>();\n    }\n}\n<span class=\"hljs-comment\">//实现工厂 幼年生产工厂</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ChildFactroy</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">PersonFactory</span> {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> Male <span class=\"hljs-title function_\">createMale</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Boy</span>();\n    }\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> Female <span class=\"hljs-title function_\">createFemale</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Girl</span>();\n    }\n}\n<span class=\"hljs-comment\">//最终调用</span>\n<span class=\"hljs-type\">PersonFactory</span> <span class=\"hljs-variable\">adultFactory</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AdultFactory</span>();\n<span class=\"hljs-type\">Male</span> <span class=\"hljs-variable\">man</span> <span class=\"hljs-operator\">=</span> adultFactory.createMale();\n<span class=\"hljs-type\">Female</span> <span class=\"hljs-variable\">woman</span> <span class=\"hljs-operator\">=</span> adultFactory.createFemale();\n<span class=\"hljs-type\">PersonFactory</span> <span class=\"hljs-variable\">childFactory</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ChildFactroy</span>();\n<span class=\"hljs-type\">Male</span> <span class=\"hljs-variable\">boy</span> <span class=\"hljs-operator\">=</span> childFactory.createMale();\n<span class=\"hljs-type\">Female</span> <span class=\"hljs-variable\">girl</span> <span class=\"hljs-operator\">=</span> childFactory.createFemale();\n</code></pre>\n<p><strong>优点：</strong></p>\n<ul>\n<li>使用者无需知晓具体对象的生成</li>\n<li>产品族中的多个对象被设计成一起工作时，能够保证使用者只使用同一个产品族中的对象</li>\n<li>增加新的产品族很方便，无须修改已有系统，符合开闭原则</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>当增加新的产品等级，需大改，甚至修改抽象层代码，重构成本高，违背了开闭原则</li>\n</ul>\n<p><strong>场景：</strong></p>\n<ul>\n<li>系统不依赖于产品类实例如何被创建、组合和表达的细节</li>\n<li>系统中有多于一个的产品族，每次只使用其中某一产品族</li>\n<li>属于同一个产品族的产品将在一起使用时</li>\n<li>产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构</li>\n</ul>\n<h1 id=\"menu_6\">备注</h1><p>实际编写代码并不会局限于使用某一种设计模式。</p>\n<p>代码在不断优化升级重构过程中会出现模式的迁移情况。</p>\n<p>无论采用何种设计模式，编码时我们要考虑这些特质：</p>\n<ul>\n<li>逻辑清晰，模块划分合理</li>\n<li>可读性高</li>\n<li>健壮性高</li>\n<li>灵活，易扩展和易迁移。</li>\n</ul>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">前言</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">模式介绍</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">简单工厂模式</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">工厂方法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">抽象工厂模式</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl1\">备注</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1058, '# 前言\n\n绝大多数经典的JAVA框架均采用了JAVA的反射机制来实例化、维护JAVA对象。\n\nJAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；\n\n对于任意一个对象，都能够调用它的任意一个方法和属性；\n\n这种动态获取的信息以及动态调用对象的方法的功能称为JAVA语言的反射机制。\n\nJAVA通常是先有类再有对象，类的对象可以调用方法或者属性。\n\n反射其实是通过Class对象来调用类里面的方法。\n\n通过反射可以调用私有方法和私有属性。\n\n# 什么是反射\n\n反射就是可以在程序运行的时候动态装载类，查看类的信息，生成对象，或操作生成对象。\n\n类在运行的时候，可以得到该类的信息，并且可以动态的修改这些信息，自己能看到自己，跟照镜子一样。\n\nJAVA的反射机制是在编译的时候并不确定哪个类被加载，而在程序运行的时候才加载、探知、自审、使用在编译期并不知道的类，这样的特点就是反射。\n\n# 反射的作用\n\n如果没有采用反射的机制，A类如果需要使用B类的方法，必须要求B类已经完成方法的编写（编译），否则A类无法通过编译。\n\n而利用JAVA的反射机制，A类可以在未得到B类完成编译时能够完成自己身代码的编译。\n\nJAVA的反射机制提供了这些能力：\n\n1. 运行时判断任意一个对象所属的类\n2. 运行时构造任意一个类的对象\n3. 运行时判断任意一个类所具有的成员变量和方法\n4. 运行时调用任意一个对象的方法\n5. 生成动态代理\n\nJAVA的反射机制能够探知类的基本结构，这种能力被称为JAVA类的“自审”。\n\n开发常用的eclipse和idea，当我们构建出一个对象的时候，去调用该对象的方法和属性的时候，一按点.编译工具就会将该对象可用的所有的方法和属性全部都列出来，供用户进行选择，就是利用了JAVA的反射原理，对创建的对象的探知、自审。 \n\n反射技术被大量用于JAVA设计模式和框架技术，最常见的设计模式就是工厂模式和单例模式。\n\n# 反射的实现\n\n反射的实现主要借助四个类：Class、Constructor、Field、Method\n\n## 通过Class类获取类对象\n\n```java\n//获取Class类的三种方式\nClass<User> userClass;\n//.class\nuserClass = User.class;\n//类名全路径\nuserClass = (Class<User>) Class.forName(\"com.mebugs.user\");\n//对象获取Class\nUser user = new User();\nuserClass = (Class<User>) user.getClass();\n//Class获取对象\nUser tom = userClass.newInstance();\n```\n\n## Class类获取Constructor构造方法\n\n```java\n//Class类获取构造方法\nClass<User> consClass = User.class;\n//全部公共构造方法数组\nConstructor<User>[] allPubCons = (Constructor<User>[]) consClass.getConstructors();\n//根据入参获取指定公共构造方法\nConstructor needPubCons = consClass.getConstructor(new Class[]{int.class,String.class});\n//全部构造方法（包含私有）\nConstructor<User>[] allCons = (Constructor<User>[]) consClass.getDeclaredConstructors();\n//根据入参获取指定构造方法（包含私有）\nConstructor needCons = consClass.getDeclaredConstructor(new Class[]{int.class,String.class});\n```\n\n## Class类获取属性\n\n```java\n//Class类获取属性\nClass<User> fieldClass = User.class;\n//获取指定的公共属性(类或接口的指定已声明字段类对象)\nField pubName = fieldClass.getField(\"name\");\n//获取全部公共属性(类或接口的指定已声明字段类对象)\nField[] allPubFiels = fieldClass.getFields();\n//获取指定的属性(类或接口的指定已声明字段类对象)\nField name = fieldClass.getDeclaredField(\"name\");\n//获取全部属性(类或接口的指定已声明字段类对象)\nField[] allFiels = fieldClass.getDeclaredFields();\n```\n\n## Class类获取方法\n\n```java\n//Class类获取方法\nClass<User> modClass = User.class;\n//获取指定的公共方法\nMethod pubDo = modClass.getMethod(\"do\",new Class[]{int.class,String.class});\n//获取全部公共方法\nMethod[] allPubMo = fieldClass.getMethods();\n//获取指定的方法\nMethod doMo = modClass.getDeclaredMethod(\"do\",new Class[]{int.class,String.class});\n//获取全部方法\nMethod[] allMo = fieldClass.getDeclaredMethods();\n```\n\n# 备注\nClassForName与ClassLoader的区别：\n\n- class.forName()除了将类的.class文件加载到JVM中会对类进行解释、执行类中的static块以及静态变量赋值的静态方法\n- classLoader只干一件事情，就是将.class文件加载到JVM中', '<h1 id=\"menu_1\">前言</h1><p>绝大多数经典的JAVA框架均采用了JAVA的反射机制来实例化、维护JAVA对象。</p>\n<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；</p>\n<p>对于任意一个对象，都能够调用它的任意一个方法和属性；</p>\n<p>这种动态获取的信息以及动态调用对象的方法的功能称为JAVA语言的反射机制。</p>\n<p>JAVA通常是先有类再有对象，类的对象可以调用方法或者属性。</p>\n<p>反射其实是通过Class对象来调用类里面的方法。</p>\n<p>通过反射可以调用私有方法和私有属性。</p>\n<h1 id=\"menu_2\">什么是反射</h1><p>反射就是可以在程序运行的时候动态装载类，查看类的信息，生成对象，或操作生成对象。</p>\n<p>类在运行的时候，可以得到该类的信息，并且可以动态的修改这些信息，自己能看到自己，跟照镜子一样。</p>\n<p>JAVA的反射机制是在编译的时候并不确定哪个类被加载，而在程序运行的时候才加载、探知、自审、使用在编译期并不知道的类，这样的特点就是反射。</p>\n<h1 id=\"menu_3\">反射的作用</h1><p>如果没有采用反射的机制，A类如果需要使用B类的方法，必须要求B类已经完成方法的编写（编译），否则A类无法通过编译。</p>\n<p>而利用JAVA的反射机制，A类可以在未得到B类完成编译时能够完成自己身代码的编译。</p>\n<p>JAVA的反射机制提供了这些能力：</p>\n<ol>\n<li>运行时判断任意一个对象所属的类</li>\n<li>运行时构造任意一个类的对象</li>\n<li>运行时判断任意一个类所具有的成员变量和方法</li>\n<li>运行时调用任意一个对象的方法</li>\n<li>生成动态代理</li>\n</ol>\n<p>JAVA的反射机制能够探知类的基本结构，这种能力被称为JAVA类的“自审”。</p>\n<p>开发常用的eclipse和idea，当我们构建出一个对象的时候，去调用该对象的方法和属性的时候，一按点.编译工具就会将该对象可用的所有的方法和属性全部都列出来，供用户进行选择，就是利用了JAVA的反射原理，对创建的对象的探知、自审。 </p>\n<p>反射技术被大量用于JAVA设计模式和框架技术，最常见的设计模式就是工厂模式和单例模式。</p>\n<h1 id=\"menu_4\">反射的实现</h1><p>反射的实现主要借助四个类：Class、Constructor、Field、Method</p>\n<h2 id=\"menu_5\">通过Class类获取类对象</h2><pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//获取Class类的三种方式</span>\nClass&lt;User&gt; userClass;\n<span class=\"hljs-comment\">//.class</span>\nuserClass = User.class;\n<span class=\"hljs-comment\">//类名全路径</span>\nuserClass = (Class&lt;User&gt;) Class.forName(<span class=\"hljs-string\">&quot;com.mebugs.user&quot;</span>);\n<span class=\"hljs-comment\">//对象获取Class</span>\n<span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>();\nuserClass = (Class&lt;User&gt;) user.getClass();\n<span class=\"hljs-comment\">//Class获取对象</span>\n<span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">tom</span> <span class=\"hljs-operator\">=</span> userClass.newInstance();\n</code></pre>\n<h2 id=\"menu_6\">Class类获取Constructor构造方法</h2><pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//Class类获取构造方法</span>\nClass&lt;User&gt; consClass = User.class;\n<span class=\"hljs-comment\">//全部公共构造方法数组</span>\nConstructor&lt;User&gt;[] allPubCons = (Constructor&lt;User&gt;[]) consClass.getConstructors();\n<span class=\"hljs-comment\">//根据入参获取指定公共构造方法</span>\n<span class=\"hljs-type\">Constructor</span> <span class=\"hljs-variable\">needPubCons</span> <span class=\"hljs-operator\">=</span> consClass.getConstructor(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Class</span>[]{<span class=\"hljs-type\">int</span>.class,String.class});\n<span class=\"hljs-comment\">//全部构造方法（包含私有）</span>\nConstructor&lt;User&gt;[] allCons = (Constructor&lt;User&gt;[]) consClass.getDeclaredConstructors();\n<span class=\"hljs-comment\">//根据入参获取指定构造方法（包含私有）</span>\n<span class=\"hljs-type\">Constructor</span> <span class=\"hljs-variable\">needCons</span> <span class=\"hljs-operator\">=</span> consClass.getDeclaredConstructor(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Class</span>[]{<span class=\"hljs-type\">int</span>.class,String.class});\n</code></pre>\n<h2 id=\"menu_7\">Class类获取属性</h2><pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//Class类获取属性</span>\nClass&lt;User&gt; fieldClass = User.class;\n<span class=\"hljs-comment\">//获取指定的公共属性(类或接口的指定已声明字段类对象)</span>\n<span class=\"hljs-type\">Field</span> <span class=\"hljs-variable\">pubName</span> <span class=\"hljs-operator\">=</span> fieldClass.getField(<span class=\"hljs-string\">&quot;name&quot;</span>);\n<span class=\"hljs-comment\">//获取全部公共属性(类或接口的指定已声明字段类对象)</span>\nField[] allPubFiels = fieldClass.getFields();\n<span class=\"hljs-comment\">//获取指定的属性(类或接口的指定已声明字段类对象)</span>\n<span class=\"hljs-type\">Field</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> fieldClass.getDeclaredField(<span class=\"hljs-string\">&quot;name&quot;</span>);\n<span class=\"hljs-comment\">//获取全部属性(类或接口的指定已声明字段类对象)</span>\nField[] allFiels = fieldClass.getDeclaredFields();\n</code></pre>\n<h2 id=\"menu_8\">Class类获取方法</h2><pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">//Class类获取方法</span>\nClass&lt;User&gt; modClass = User.class;\n<span class=\"hljs-comment\">//获取指定的公共方法</span>\n<span class=\"hljs-type\">Method</span> <span class=\"hljs-variable\">pubDo</span> <span class=\"hljs-operator\">=</span> modClass.getMethod(<span class=\"hljs-string\">&quot;do&quot;</span>,<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Class</span>[]{<span class=\"hljs-type\">int</span>.class,String.class});\n<span class=\"hljs-comment\">//获取全部公共方法</span>\nMethod[] allPubMo = fieldClass.getMethods();\n<span class=\"hljs-comment\">//获取指定的方法</span>\n<span class=\"hljs-type\">Method</span> <span class=\"hljs-variable\">doMo</span> <span class=\"hljs-operator\">=</span> modClass.getDeclaredMethod(<span class=\"hljs-string\">&quot;do&quot;</span>,<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Class</span>[]{<span class=\"hljs-type\">int</span>.class,String.class});\n<span class=\"hljs-comment\">//获取全部方法</span>\nMethod[] allMo = fieldClass.getDeclaredMethods();\n</code></pre>\n<h1 id=\"menu_9\">备注</h1><p>ClassForName与ClassLoader的区别：</p>\n<ul>\n<li>class.forName()除了将类的.class文件加载到JVM中会对类进行解释、执行类中的static块以及静态变量赋值的静态方法</li>\n<li>classLoader只干一件事情，就是将.class文件加载到JVM中</li>\n</ul>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">前言</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">什么是反射</a> <!----></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">反射的作用</a> <!----></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">反射的实现</a> <ul><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">通过Class类获取类对象</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">Class类获取Constructor构造方法</a> <!----></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">Class类获取属性</a> <!----></li><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl2\">Class类获取方法</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_9\')\" class=\"pl1\">备注</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1059, '# 基本信息\n\nMeal（一顿饭）意如其名，旨在节省一顿饭的时间。\n本工程采用前后端分离的部署方式，服务端采用SpringBoot构建，前端采用Vue。\n工程仅提供了一些基础支撑能力的构建，不包含其他的业务逻辑，旨在快速铺开一个新业务系统。\n\n服务端工程地址：[Gitee](https://gitee.com/mebugs/meal \"Gitee\") 丨 [GitHub](https://github.com/mebugs/meal \"GitHub\")\n\n前端工程地址：[Gitee](https://gitee.com/mebugs/meal-ui \"Gitee\") 丨 [GitHub](https://github.com/mebugs/meal-ui \"GitHub\")\n\n## 特别致谢\n\nMeal服务端使用[MyBatis-Plus](https://mybatis.plus/ \"MyBatis-Plus\")作为基础脚手架。\n\nMeal服务端使用[jjwt](https://github.com/jwtk/jjwt \"jjwt\")实现JWT快速加解密。\n\nMeal-ui前端工程Fork自[vue-admin-template](https://github.com/PanJiaChen/vue-admin-template \"vue-admin-template\")。\n\n本人是JAVA服务端开发，[@花裤衩](https://github.com/PanJiaChen \"@花裤衩\")的前端系列开源项目为我学习Vue提供非常大的帮助，非常感谢！\n\n# 功能清单\n\nMeal工程仅提供了最基本的账号-角色支撑能力，没有涉及其他功能页面。\n\n## 登陆页\n\n![/static/upload/post/1646356698575.jpg](/static/upload/post/1646356698575.jpg)\n\n## 工作中心\n\n![/static/upload/post/1646356749194.jpg](/static/upload/post/1646356749194.jpg)\n\n## 角色控制与多级菜单测试\n\n![/static/upload/post/1646356805972.jpg](/static/upload/post/1646356805972.jpg)\n\n## 个人密码管理\n\n![/static/upload/post/1646356725609.jpg](/static/upload/post/1646356725609.jpg)\n\n## 账号管理\n\n![/static/upload/post/1646356813351.jpg](/static/upload/post/1646356813351.jpg)\n\n## 代码生成\n\n![/static/upload/post/1646356830776.jpg](/static/upload/post/1646356830776.jpg)\n\n# 开发说明\n\n## 服务端\n\n### 外部依赖\n\n1. JDK 1.8 已知可能持续使用很长时间的版本\n2. MySql 5.7 经典版本\n3. Redis 6.0 比较新的一个版本（实际上目前项目中对版本要求没有十分严格）\n\n### 工程目录\n\n![/static/upload/post/1646356850068.jpg](/static/upload/post/1646356850068.jpg)\n\n### 核心类\n\n - MyBatisPlusConfig：MyBatis-Plus配置类，配置Mapper扫描位置、分页插件等。\n - RedisConfig：配置Redis为默认缓存工具及常见操作Bean配置。\n - CodeMakerUtils：代码生成器的执行类\n - JwtUserContext：JWT安全用户上下文对象（全局获取登录用户信息）\n - JwtFilter：Jwt过滤器，核心过滤器（登录、授权、拦截）\n - ExceptionHandler：全局异常捕获处理（AOP实现，支持自定义异常处理）\n - RoleInterceptor：角色拦截器（基于自定义注解@RolePermission实现鉴权）\n - EncryptionUtils：盐值加密工具（账号的密码生成，不可逆加密算法）\n\n### 开发说明\n\n1. 数据库初始化刷库\n2. application-dev.yml配置您的数据库信息和redis信息（默认localhost）\n3. 启动App类\n\n启动示意图：\n\n![/static/upload/post/1646356961460.jpg](/static/upload/post/1646356961460.jpg)\n\n## 前端\n### 外部依赖\n\n1. Node.js（基本工具）\n2. Git（多数前端工程依赖会需要调用Git下载）\n\n### 工程目录\n\n![/static/upload/post/1646356972142.jpg](/static/upload/post/1646356972142.jpg)\n\n![/static/upload/post/1646357023385.jpg](/static/upload/post/1646357023385.jpg)\n\n### 相对原本的改动\n\n1. 移除Mocks模拟返回服务（调用meal服务端工程）\n2. 移除测试模块以及相关依赖\n3. 移除Cookies插件依赖，Cookies统一替换为window.localStorage\n4. 补充动态路由由服务端返回的用户角色集Roles控制\n5. 移除自定义icon（svg格式），替换为element-ui的图标，直接修改了Sidebar/Item.vue\n6. 核心方法getUserBase获取用户基础信息src/store/modules/user.js getInfo()\n7. 增加v-droll可以自由在屏幕范围内拖动弹窗（src/directive/droll.js）\n\n### 启动界面\n\n![/static/upload/post/1646356937696.jpg](/static/upload/post/1646356937696.jpg)\n\n### 开发说明\n\n```bash\n# 依赖下载\nnpm install\n# 开发模式\nnpm run dev\n# 生产编译\nnpm run build\n```\n\n# 关于个人\n\n[关于米虫](http://www.mebugs.com/page/about.html)\n', '<h1 id=\"menu_1\">基本信息</h1><p>Meal（一顿饭）意如其名，旨在节省一顿饭的时间。<br/>本工程采用前后端分离的部署方式，服务端采用SpringBoot构建，前端采用Vue。<br/>工程仅提供了一些基础支撑能力的构建，不包含其他的业务逻辑，旨在快速铺开一个新业务系统。</p>\n<p>服务端工程地址：<a class=\"mlink\" href=\"https://gitee.com/mebugs/meal\" title=\"Gitee\" target=\"_blank\">Gitee</a> 丨 <a class=\"mlink\" href=\"https://github.com/mebugs/meal\" title=\"GitHub\" target=\"_blank\">GitHub</a></p>\n<p>前端工程地址：<a class=\"mlink\" href=\"https://gitee.com/mebugs/meal-ui\" title=\"Gitee\" target=\"_blank\">Gitee</a> 丨 <a class=\"mlink\" href=\"https://github.com/mebugs/meal-ui\" title=\"GitHub\" target=\"_blank\">GitHub</a></p>\n<h2 id=\"menu_2\">特别致谢</h2><p>Meal服务端使用<a class=\"mlink\" href=\"https://mybatis.plus/\" title=\"MyBatis-Plus\" target=\"_blank\">MyBatis-Plus</a>作为基础脚手架。</p>\n<p>Meal服务端使用<a class=\"mlink\" href=\"https://github.com/jwtk/jjwt\" title=\"jjwt\" target=\"_blank\">jjwt</a>实现JWT快速加解密。</p>\n<p>Meal-ui前端工程Fork自<a class=\"mlink\" href=\"https://github.com/PanJiaChen/vue-admin-template\" title=\"vue-admin-template\" target=\"_blank\">vue-admin-template</a>。</p>\n<p>本人是JAVA服务端开发，<a class=\"mlink\" href=\"https://github.com/PanJiaChen\" title=\"@花裤衩\" target=\"_blank\">@花裤衩</a>的前端系列开源项目为我学习Vue提供非常大的帮助，非常感谢！</p>\n<h1 id=\"menu_3\">功能清单</h1><p>Meal工程仅提供了最基本的账号-角色支撑能力，没有涉及其他功能页面。</p>\n<h2 id=\"menu_4\">登陆页</h2><p><img src=\"/static/upload/post/1646356698575.jpg\" alt=\"/static/upload/post/1646356698575.jpg\"/></p>\n<h2 id=\"menu_5\">工作中心</h2><p><img src=\"/static/upload/post/1646356749194.jpg\" alt=\"/static/upload/post/1646356749194.jpg\"/></p>\n<h2 id=\"menu_6\">角色控制与多级菜单测试</h2><p><img src=\"/static/upload/post/1646356805972.jpg\" alt=\"/static/upload/post/1646356805972.jpg\"/></p>\n<h2 id=\"menu_7\">个人密码管理</h2><p><img src=\"/static/upload/post/1646356725609.jpg\" alt=\"/static/upload/post/1646356725609.jpg\"/></p>\n<h2 id=\"menu_8\">账号管理</h2><p><img src=\"/static/upload/post/1646356813351.jpg\" alt=\"/static/upload/post/1646356813351.jpg\"/></p>\n<h2 id=\"menu_9\">代码生成</h2><p><img src=\"/static/upload/post/1646356830776.jpg\" alt=\"/static/upload/post/1646356830776.jpg\"/></p>\n<h1 id=\"menu_10\">开发说明</h1><h2 id=\"menu_11\">服务端</h2><h3 id=\"menu_12\">外部依赖</h3><ol>\n<li>JDK 1.8 已知可能持续使用很长时间的版本</li>\n<li>MySql 5.7 经典版本</li>\n<li>Redis 6.0 比较新的一个版本（实际上目前项目中对版本要求没有十分严格）</li>\n</ol>\n<h3 id=\"menu_13\">工程目录</h3><p><img src=\"/static/upload/post/1646356850068.jpg\" alt=\"/static/upload/post/1646356850068.jpg\"/></p>\n<h3 id=\"menu_14\">核心类</h3><ul>\n<li>MyBatisPlusConfig：MyBatis-Plus配置类，配置Mapper扫描位置、分页插件等。</li>\n<li>RedisConfig：配置Redis为默认缓存工具及常见操作Bean配置。</li>\n<li>CodeMakerUtils：代码生成器的执行类</li>\n<li>JwtUserContext：JWT安全用户上下文对象（全局获取登录用户信息）</li>\n<li>JwtFilter：Jwt过滤器，核心过滤器（登录、授权、拦截）</li>\n<li>ExceptionHandler：全局异常捕获处理（AOP实现，支持自定义异常处理）</li>\n<li>RoleInterceptor：角色拦截器（基于自定义注解@RolePermission实现鉴权）</li>\n<li>EncryptionUtils：盐值加密工具（账号的密码生成，不可逆加密算法）</li>\n</ul>\n<h3 id=\"menu_15\">开发说明</h3><ol>\n<li>数据库初始化刷库</li>\n<li>application-dev.yml配置您的数据库信息和redis信息（默认localhost）</li>\n<li>启动App类</li>\n</ol>\n<p>启动示意图：</p>\n<p><img src=\"/static/upload/post/1646356961460.jpg\" alt=\"/static/upload/post/1646356961460.jpg\"/></p>\n<h2 id=\"menu_16\">前端</h2><h3 id=\"menu_17\">外部依赖</h3><ol>\n<li>Node.js（基本工具）</li>\n<li>Git（多数前端工程依赖会需要调用Git下载）</li>\n</ol>\n<h3 id=\"menu_18\">工程目录</h3><p><img src=\"/static/upload/post/1646356972142.jpg\" alt=\"/static/upload/post/1646356972142.jpg\"/></p>\n<p><img src=\"/static/upload/post/1646357023385.jpg\" alt=\"/static/upload/post/1646357023385.jpg\"/></p>\n<h3 id=\"menu_19\">相对原本的改动</h3><ol>\n<li>移除Mocks模拟返回服务（调用meal服务端工程）</li>\n<li>移除测试模块以及相关依赖</li>\n<li>移除Cookies插件依赖，Cookies统一替换为window.localStorage</li>\n<li>补充动态路由由服务端返回的用户角色集Roles控制</li>\n<li>移除自定义icon（svg格式），替换为element-ui的图标，直接修改了Sidebar/Item.vue</li>\n<li>核心方法getUserBase获取用户基础信息src/store/modules/user.js getInfo()</li>\n<li>增加v-droll可以自由在屏幕范围内拖动弹窗（src/directive/droll.js）</li>\n</ol>\n<h3 id=\"menu_20\">启动界面</h3><p><img src=\"/static/upload/post/1646356937696.jpg\" alt=\"/static/upload/post/1646356937696.jpg\"/></p>\n<h3 id=\"menu_21\">开发说明</h3><pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># 依赖下载</span>\nnpm install\n<span class=\"hljs-comment\"># 开发模式</span>\nnpm run dev\n<span class=\"hljs-comment\"># 生产编译</span>\nnpm run build\n</code></pre>\n<h1 id=\"menu_22\">关于个人</h1><p><a class=\"mlink\" href=\"http://www.mebugs.com/page/about.html\" title=\"关于米虫\" target=\"_blank\">关于米虫</a></p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">基本信息</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">特别致谢</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">功能清单</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">登陆页</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">工作中心</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">角色控制与多级菜单测试</a> <!----></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">个人密码管理</a> <!----></li><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl2\">账号管理</a> <!----></li><li><a href=\"javascript:runTo(\'menu_9\')\" class=\"pl2\">代码生成</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_10\')\" class=\"pl1\">开发说明</a> <ul><li><a href=\"javascript:runTo(\'menu_11\')\" class=\"pl2\">服务端</a> <ul><li><a href=\"javascript:runTo(\'menu_12\')\" class=\"pl3\">外部依赖</a></li><li><a href=\"javascript:runTo(\'menu_13\')\" class=\"pl3\">工程目录</a></li><li><a href=\"javascript:runTo(\'menu_14\')\" class=\"pl3\">核心类</a></li><li><a href=\"javascript:runTo(\'menu_15\')\" class=\"pl3\">开发说明</a></li></ul></li><li><a href=\"javascript:runTo(\'menu_16\')\" class=\"pl2\">前端</a> <ul><li><a href=\"javascript:runTo(\'menu_17\')\" class=\"pl3\">外部依赖</a></li><li><a href=\"javascript:runTo(\'menu_18\')\" class=\"pl3\">工程目录</a></li><li><a href=\"javascript:runTo(\'menu_19\')\" class=\"pl3\">相对原本的改动</a></li><li><a href=\"javascript:runTo(\'menu_20\')\" class=\"pl3\">启动界面</a></li><li><a href=\"javascript:runTo(\'menu_21\')\" class=\"pl3\">开发说明</a></li></ul></li></ul></li><li><a href=\"javascript:runTo(\'menu_22\')\" class=\"pl1\">关于个人</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1060, '# 基本信息\n\nMeal\'S是对Meal工程的增强版。\n\nMeal\'S依旧不会包含过多的业务逻辑，提供用户-角色-权限集的基础管理能力。\n\nMeal\'S可以实现自定义角色并为角色自由赋予权限，最终用户所具备的权限集是其所选择的角色权限集的并集。\n\nMeal\'S工程为了提升效率设置了相对科学的缓存命名空间，下文中会详细说明。\n\n服务端工程地址：[Gitee](https://gitee.com/mebugs/meals \"Gitee\") 丨 [GitHub](https://github.com/mebugs/meals \"GitHub\")\n\n前端工程地址：[Gitee](https://gitee.com/mebugs/meals-ui \"Gitee\") 丨 [GitHub](https://github.com/mebugs/meals-ui \"GitHub\")\n\n## 特别致谢\n\nMeal\'S服务端使用[MyBatis-Plus](https://mybatis.plus/ \"MyBatis-Plus\")作为基础脚手架。\n\nMeal\'S服务端使用[jjwt](https://github.com/jwtk/jjwt \"jjwt\")实现JWT快速加解密。\n\nMeal\'S-ui前端工程Fork自[vue-admin-template](https://github.com/PanJiaChen/vue-admin-template \"vue-admin-template\")。\n\n本人是JAVA服务端开发，[@花裤衩](https://github.com/PanJiaChen \"@花裤衩\")的前端系列开源项目为我学习Vue提供非常大的帮助，非常感谢！\n\n# 功能清单\n\nMeal\'S工程仅提供了最基本的账号-角色-权限集支撑能力，没有涉及其他功能页面。\n\n为了提供更为友好的体验，提供了账号查看自身权限集的能力。\n\n## 登陆页\n\n![/static/upload/post/1646357607925.jpg](/static/upload/post/1646357607925.jpg)\n\n## 个人中心\n\n![/static/upload/post/1646357623966.jpg](/static/upload/post/1646357623966.jpg)\n\n## 账号管理\n\n![/static/upload/post/1646357637822.jpg](/static/upload/post/1646357637822.jpg)\n\n## 角色管理\n\n![/static/upload/post/1646357657374.jpg](/static/upload/post/1646357657374.jpg)\n\n![/static/upload/post/1646357668420.jpg](/static/upload/post/1646357668420.jpg)\n\n\n## 权限集查看\n\n![/static/upload/post/1646357704403.jpg](/static/upload/post/1646357704403.jpg)\n\n## 代码生成\n\n![/static/upload/post/1646357677093.jpg](/static/upload/post/1646357677093.jpg)\n\n# 开发说明\n## 服务端\n### 外部依赖\n\n1. JDK 1.8 已知可能持续使用很长时间的版本\n2. MySql 5.7 经典版本\n3. Redis 6.0 比较新的一个版本（实际上目前项目中对版本要求没有十分严格）\n\n### 基本缓存结构说明\n\nMeal\'S才用了Redis作为默认缓存工具，为了提升鉴权和查询性能，主要实现两大缓存。\n\n权限树缓存：用于界面渲染树形结构。\n\n权限集缓存：用户服务端接口鉴权。\n\n设置缓存的主要目的用于降低数据库查询压力，尤其是查询权限树时，需要组装树形结构。\n\n![/static/upload/post/1646357747021.jpg](/static/upload/post/1646357747021.jpg)\n\n### 工程目录\n\n![/static/upload/post/1646357828391.jpg](/static/upload/post/1646357828391.jpg)\n\n### 核心类\n\n - MyBatisPlusConfig：MyBatis-Plus配置类，配置Mapper扫描位置、分页插件等。\n - RedisConfig：配置Redis为默认缓存工具及常见操作Bean配置。\n - CodeMakerUtils：代码生成器的执行类\n - JwtUserContext：JWT安全用户上下文对象（全局获取登录用户信息）\n - JwtFilter：Jwt过滤器，核心过滤器（登录、授权、拦截）\n - ExceptionHandler：全局异常捕获处理（AOP实现，支持自定义异常处理）\n - AuthorizeInterceptor：权限拦截器（基于自定义注解@Authorize实现鉴权）\n - EncryptionUtils：盐值加密工具（账号的密码生成，不可逆加密算法）\n - SysInitTask：系统启动任务（当前主要缓存全部权限树）\n - ThreadAuthRole：角色权限变动线程（根据变动的角色ID更新角色、涉及用户权限相关缓存）\n - ThreadPoolConfig：基于Spring的线程池配置\n\n### 开发说明\n\n1. 数据库初始化刷库\n2. application-dev.yml配置您的数据库信息和redis信息（默认localhost）\n3. 启动App类\n\n启动示意图：\n\n![/static/upload/post/1646357785945.jpg](/static/upload/post/1646357785945.jpg)\n\n\n## 前端\n### 外部依赖\n\n1. Node.js（基本工具）\n2. Git（多数前端工程依赖会需要调用Git下载）\n\n### 工程目录\n\n因为Meals-ui和Meal-ui的工程目录结构没有产生变动，因此此处直接引用了Meal-ui的工程目录结构图。\n\n![/static/upload/post/1646357795932.jpg](/static/upload/post/1646357795932.jpg)\n\n![/static/upload/post/1646357758580.jpg](/static/upload/post/1646357758580.jpg)\n\n### 相对原本的改动\n\n1. 移除Mocks模拟返回服务（调用meal服务端工程）\n2. 移除测试模块以及相关依赖\n3. 移除Cookies插件依赖，Cookies统一替换为window.localStorage\n4. 补充动态路由由服务端返回的用户角色集Roles控制\n5. 移除自定义icon（svg格式），替换为element-ui的图标，直接修改了Sidebar/Item.vue\n6. 核心方法getUserBase获取用户基础信息src/store/modules/user.js getInfo()\n7. 增加v-droll可以自由在屏幕范围内拖动弹窗（src/directive/droll.js）\n\n以下为Meals-ui基于Meal-ui增加的主要改动。\n\n1. 增加自定义指令v-authorize判断界面按钮菜单是否具备权限\n2. 修改路由rolse为auth（路由指定唯一auth标示需要的权限）\n3. 代码生成器增强，支持模糊查询表名，支持多选生成代码\n4. 对原本的element-ui主题配色进行了修改\n\n```html\n<!-- v-authorize使用方式 -->\n<button type=\"button\" v-authorize=\"\'SYS-USER-M\'\" />\n```\n\n\n### 启动界面\n\n![/static/upload/post/1646357843208.jpg](/static/upload/post/1646357843208.jpg)\n\n### 开发说明\n\n```bash\n# 依赖下载\nnpm install\n# 开发模式\nnpm run dev\n# 生产编译\nnpm run build\n```\n\n# 关于个人\n\n[关于米虫](http://www.mebugs.com/page/about.html)\n', '<h1 id=\"menu_1\">基本信息</h1><p>Meal&#39;S是对Meal工程的增强版。</p>\n<p>Meal&#39;S依旧不会包含过多的业务逻辑，提供用户-角色-权限集的基础管理能力。</p>\n<p>Meal&#39;S可以实现自定义角色并为角色自由赋予权限，最终用户所具备的权限集是其所选择的角色权限集的并集。</p>\n<p>Meal&#39;S工程为了提升效率设置了相对科学的缓存命名空间，下文中会详细说明。</p>\n<p>服务端工程地址：<a class=\"mlink\" href=\"https://gitee.com/mebugs/meals\" title=\"Gitee\" target=\"_blank\">Gitee</a> 丨 <a class=\"mlink\" href=\"https://github.com/mebugs/meals\" title=\"GitHub\" target=\"_blank\">GitHub</a></p>\n<p>前端工程地址：<a class=\"mlink\" href=\"https://gitee.com/mebugs/meals-ui\" title=\"Gitee\" target=\"_blank\">Gitee</a> 丨 <a class=\"mlink\" href=\"https://github.com/mebugs/meals-ui\" title=\"GitHub\" target=\"_blank\">GitHub</a></p>\n<h2 id=\"menu_2\">特别致谢</h2><p>Meal&#39;S服务端使用<a class=\"mlink\" href=\"https://mybatis.plus/\" title=\"MyBatis-Plus\" target=\"_blank\">MyBatis-Plus</a>作为基础脚手架。</p>\n<p>Meal&#39;S服务端使用<a class=\"mlink\" href=\"https://github.com/jwtk/jjwt\" title=\"jjwt\" target=\"_blank\">jjwt</a>实现JWT快速加解密。</p>\n<p>Meal&#39;S-ui前端工程Fork自<a class=\"mlink\" href=\"https://github.com/PanJiaChen/vue-admin-template\" title=\"vue-admin-template\" target=\"_blank\">vue-admin-template</a>。</p>\n<p>本人是JAVA服务端开发，<a class=\"mlink\" href=\"https://github.com/PanJiaChen\" title=\"@花裤衩\" target=\"_blank\">@花裤衩</a>的前端系列开源项目为我学习Vue提供非常大的帮助，非常感谢！</p>\n<h1 id=\"menu_3\">功能清单</h1><p>Meal&#39;S工程仅提供了最基本的账号-角色-权限集支撑能力，没有涉及其他功能页面。</p>\n<p>为了提供更为友好的体验，提供了账号查看自身权限集的能力。</p>\n<h2 id=\"menu_4\">登陆页</h2><p><img src=\"/static/upload/post/1646357607925.jpg\" alt=\"/static/upload/post/1646357607925.jpg\"/></p>\n<h2 id=\"menu_5\">个人中心</h2><p><img src=\"/static/upload/post/1646357623966.jpg\" alt=\"/static/upload/post/1646357623966.jpg\"/></p>\n<h2 id=\"menu_6\">账号管理</h2><p><img src=\"/static/upload/post/1646357637822.jpg\" alt=\"/static/upload/post/1646357637822.jpg\"/></p>\n<h2 id=\"menu_7\">角色管理</h2><p><img src=\"/static/upload/post/1646357657374.jpg\" alt=\"/static/upload/post/1646357657374.jpg\"/></p>\n<p><img src=\"/static/upload/post/1646357668420.jpg\" alt=\"/static/upload/post/1646357668420.jpg\"/></p>\n<h2 id=\"menu_8\">权限集查看</h2><p><img src=\"/static/upload/post/1646357704403.jpg\" alt=\"/static/upload/post/1646357704403.jpg\"/></p>\n<h2 id=\"menu_9\">代码生成</h2><p><img src=\"/static/upload/post/1646357677093.jpg\" alt=\"/static/upload/post/1646357677093.jpg\"/></p>\n<h1 id=\"menu_10\">开发说明</h1><h2 id=\"menu_11\">服务端</h2><h3 id=\"menu_12\">外部依赖</h3><ol>\n<li>JDK 1.8 已知可能持续使用很长时间的版本</li>\n<li>MySql 5.7 经典版本</li>\n<li>Redis 6.0 比较新的一个版本（实际上目前项目中对版本要求没有十分严格）</li>\n</ol>\n<h3 id=\"menu_13\">基本缓存结构说明</h3><p>Meal&#39;S才用了Redis作为默认缓存工具，为了提升鉴权和查询性能，主要实现两大缓存。</p>\n<p>权限树缓存：用于界面渲染树形结构。</p>\n<p>权限集缓存：用户服务端接口鉴权。</p>\n<p>设置缓存的主要目的用于降低数据库查询压力，尤其是查询权限树时，需要组装树形结构。</p>\n<p><img src=\"/static/upload/post/1646357747021.jpg\" alt=\"/static/upload/post/1646357747021.jpg\"/></p>\n<h3 id=\"menu_14\">工程目录</h3><p><img src=\"/static/upload/post/1646357828391.jpg\" alt=\"/static/upload/post/1646357828391.jpg\"/></p>\n<h3 id=\"menu_15\">核心类</h3><ul>\n<li>MyBatisPlusConfig：MyBatis-Plus配置类，配置Mapper扫描位置、分页插件等。</li>\n<li>RedisConfig：配置Redis为默认缓存工具及常见操作Bean配置。</li>\n<li>CodeMakerUtils：代码生成器的执行类</li>\n<li>JwtUserContext：JWT安全用户上下文对象（全局获取登录用户信息）</li>\n<li>JwtFilter：Jwt过滤器，核心过滤器（登录、授权、拦截）</li>\n<li>ExceptionHandler：全局异常捕获处理（AOP实现，支持自定义异常处理）</li>\n<li>AuthorizeInterceptor：权限拦截器（基于自定义注解@Authorize实现鉴权）</li>\n<li>EncryptionUtils：盐值加密工具（账号的密码生成，不可逆加密算法）</li>\n<li>SysInitTask：系统启动任务（当前主要缓存全部权限树）</li>\n<li>ThreadAuthRole：角色权限变动线程（根据变动的角色ID更新角色、涉及用户权限相关缓存）</li>\n<li>ThreadPoolConfig：基于Spring的线程池配置</li>\n</ul>\n<h3 id=\"menu_16\">开发说明</h3><ol>\n<li>数据库初始化刷库</li>\n<li>application-dev.yml配置您的数据库信息和redis信息（默认localhost）</li>\n<li>启动App类</li>\n</ol>\n<p>启动示意图：</p>\n<p><img src=\"/static/upload/post/1646357785945.jpg\" alt=\"/static/upload/post/1646357785945.jpg\"/></p>\n<h2 id=\"menu_17\">前端</h2><h3 id=\"menu_18\">外部依赖</h3><ol>\n<li>Node.js（基本工具）</li>\n<li>Git（多数前端工程依赖会需要调用Git下载）</li>\n</ol>\n<h3 id=\"menu_19\">工程目录</h3><p>因为Meals-ui和Meal-ui的工程目录结构没有产生变动，因此此处直接引用了Meal-ui的工程目录结构图。</p>\n<p><img src=\"/static/upload/post/1646357795932.jpg\" alt=\"/static/upload/post/1646357795932.jpg\"/></p>\n<p><img src=\"/static/upload/post/1646357758580.jpg\" alt=\"/static/upload/post/1646357758580.jpg\"/></p>\n<h3 id=\"menu_20\">相对原本的改动</h3><ol>\n<li>移除Mocks模拟返回服务（调用meal服务端工程）</li>\n<li>移除测试模块以及相关依赖</li>\n<li>移除Cookies插件依赖，Cookies统一替换为window.localStorage</li>\n<li>补充动态路由由服务端返回的用户角色集Roles控制</li>\n<li>移除自定义icon（svg格式），替换为element-ui的图标，直接修改了Sidebar/Item.vue</li>\n<li>核心方法getUserBase获取用户基础信息src/store/modules/user.js getInfo()</li>\n<li>增加v-droll可以自由在屏幕范围内拖动弹窗（src/directive/droll.js）</li>\n</ol>\n<p>以下为Meals-ui基于Meal-ui增加的主要改动。</p>\n<ol>\n<li>增加自定义指令v-authorize判断界面按钮菜单是否具备权限</li>\n<li>修改路由rolse为auth（路由指定唯一auth标示需要的权限）</li>\n<li>代码生成器增强，支持模糊查询表名，支持多选生成代码</li>\n<li>对原本的element-ui主题配色进行了修改</li>\n</ol>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&lt;!-- v-authorize使用方式 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> <span class=\"hljs-attr\">v-authorize</span>=<span class=\"hljs-string\">&quot;&#x27;SYS-USER-M&#x27;&quot;</span> /&gt;</span>\n</code></pre>\n<h3 id=\"menu_21\">启动界面</h3><p><img src=\"/static/upload/post/1646357843208.jpg\" alt=\"/static/upload/post/1646357843208.jpg\"/></p>\n<h3 id=\"menu_22\">开发说明</h3><pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># 依赖下载</span>\nnpm install\n<span class=\"hljs-comment\"># 开发模式</span>\nnpm run dev\n<span class=\"hljs-comment\"># 生产编译</span>\nnpm run build\n</code></pre>\n<h1 id=\"menu_23\">关于个人</h1><p><a class=\"mlink\" href=\"http://www.mebugs.com/page/about.html\" title=\"关于米虫\" target=\"_blank\">关于米虫</a></p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">基本信息</a> <ul><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl2\">特别致谢</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl1\">功能清单</a> <ul><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl2\">登陆页</a> <!----></li><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">个人中心</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">账号管理</a> <!----></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">角色管理</a> <!----></li><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl2\">权限集查看</a> <!----></li><li><a href=\"javascript:runTo(\'menu_9\')\" class=\"pl2\">代码生成</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_10\')\" class=\"pl1\">开发说明</a> <ul><li><a href=\"javascript:runTo(\'menu_11\')\" class=\"pl2\">服务端</a> <ul><li><a href=\"javascript:runTo(\'menu_12\')\" class=\"pl3\">外部依赖</a></li><li><a href=\"javascript:runTo(\'menu_13\')\" class=\"pl3\">基本缓存结构说明</a></li><li><a href=\"javascript:runTo(\'menu_14\')\" class=\"pl3\">工程目录</a></li><li><a href=\"javascript:runTo(\'menu_15\')\" class=\"pl3\">核心类</a></li><li><a href=\"javascript:runTo(\'menu_16\')\" class=\"pl3\">开发说明</a></li></ul></li><li><a href=\"javascript:runTo(\'menu_17\')\" class=\"pl2\">前端</a> <ul><li><a href=\"javascript:runTo(\'menu_18\')\" class=\"pl3\">外部依赖</a></li><li><a href=\"javascript:runTo(\'menu_19\')\" class=\"pl3\">工程目录</a></li><li><a href=\"javascript:runTo(\'menu_20\')\" class=\"pl3\">相对原本的改动</a></li><li><a href=\"javascript:runTo(\'menu_21\')\" class=\"pl3\">启动界面</a></li><li><a href=\"javascript:runTo(\'menu_22\')\" class=\"pl3\">开发说明</a></li></ul></li></ul></li><li><a href=\"javascript:runTo(\'menu_23\')\" class=\"pl1\">关于个人</a> <!----></li></ul>');
INSERT INTO `post_info` VALUES (1061, '# 前言\n\n上次更新博客还是上次。\n\n近一年更换了工作以及技术栈，努力适应公司的业务，博客也疏于打理。\n\n一直以来准备对本站进行全量的重构，总是一拖再拖。\n\n从2021年4月开始，正式开通了本站的代码仓库，有时间就补充一些功能。\n\n不自觉已经过去了快一年，才完成本站的全部内容。\n\n这个工作效率真是令自己无比汗颜。\n\n整体开发分四个阶段：\n\n1. HTML静态UI编码（中途推翻一个版本）\n2. Vue+PHP后端管理中心的开发\n3. PHP渲染前端页面编码\n4. PHP渲染转静态化+定时任务+配置管理\n\n# 技术栈\n\n- PHP7.4：服务端语言\n- MySQL5.7：关系型数据库\n- Vue.js：管理中心\n- HTML、CSS、JavaScript\n\n## 实现逻辑\n\n本站首访页面均为纯HTML，无需经过PHP查询数据库数据。\n\n完整的处理流程如下：\n\n![/static/upload/post/1646380450802.jpg](/static/upload/post/1646380450802.jpg)\n\n这样做的好处在于，访问网页时直接解析Nginx返回的HTML文件，不会受到PHP和MySQL数据性能屏障约束。\n\n缺点是提交的评论或其他数据不会实时展示，不过本站的评论或友链需要审核，因此这个算不上什么问题。\n\n# 前端功能清单\n\n除了常规的文章阅读之外，本站提供了以下功能。\n\n## 留言\n\n支持在任意文章下留言（需要审核），支持用户在头像库中任选头像。\n\n评论基本信息记忆（由浏览器本地完成记忆）\n\n支持评论文章，回复评论。回复二级评论。\n\n## 友链\n\n支持自行申请友链，支持是否申请首页友链。\n\n支持一键读取站点名、描述、图标（支持自行上传图标）。\n\n友链需要审核。\n\n## 地图\n\n支持模糊查询本站全部文章（目前仅支持标题模糊）。\n\n# 管理端功能清单\n\n暂不赘述，见下图（本地开发版本）。\n\n![/static/upload/post/1646381058716.png](/static/upload/post/1646381058716.png)\n\n# 开源地址\n\n暂未考虑开放一键安装等功能，代码仅供参考。\n\n[Gitee](https://gitee.com/mebugs/mebugs.com) 丨 [Github](https://github.com/mebugs/mebugs.com)', '<h1 id=\"menu_1\">前言</h1><p>上次更新博客还是上次。</p>\n<p>近一年更换了工作以及技术栈，努力适应公司的业务，博客也疏于打理。</p>\n<p>一直以来准备对本站进行全量的重构，总是一拖再拖。</p>\n<p>从2021年4月开始，正式开通了本站的代码仓库，有时间就补充一些功能。</p>\n<p>不自觉已经过去了快一年，才完成本站的全部内容。</p>\n<p>这个工作效率真是令自己无比汗颜。</p>\n<p>整体开发分四个阶段：</p>\n<ol>\n<li>HTML静态UI编码（中途推翻一个版本）</li>\n<li>Vue+PHP后端管理中心的开发</li>\n<li>PHP渲染前端页面编码</li>\n<li>PHP渲染转静态化+定时任务+配置管理</li>\n</ol>\n<h1 id=\"menu_2\">技术栈</h1><ul>\n<li>PHP7.4：服务端语言</li>\n<li>MySQL5.7：关系型数据库</li>\n<li>Vue.js：管理中心</li>\n<li>HTML、CSS、JavaScript</li>\n</ul>\n<h2 id=\"menu_3\">实现逻辑</h2><p>本站首访页面均为纯HTML，无需经过PHP查询数据库数据。</p>\n<p>完整的处理流程如下：</p>\n<p><img src=\"/static/upload/post/1646380450802.jpg\" alt=\"/static/upload/post/1646380450802.jpg\"/></p>\n<p>这样做的好处在于，访问网页时直接解析Nginx返回的HTML文件，不会受到PHP和MySQL数据性能屏障约束。</p>\n<p>缺点是提交的评论或其他数据不会实时展示，不过本站的评论或友链需要审核，因此这个算不上什么问题。</p>\n<h1 id=\"menu_4\">前端功能清单</h1><p>除了常规的文章阅读之外，本站提供了以下功能。</p>\n<h2 id=\"menu_5\">留言</h2><p>支持在任意文章下留言（需要审核），支持用户在头像库中任选头像。</p>\n<p>评论基本信息记忆（由浏览器本地完成记忆）</p>\n<p>支持评论文章，回复评论。回复二级评论。</p>\n<h2 id=\"menu_6\">友链</h2><p>支持自行申请友链，支持是否申请首页友链。</p>\n<p>支持一键读取站点名、描述、图标（支持自行上传图标）。</p>\n<p>友链需要审核。</p>\n<h2 id=\"menu_7\">地图</h2><p>支持模糊查询本站全部文章（目前仅支持标题模糊）。</p>\n<h1 id=\"menu_8\">管理端功能清单</h1><p>暂不赘述，见下图（本地开发版本）。</p>\n<p><img src=\"/static/upload/post/1646381058716.png\" alt=\"/static/upload/post/1646381058716.png\"/></p>\n<h1 id=\"menu_9\">开源地址</h1><p>暂未考虑开放一键安装等功能，代码仅供参考。</p>\n<p><a class=\"mlink\" href=\"https://gitee.com/mebugs/mebugs.com\" title=\"Gitee\" target=\"_blank\">Gitee</a> 丨 <a class=\"mlink\" href=\"https://github.com/mebugs/mebugs.com\" title=\"Github\" target=\"_blank\">Github</a></p>\n', '<ul><li><a href=\"javascript:runTo(\'menu_1\')\" class=\"pl1\">前言</a> <!----></li><li><a href=\"javascript:runTo(\'menu_2\')\" class=\"pl1\">技术栈</a> <ul><li><a href=\"javascript:runTo(\'menu_3\')\" class=\"pl2\">实现逻辑</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_4\')\" class=\"pl1\">前端功能清单</a> <ul><li><a href=\"javascript:runTo(\'menu_5\')\" class=\"pl2\">留言</a> <!----></li><li><a href=\"javascript:runTo(\'menu_6\')\" class=\"pl2\">友链</a> <!----></li><li><a href=\"javascript:runTo(\'menu_7\')\" class=\"pl2\">地图</a> <!----></li></ul></li><li><a href=\"javascript:runTo(\'menu_8\')\" class=\"pl1\">管理端功能清单</a> <!----></li><li><a href=\"javascript:runTo(\'menu_9\')\" class=\"pl1\">开源地址</a> <!----></li></ul>');

-- ----------------------------
-- Table structure for post_main
-- ----------------------------
DROP TABLE IF EXISTS `post_main`;
CREATE TABLE `post_main`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '文章ID',
  `title` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标题',
  `url` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '静态URL',
  `banner` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '主图',
  `remark` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '描述',
  `cid` bigint(20) NULL DEFAULT NULL COMMENT '分类ID',
  `status` smallint(6) NULL DEFAULT NULL COMMENT '状态',
  `view` int(11) NOT NULL DEFAULT 0 COMMENT '阅读量',
  `depth` int(11) NOT NULL DEFAULT 0 COMMENT '深度阅读量',
  `monthView` int(11) NOT NULL DEFAULT 0 COMMENT '近期热门',
  `randno` int(11) NOT NULL DEFAULT 0 COMMENT '随机排序',
  `openComms` smallint(1) NOT NULL DEFAULT 0 COMMENT '是否开放评论',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1062 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章主表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of post_main
-- ----------------------------
INSERT INTO `post_main` VALUES (1, '关于米虫丨关于本站丨一些寄语', 'about', '1642035882963.jpg', '关于米虫的个人经历，本站的起源，域名的由来与意义，大致介绍构建本站的整体技术方案。个人过往经历的感悟，一些想法与体会，与君分享，与君共勉，希望您有所收获！', 15, 2, 0, 0, 0, 203, 0);
INSERT INTO `post_main` VALUES (2, '米虫的留言板', 'msg', '1642156318557.jpg', '这里是米虫的留言板，如果您有什么建议或疑问，请在这里留言！推荐您留下邮箱，该信息不会外泄，当我回复时会通过邮件知会您！', 15, 2, 0, 0, 0, 107, 0);
INSERT INTO `post_main` VALUES (1000, 'JAVA实例化对象的五种方式', 'javaobj', '1642463972831.jpg', '面向对象的编程语言JAVA，万物皆为对象，工作中我们常常会将创建（实例化）对象的操作交给框架或者容器（如SpringIoC），但依旧需要了解JAVA实例化对象的多种方式', 1, 1, 3, 1, 1, 928, 0);
INSERT INTO `post_main` VALUES (1001, '交互式脚本expect脚本实现自动化', 'expect', '1642465194118.jpg', 'expect脚本由一系列expect-send对组成，等待输出中输出特定的字符，通常是一个提示符，然后发送特定的响应，特别适用于需要批量手动输入命令的自动化操作改造', 5, 1, 3, 0, 1, 321, 0);
INSERT INTO `post_main` VALUES (1002, 'Jquery中.attr()和.prop()方法', 'jqwrit', '1644832168729.jpg', 'Jquery中使用attr()方法动态设置多选框被选中状态时不生效或需要操作多次方可生效的问题可通过prop()替代完成，当需要设置html原生属性时最好使用prop()方法来进行操作', 6, 1, 1, 0, 1, 821, 0);
INSERT INTO `post_main` VALUES (1003, '关键：Linux系统磁盘挂载', 'diskgz', '1644888437645.jpg', 'Linux系统一般情况下启动默认只加载系统盘，支持其他磁盘自由热插拔，如果发现自己的某些目录找不见了的时候不要慌看看是不是没有设置开机启动自动加载挂载磁盘内容，另外要特别注意首次安装系统记得磁盘挂载操作', 5, 1, 2, 0, 1, 141, 0);
INSERT INTO `post_main` VALUES (1004, 'Crontab配置定时任务处理日常工作', 'crontl', '1644890138387.jpg', 'Linux服务器测试环境或正式生产环境常常设计一些定时例行处理的操作，如日记备份转移清理等，利用Crontab+Shell脚本组合实现定期定时操作，确保不会应工作繁忙忘记任务导致环境异常', 5, 1, 3, 0, 2, 244, 0);
INSERT INTO `post_main` VALUES (1005, 'CSS3通过Gradients实现渐变背景色', 'gradc', '1645013231825.jpg', '使用背景色渐变可以使得页面质感得到大幅度提升，CSS样式中通过gradients属性指定两个或多个颜色之间平滑过渡，由于颜色的渐变是由浏览器生成，因此不会出现不同分辨率下失真的情况。', 6, 1, 3, 0, 1, 797, 0);
INSERT INTO `post_main` VALUES (1006, 'Beyond Compare 4 无限试用方案', 'bcomp', '1645055993907.jpg', 'Beyond Compare 强大专业的文件和文件夹对比工具，可以很方便地比较出文件或文件夹的差异，支持众多种格式的对比，支持快速替换，商用软件，默认试用30天（次）+15天，过期后可以进行重复试用。', 16, 1, 3, 0, 2, 255, 0);
INSERT INTO `post_main` VALUES (1007, 'Servlet生命周期及数据流转过程', 'servlet', '1645056985017.jpg', 'Spring家族大行其道的今天，很多人可能未必还记得JAVA中原生Servlet对象的一些知识，实际上SpringMVC就是基于Servlet进行的封装，记录Servlet对象生命周期及数据流转过程', 1, 1, 2, 0, 1, 885, 0);
INSERT INTO `post_main` VALUES (1008, 'instantclick.js预加载实现网页秒开', 'upspeed', '1645059069074.jpg', 'instantclick.js利用预加载技术使得网站页面跳转时的速度得到大大提升，通过预加载数据替换当前的DOM结构体来达到减少页面请求返回的数据量，提供事件监听钩子函数便于完成页面初始化', 6, 1, 1, 1, 1, 658, 0);
INSERT INTO `post_main` VALUES (1009, '通过ulimit命令解决Too many open files', 'ulimit', '1645145205665.jpg', '项目启动报错：Too many open files，通过ulimit命令可以查看与管理用户/程序/进程占用资源情况，其中比较实用的是可以根据资源情况配置linux用户的最大进程数', 5, 1, 1, 0, 1, 637, 0);
INSERT INTO `post_main` VALUES (1010, 'Eclipse中操作Git进行代码关联/拉取/推送', 'ecligit', '1645146446122.jpg', 'Eclipse可以直接通过GitRepositories直接创建本地项目与Git仓库关联，clone代码，同步、拉取以及推送代码，对于曾经经常使用SVN插件的小伙伴上手会相对容易。', 1, 1, 2, 0, 1, 213, 0);
INSERT INTO `post_main` VALUES (1011, '多环境间信任关系添加的完整与快捷流程', 'trushgx', '1645437781727.jpg', '项目上的开发和测试环境非常多，少则数十多则上百，实际工作中实在懒得来回登录或打开各个环境，最好的方案就是给内网环境间添加一下信任关系，便于快速在环境之间切换，免去输入密码的烦恼', 5, 1, 2, 0, 1, 153, 0);
INSERT INTO `post_main` VALUES (1012, 'Oracle数据库基础实用维护命令集', 'orascri', '1645492060246.jpg', 'Linux系统下的Oracle数据库实用常用的维护命令整理，本文内容偏向运维，主要包含：基础启动重启、表空间维护、数据库角色与用户维护、字符集配置等，并给出各类场景的实例语句', 7, 1, 1, 0, 1, 128, 0);
INSERT INTO `post_main` VALUES (1013, 'Nginx地址重写（rewrite）配置规则', 'nginxre', '1645493256419.jpg', 'UrlRewrite并非Nginx容器独有，访问地址重写一般多用于实现伪静态，实现对用户访问的URL进行重写，以达到访问地址美观、不暴露访问参数的目的，再配合应用程序可以实现很多特殊的场景', 12, 1, 4, 0, 1, 181, 0);
INSERT INTO `post_main` VALUES (1014, 'uni-app仿生导航操作WebView（网络页面）', 'uniwebv', '1645527166229.jpg', '页面中的WebView嵌入一个网络页面后，顶部原生导航栏默认是整个页面返回，而实际上我们需要操作的是WebView内网页的后退，因此我们可以通过获取子WebView对象进行操作', 8, 1, 1, 0, 1, 521, 0);
INSERT INTO `post_main` VALUES (1015, 'MySql数据库设置表名大小写不敏感', 'mysqlinux', '1645666327141.jpg', 'MySql数据库在Linux系统下默认数据库名与表名严格区分大小写，一般情况下我们创建表名习惯使用全小写，如果遇到某些从Windows服务器迁移过来的数据库可能需要设置大小写不敏感', 7, 1, 1, 0, 1, 62, 0);
INSERT INTO `post_main` VALUES (1016, 'MyBatis-Plus中常用的Lambda无SQL父类方法', 'mybatispll', '1645666539566.jpg', 'MyBatis-Plus是一个基于MyBatis的增强脚手架，使用其封装好的各类接口可能在实际开发过程无需手写SQL快速完成业务开发，尤其在JDK1.8后的Lambda语法下使用更为方便', 1, 1, 1, 1, 1, 747, 0);
INSERT INTO `post_main` VALUES (1017, 'Chrome开发者模式保留访问日志以及过滤请求', 'chromereq', '1645684640057.jpg', 'Chrome开发者模式下提供了保保留访问日志的能力便于检查历史请求是否正常，同时提供了请求显示过滤器可以方便快速定位您想看的请求记录或过滤掉某些不想显示的请求记录', 16, 1, 1, 0, 1, 548, 0);
INSERT INTO `post_main` VALUES (1018, 'JAVA中创建线程的三种方式的使用与区别', 'javathread', '1645752567133.jpg', 'JAVA中通过继承Thread类、实现Runnable接口以及实现Callable接口配合Future接口实现创建多线程，三种方式各有优缺点，而第三种则具备更多的增强能力', 1, 1, 1, 0, 1, 503, 0);
INSERT INTO `post_main` VALUES (1019, '启动Docker后ssh连接自动断开且无法连接', 'dockssh', '1645764740644.jpg', 'CentOS7.9在启动Docker之后会出现卡死，ssh远程连接（XShell）自动断开且无法再次连接，仅重启后方能连接，但启动Docker之后依旧出现前面的相同情况的问题解决方案', 12, 1, 1, 0, 1, 869, 0);
INSERT INTO `post_main` VALUES (1020, 'Git在各种场景下的仓库关联', 'gitderes', '1645765677783.jpg', '本文针对Git常见的三种场景：全新工程、本地已有工程、以及其他分支关联，详细的操作命令、流程、作用以及注意事项，Git命令并不受代码托管平台的影响，因此本质上可以通用解决问题', 16, 1, 1, 0, 1, 838, 0);
INSERT INTO `post_main` VALUES (1021, '分布式缓存的应用价值与优势所在', 'fbscache', '1645770085297.jpg', '解决高并发访问的最为直接的方式是应用缓存，除了常见的本地缓存之外，我们还可以引入分布式缓存（如Redis），分布式缓存在系统架构中有什么优势和应用价值是什么呢？', 11, 1, 1, 0, 1, 584, 0);
INSERT INTO `post_main` VALUES (1022, 'Maven的pom配置文件的scope属性', 'mavenscop', '1645785410064.jpg', 'scope属性主要用于控制依赖范围，主要分为编译、打包、运行、测试、依赖传递等各个常见，scope不同于optional提供了更多可选择的配置参数用于应对不同的依赖场景。', 1, 1, 1, 0, 1, 407, 0);
INSERT INTO `post_main` VALUES (1023, 'SQL通过CASE WHEN语句实现条件返回', 'sqlcashw', '1645785805640.jpg', '通过CASE WHEN语句进行设置不同的条件格式匹配后返回指定的值，能够在不修改源表数据的前提下查询展示出我们需要的信息，CASE WHEN语句的语法语义以及实际使用案例。', 7, 1, 1, 0, 1, 283, 0);
INSERT INTO `post_main` VALUES (1024, 'Windows版本的Redis（新版本的GitHub地址）', 'gitrediurl', '1645786170487.jpg', 'Redis目前提供源码、Docker镜像、云版三种下载形式，官网没有提供Windows版本下载和安装，除了商业化的Memurai之外想获得较新的Windows版本的Redis还得再GitHub找！', 10, 1, 1, 0, 1, 195, 0);
INSERT INTO `post_main` VALUES (1025, 'Spring、SpringMVC和SpringBoot', 'springhome', '1645786549085.jpg', 'Spring就像一个大家族，里面包含了很多衍生产品，其中最为出名的就是SpringMVC和SpringBoot，那么这三者之间是什么关系呢？SpringMVC和SpringBoot又专门用来做什么呢？', 1, 1, 2, 0, 2, 126, 0);
INSERT INTO `post_main` VALUES (1026, 'Android Studio关闭网络代理（同步gradle配置）', 'asgradlecf', '1646006214760.jpg', '现阶段中Android Studio所需要的绝大多数SDK和依赖一般都不需要使用网络代理去访问，但是仅仅在Android Studio关闭代理配置不能完成使得设置生效，还需要gradle.properties中删除配置。', 8, 1, 1, 0, 1, 44, 0);
INSERT INTO `post_main` VALUES (1027, 'MVC设计模式详解（思想、结构、作用与实现）', 'mvcdown', '1646006507355.jpg', 'MVC的全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范，本身并不引入新的功能，用来指导我们改善应用程序的架构，使得模型和视图相分离，得到更好的开发和维护效率。', 11, 1, 1, 0, 1, 845, 0);
INSERT INTO `post_main` VALUES (1028, '一文理解SpringMVC框架核心', 'smvcdata', '1646007019535.jpg', 'SpringMVC框架是围绕DispatcherServlet（前端控制器）展开的，本文描述SpringMVC的优点、各个核心类（角色）作用，并说明用户请求数据到最终视图返回完整的数据传输过程', 1, 1, 4, 0, 4, 91, 0);
INSERT INTO `post_main` VALUES (1029, 'maven管理JAVA项目pom.xml文件实例', 'mavpomx', '1646007353909.jpg', 'maven是专门用于构建和管理Java相关项目的管理工具，提供了项目对象模型（POM）文件的新概念来管理项目的构建相关性和文档，其中pom.xml文件描述了maven项目的基本信息。', 1, 1, 2, 0, 2, 923, 0);
INSERT INTO `post_main` VALUES (1030, 'Struts2原生校验器以及自定义校验器', 'strustvalt', '1646007630828.jpg', 'Struts2校验框架可以在request进Action之前对请求参数进行校验，非法则拦截返回，框架自带了不少常用校验器可以直接配置此外我们可以自定义一个校验器已满足自身的定制诉求', 1, 1, 1, 0, 1, 342, 0);
INSERT INTO `post_main` VALUES (1031, 'Struts2 + Spring框架融合配置', 'strustmvc', '1646008181748.jpg', 'Struts2框架以WebWork优秀的设计思想为核心，吸收了 Struts框架的部分优点，提供了一个更加整洁的MVC设计模式实现的Web应用程序框架，本文主要是与Spring整合关键配置和实例', 1, 1, 0, 0, 0, 942, 0);
INSERT INTO `post_main` VALUES (1032, 'Jquery+CSS3实现网页入场动画特效', 'lodingin', '1646008724670.jpg', '多数网站首页的数据往往是最庞大的，三到五秒打开都算比较优秀，因此设置一个开场（预加载）动画特效能够大幅度提升用户感官体验，这里分享本站使用的加载动画，整体比较简约清新', 6, 1, 2, 0, 2, 685, 0);
INSERT INTO `post_main` VALUES (1033, 'Xshell6和Xftp6家庭版（Xmanager系列工具）', 'xmanage', '1646008924962.jpg', 'Xmanager是一个非开源（商用）的实用无缝衔接工具（个人可以获取家庭版），其中最常用的Xshell和Xftp可以非常便捷的在Windows系统下连接Unix环境，是目前市面最好的连接工具，运维工程师必备良品', 16, 1, 0, 0, 0, 598, 0);
INSERT INTO `post_main` VALUES (1034, '侧边栏下滑即将越过时动态固顶与上滑恢复', 'slideres', '1646009437104.jpg', '对于很多二栏布局的网站而言，正文部分过长时，侧边栏区域下拉过程中出现大片空白，因此我们可以实现当屏幕下滑达到指定元素位置（如即将越过）后对元素固顶来解决侧边栏区域的空旷感', 6, 1, 3, 0, 3, 936, 0);
INSERT INTO `post_main` VALUES (1035, 'SpringContextHolder工具类自由获取Bean', 'holdgbean', '1646010018677.jpg', '在工程中会存在一些未被纳入Spring框架管理的类，想调用Spring容器中的bean时可以通过SpringContextHolder工具类的getBean方法来获取指定的bean，比如过滤器、拦截器、自动任务等', 1, 1, 3, 0, 3, 887, 0);
INSERT INTO `post_main` VALUES (1036, 'Jquery+CSS轻松实现导航动态显示隐藏', 'jcheadh', '1646010594005.jpg', '绝大多数网站都会有个顶部导航，对于手机端而言为了便于访问导航常常会做固顶操作，通过CSS样式配合Jquery的scroll()方法或原生JS监听滑动事件方法，可以轻松实现下滑隐藏，上滑显示的效果', 6, 1, 2, 0, 2, 627, 0);
INSERT INTO `post_main` VALUES (1037, 'JavaScript预防频繁点击误操作（防抖处理）', 'dobchk', '1646023411667.jpg', '前端通过点击触发向服务端发起数据请求的地方特别需要注意添加防双击/频繁点击操作的预防处理，双击/频繁点击的误操作可能导致数据重复或者异常，影响用户体验', 6, 1, 0, 0, 0, 476, 0);
INSERT INTO `post_main` VALUES (1038, '处理windows系统pagefile.sys大量占用C盘空间', 'bigfiles', '1646023967415.jpg', 'pagefile.sys文件一般存在于c盘，只有点击系统的隐藏属性才能看到它，这个文件的容量一般都比较大，而且大小不是固定的，不可以直接删除，会出现内存不足错误需要进行特定配置', 12, 1, 0, 0, 0, 497, 0);
INSERT INTO `post_main` VALUES (1039, 'SQL语句中DELETE、TRUNCATE和DROP的区别', 'delqbsql', '1646024156414.jpg', '当我们需要清理或删除某张表或数据的时候，通常会有采取DELETE、TRUNCATE、DROP的任意一种形式的SQL语句，他们之间作用的对象不同所产生的效果也各不相同，包括执行结果和效率', 7, 1, 0, 0, 0, 57, 0);
INSERT INTO `post_main` VALUES (1040, '合理配置php-fpm参数减少服务器内存浪费', 'phpfpmxc', '1646100627063.jpg', 'PHP应用有时候出现503错误的时候可能内存不足导致访问网站无响应，当发现实际应用数理不多的情况，可以考虑检查是不是有可能由于php-fpm进程过多导致，可以通过参数配置解决问题', 4, 1, 0, 0, 0, 794, 0);
INSERT INTO `post_main` VALUES (1041, 'PHP截取指定长度的字符串mb_substr()', 'phpsubss', '1646101105145.jpg', 'PHP中常见的截取字符串substr()函数使用非常容易，但是有时针对中文截取时会出现乱码问题（主要是由于编码类型导致），可以通过mb_substr()处理，其差异在于需要指定文字字符集即可解决', 4, 1, 0, 0, 0, 800, 0);
INSERT INTO `post_main` VALUES (1042, 'CSS文字超出隐藏添加省略号及失效处理', 'cssouthid', '1646101414193.jpg', '在前端页面中文字超出隐藏并添加省略号是比较常见的样式处理，实际CSS样式中单行省略和多行省略的样式有所差异，在某些特殊场景下多行超出的样式会不生效，本文给出相关解决方案', 6, 1, 0, 0, 0, 620, 0);
INSERT INTO `post_main` VALUES (1043, '前端多终端自适应网页开发模式', 'zsycsshtml', '1646128839253.jpg', '智能移动终端大爆发的现阶段，手机访问网页已经成为人们不可或缺的使用习惯，开发自适应网页大势所趋，实际上无论改造还是开发本身并不复杂，但是掌握更好的开发模式会使得你编写页面更加高效快捷', 6, 1, 0, 0, 0, 701, 0);
INSERT INTO `post_main` VALUES (1044, 'Oracle数据库删除用户时提示用户存在连接', 'odeluser', '1646131799732.jpg', '在开发或测试的Oracle数据库中，为了模拟真实环境的首次安装，我们常常会不断的创建和删除数据库用户，有时候在删除数据库用户的时候会遇到提示用户存在连接，如何处理？', 7, 1, 0, 0, 0, 645, 0);
INSERT INTO `post_main` VALUES (1045, '自定义filter过滤器拦截未登录（非法）请求', 'webfiltergo', '1646132013719.jpg', '在JAVA的WEB工程中我们可以将JSP页面文件放在WEB-INFO中限制用户进行URL直接访问，但静态资源如js、css文件却是需要被外部直接访问的，直接对外暴露又不太安全，可以通过自定义过滤器处理', 1, 1, 0, 0, 0, 122, 0);
INSERT INTO `post_main` VALUES (1046, 'Oracle数据库MERGE INTO语句条件入库', 'meginto', '1646135907738.jpg', 'Oracle 9i版本引入MERGE INTO语句，其主要用于实现条件入库能力，用于解决对于已有数据更新升级的情况，即可实现不存在数据则插入，存在数据则更新的分支判断形式的更新能力', 7, 1, 0, 0, 0, 675, 0);
INSERT INTO `post_main` VALUES (1047, 'Linux采用EOF实现一键改密Shell脚本', 'shellrepwd', '1646184850311.jpg', 'Linux环境的Shell中通常将EOF与<<结合使用，表示后续的输入作为子命令或子Shell的输入，直到遇到EOF为止，再返回到主调Shell，其特性可用于写入文件执行某些自定义操作等场景', 5, 1, 0, 0, 0, 11, 0);
INSERT INTO `post_main` VALUES (1048, 'Jquery1.7+绑定事件on()方法使用案例', 'jqueryonx', '1646185584629.jpg', 'Jquery绑定事件后很多中方式bind()、live()、delegate()、on()，实际应用中比较推荐采用on()的方式去处理，具有较高的自定义组合能力，本文对on()详解', 6, 1, 0, 0, 0, 28, 0);
INSERT INTO `post_main` VALUES (1049, 'Jquery中bind()、live()、delegate()和on()的区别', 'bindqb', '1646185715696.jpg', '自Jquery1.7起，on()方法是 bind()、live()、delegate() 方法的新的替代品，我们推荐使用on()来处理业务中的事件绑定，通过理解这些方法的差异能够更加清晰明白使用on()方法的优势所在', 6, 1, 0, 0, 0, 108, 0);
INSERT INTO `post_main` VALUES (1050, 'JavaScript中获取事件触发源节点的方式', 'checknodes', '1646185999827.jpg', '前端界面常常涉及到需要获取各类事件产生的源节点然后进行后续的逻辑处理（如修改状态、颜色等），本文列举了几类常见的获取源节点对象的方式，原生和Jquery等写法均有列举其中', 6, 1, 0, 0, 0, 458, 0);
INSERT INTO `post_main` VALUES (1051, '通过HttpClient实现服务端收发HTTP请求', 'httpclientapc', '1646186272018.jpg', 'JAVA服务端实现HTTP请求的方式有很多种（比如常见的socket操作），本文介绍采用Apache Jakarta Common下的子项目HttpClient来实现，个人当时引入此工具包主要为实现单点登录能力', 1, 1, 0, 0, 0, 964, 0);
INSERT INTO `post_main` VALUES (1052, 'Linux下Oracle数据库配置日志目录及统一迁移', 'oraclelilog', '1646304079649.jpg', '很多运维人员习惯采用默认安装的方式安装Oracle数据库，而Oracle日志默认放置在/opt目录下，绝大多数Linux环境的大磁盘往往挂载在/home，因此经常会出现磁盘空间不足的情况，采用本文配置可指定并迁移日志', 7, 1, 0, 0, 0, 446, 0);
INSERT INTO `post_main` VALUES (1053, 'bat脚本的基本关键字介绍及脚本实例', 'batbacksh', '1646304232748.jpg', '正常情况下将手工操作的行为转换为DOS命令，然后放入到.bat文件中就完成了一键脚本的制作，本文中的一键备份&清理脚本仅作为抛砖引玉的作用，主要目的用于学习下bat脚本的基本关键字', 12, 1, 0, 0, 0, 341, 0);
INSERT INTO `post_main` VALUES (1054, 'JAVA服务端GET请求URL中文参数乱码', 'getpramnoc', '1646304508051.jpg', '公司的老WEB项目的内部链接跳转时使用了GET请求并且携带参数进行传递，在绝大多数情况没问题，但携带中文参数时后台获取的内容会出现乱码的问题（事实上我们并不建议用GET请求传递太多参数）', 1, 1, 0, 0, 0, 368, 0);
INSERT INTO `post_main` VALUES (1055, 'BigDecimal类实现高精度符点运算', 'bigdecit', '1646304773464.jpg', 'JAVA中默认的double和float数据类型进行符点运算时会造成精度丢失，比如小数点后出现无限个9，而java.math包提供的BigDecimal类则是专门用于提供高精度的符点运算能力。', 1, 1, 0, 0, 0, 818, 0);
INSERT INTO `post_main` VALUES (1056, 'JAVA单例模式中的饿汉模式与懒汉模式', 'modehlh', '1646305094949.jpg', '在绝大多数的JAVA经典应用框架中广泛使用到了单例设计模式，单例设计模式最普遍的分类方式分类分为懒汉模式与饿汉模式两种，其主要区别在于初始化创建对象的时机不同。', 1, 1, 0, 0, 0, 987, 0);
INSERT INTO `post_main` VALUES (1057, 'JAVA设计模式之创建者模式中的三种工厂模式', 'ctrfctmod', '1646305217152.jpg', '工厂模式归属于设计模式中的创建者模式，其主要用途是为了让我们更加优雅的创建JAVA对象，常见的工厂模式主要分为简单工厂、工厂方法、抽象方法三种形式，具体使用中并不拘泥于形式。', 1, 1, 0, 0, 0, 480, 0);
INSERT INTO `post_main` VALUES (1058, 'JAVA语言中的反射机制的作用原理及使用', 'flectdo', '1646305412285.jpg', 'JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；动态获取的信息以及动态调用对象的方法的功能。', 1, 1, 0, 0, 0, 439, 0);
INSERT INTO `post_main` VALUES (1059, 'Meal（一顿饭）基础用户权限管理脚手架', 'meal', '1646356622145.jpg', '基于SpringBoot+Vue前后端分离部署模式用于简化开发的基础脚手架，本工程未包含过多的业务逻辑，仅提供账号、登录、鉴权、授权基础能力，采用了用户-角色最基本的授权模型进行构建。', 13, 1, 2, 0, 2, 757, 0);
INSERT INTO `post_main` VALUES (1060, 'MealS（干饭人）用户角色权限集增强版脚手架', 'meals', '1646357527180.jpg', 'MealS是基于Meal开源工程进行了增强，提供将权限粒度细分到接口/按钮级，采样用户-角色-权限集的方式进行授权、鉴权，可以自行定义角色所具备的权限集，实现更高粒度的权限控制能力。', 13, 1, 1, 0, 1, 470, 0);
INSERT INTO `post_main` VALUES (1061, '20220304米虫博客全站改版', 'mebugs', '1646381175993.jpg', '本站于2022年03月04日完成全部的改版内容，包括前端布局、管理端优化、自动任务优化，增加了大量的功能类开发，完善处理流程和配置化整合等，本站内容已开源与Gitee和Github', 13, 1, 0, 0, 0, 0, 0);

-- ----------------------------
-- Table structure for post_tag
-- ----------------------------
DROP TABLE IF EXISTS `post_tag`;
CREATE TABLE `post_tag`  (
  `pid` bigint(20) NOT NULL COMMENT '文章ID',
  `tid` bigint(20) NOT NULL COMMENT '标签ID',
  UNIQUE INDEX `unitpid`(`pid`, `tid`) USING BTREE COMMENT '文章标签唯一'
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of post_tag
-- ----------------------------
INSERT INTO `post_tag` VALUES (1000, 2);
INSERT INTO `post_tag` VALUES (1000, 3);
INSERT INTO `post_tag` VALUES (1000, 4);
INSERT INTO `post_tag` VALUES (1000, 5);
INSERT INTO `post_tag` VALUES (1000, 6);
INSERT INTO `post_tag` VALUES (1001, 7);
INSERT INTO `post_tag` VALUES (1001, 8);
INSERT INTO `post_tag` VALUES (1001, 9);
INSERT INTO `post_tag` VALUES (1001, 10);
INSERT INTO `post_tag` VALUES (1002, 11);
INSERT INTO `post_tag` VALUES (1002, 12);
INSERT INTO `post_tag` VALUES (1002, 13);
INSERT INTO `post_tag` VALUES (1003, 14);
INSERT INTO `post_tag` VALUES (1003, 15);
INSERT INTO `post_tag` VALUES (1004, 16);
INSERT INTO `post_tag` VALUES (1004, 17);
INSERT INTO `post_tag` VALUES (1004, 18);
INSERT INTO `post_tag` VALUES (1005, 19);
INSERT INTO `post_tag` VALUES (1005, 20);
INSERT INTO `post_tag` VALUES (1006, 21);
INSERT INTO `post_tag` VALUES (1006, 22);
INSERT INTO `post_tag` VALUES (1006, 23);
INSERT INTO `post_tag` VALUES (1007, 24);
INSERT INTO `post_tag` VALUES (1007, 25);
INSERT INTO `post_tag` VALUES (1007, 26);
INSERT INTO `post_tag` VALUES (1008, 27);
INSERT INTO `post_tag` VALUES (1008, 28);
INSERT INTO `post_tag` VALUES (1008, 29);
INSERT INTO `post_tag` VALUES (1009, 30);
INSERT INTO `post_tag` VALUES (1009, 31);
INSERT INTO `post_tag` VALUES (1009, 32);
INSERT INTO `post_tag` VALUES (1010, 1);
INSERT INTO `post_tag` VALUES (1010, 33);
INSERT INTO `post_tag` VALUES (1010, 34);
INSERT INTO `post_tag` VALUES (1011, 35);
INSERT INTO `post_tag` VALUES (1011, 36);
INSERT INTO `post_tag` VALUES (1011, 37);
INSERT INTO `post_tag` VALUES (1012, 38);
INSERT INTO `post_tag` VALUES (1012, 39);
INSERT INTO `post_tag` VALUES (1012, 40);
INSERT INTO `post_tag` VALUES (1013, 41);
INSERT INTO `post_tag` VALUES (1013, 42);
INSERT INTO `post_tag` VALUES (1013, 43);
INSERT INTO `post_tag` VALUES (1014, 44);
INSERT INTO `post_tag` VALUES (1014, 45);
INSERT INTO `post_tag` VALUES (1014, 46);
INSERT INTO `post_tag` VALUES (1015, 31);
INSERT INTO `post_tag` VALUES (1015, 47);
INSERT INTO `post_tag` VALUES (1015, 48);
INSERT INTO `post_tag` VALUES (1016, 49);
INSERT INTO `post_tag` VALUES (1016, 50);
INSERT INTO `post_tag` VALUES (1016, 51);
INSERT INTO `post_tag` VALUES (1017, 52);
INSERT INTO `post_tag` VALUES (1017, 53);
INSERT INTO `post_tag` VALUES (1017, 54);
INSERT INTO `post_tag` VALUES (1018, 12);
INSERT INTO `post_tag` VALUES (1018, 55);
INSERT INTO `post_tag` VALUES (1018, 56);
INSERT INTO `post_tag` VALUES (1019, 57);
INSERT INTO `post_tag` VALUES (1019, 58);
INSERT INTO `post_tag` VALUES (1019, 59);
INSERT INTO `post_tag` VALUES (1020, 1);
INSERT INTO `post_tag` VALUES (1020, 56);
INSERT INTO `post_tag` VALUES (1020, 60);
INSERT INTO `post_tag` VALUES (1021, 61);
INSERT INTO `post_tag` VALUES (1021, 62);
INSERT INTO `post_tag` VALUES (1021, 63);
INSERT INTO `post_tag` VALUES (1022, 64);
INSERT INTO `post_tag` VALUES (1022, 65);
INSERT INTO `post_tag` VALUES (1022, 66);
INSERT INTO `post_tag` VALUES (1023, 40);
INSERT INTO `post_tag` VALUES (1023, 67);
INSERT INTO `post_tag` VALUES (1023, 68);
INSERT INTO `post_tag` VALUES (1024, 69);
INSERT INTO `post_tag` VALUES (1024, 70);
INSERT INTO `post_tag` VALUES (1024, 71);
INSERT INTO `post_tag` VALUES (1025, 72);
INSERT INTO `post_tag` VALUES (1025, 73);
INSERT INTO `post_tag` VALUES (1025, 74);
INSERT INTO `post_tag` VALUES (1026, 75);
INSERT INTO `post_tag` VALUES (1026, 76);
INSERT INTO `post_tag` VALUES (1026, 77);
INSERT INTO `post_tag` VALUES (1027, 78);
INSERT INTO `post_tag` VALUES (1027, 79);
INSERT INTO `post_tag` VALUES (1028, 54);
INSERT INTO `post_tag` VALUES (1028, 73);
INSERT INTO `post_tag` VALUES (1028, 78);
INSERT INTO `post_tag` VALUES (1029, 31);
INSERT INTO `post_tag` VALUES (1029, 64);
INSERT INTO `post_tag` VALUES (1029, 80);
INSERT INTO `post_tag` VALUES (1030, 79);
INSERT INTO `post_tag` VALUES (1030, 81);
INSERT INTO `post_tag` VALUES (1030, 82);
INSERT INTO `post_tag` VALUES (1031, 72);
INSERT INTO `post_tag` VALUES (1031, 79);
INSERT INTO `post_tag` VALUES (1031, 81);
INSERT INTO `post_tag` VALUES (1032, 19);
INSERT INTO `post_tag` VALUES (1032, 27);
INSERT INTO `post_tag` VALUES (1032, 83);
INSERT INTO `post_tag` VALUES (1033, 59);
INSERT INTO `post_tag` VALUES (1033, 84);
INSERT INTO `post_tag` VALUES (1033, 85);
INSERT INTO `post_tag` VALUES (1034, 11);
INSERT INTO `post_tag` VALUES (1034, 19);
INSERT INTO `post_tag` VALUES (1034, 86);
INSERT INTO `post_tag` VALUES (1035, 72);
INSERT INTO `post_tag` VALUES (1035, 87);
INSERT INTO `post_tag` VALUES (1035, 88);
INSERT INTO `post_tag` VALUES (1036, 11);
INSERT INTO `post_tag` VALUES (1036, 19);
INSERT INTO `post_tag` VALUES (1036, 46);
INSERT INTO `post_tag` VALUES (1037, 89);
INSERT INTO `post_tag` VALUES (1037, 90);
INSERT INTO `post_tag` VALUES (1037, 91);
INSERT INTO `post_tag` VALUES (1038, 70);
INSERT INTO `post_tag` VALUES (1038, 92);
INSERT INTO `post_tag` VALUES (1038, 93);
INSERT INTO `post_tag` VALUES (1039, 40);
INSERT INTO `post_tag` VALUES (1039, 94);
INSERT INTO `post_tag` VALUES (1039, 95);
INSERT INTO `post_tag` VALUES (1040, 93);
INSERT INTO `post_tag` VALUES (1040, 96);
INSERT INTO `post_tag` VALUES (1040, 97);
INSERT INTO `post_tag` VALUES (1041, 98);
INSERT INTO `post_tag` VALUES (1041, 99);
INSERT INTO `post_tag` VALUES (1041, 100);
INSERT INTO `post_tag` VALUES (1042, 19);
INSERT INTO `post_tag` VALUES (1042, 98);
INSERT INTO `post_tag` VALUES (1042, 101);
INSERT INTO `post_tag` VALUES (1043, 19);
INSERT INTO `post_tag` VALUES (1043, 102);
INSERT INTO `post_tag` VALUES (1043, 103);
INSERT INTO `post_tag` VALUES (1044, 38);
INSERT INTO `post_tag` VALUES (1044, 59);
INSERT INTO `post_tag` VALUES (1044, 94);
INSERT INTO `post_tag` VALUES (1045, 104);
INSERT INTO `post_tag` VALUES (1045, 105);
INSERT INTO `post_tag` VALUES (1045, 106);
INSERT INTO `post_tag` VALUES (1046, 38);
INSERT INTO `post_tag` VALUES (1046, 67);
INSERT INTO `post_tag` VALUES (1046, 107);
INSERT INTO `post_tag` VALUES (1047, 8);
INSERT INTO `post_tag` VALUES (1047, 35);
INSERT INTO `post_tag` VALUES (1047, 108);
INSERT INTO `post_tag` VALUES (1048, 11);
INSERT INTO `post_tag` VALUES (1048, 12);
INSERT INTO `post_tag` VALUES (1048, 109);
INSERT INTO `post_tag` VALUES (1049, 11);
INSERT INTO `post_tag` VALUES (1049, 12);
INSERT INTO `post_tag` VALUES (1049, 109);
INSERT INTO `post_tag` VALUES (1050, 11);
INSERT INTO `post_tag` VALUES (1050, 110);
INSERT INTO `post_tag` VALUES (1050, 111);
INSERT INTO `post_tag` VALUES (1051, 106);
INSERT INTO `post_tag` VALUES (1051, 112);
INSERT INTO `post_tag` VALUES (1051, 113);
INSERT INTO `post_tag` VALUES (1052, 14);
INSERT INTO `post_tag` VALUES (1052, 38);
INSERT INTO `post_tag` VALUES (1052, 53);
INSERT INTO `post_tag` VALUES (1053, 8);
INSERT INTO `post_tag` VALUES (1053, 70);
INSERT INTO `post_tag` VALUES (1053, 114);
INSERT INTO `post_tag` VALUES (1054, 99);
INSERT INTO `post_tag` VALUES (1054, 106);
INSERT INTO `post_tag` VALUES (1054, 115);
INSERT INTO `post_tag` VALUES (1055, 116);
INSERT INTO `post_tag` VALUES (1055, 117);
INSERT INTO `post_tag` VALUES (1055, 118);
INSERT INTO `post_tag` VALUES (1056, 5);
INSERT INTO `post_tag` VALUES (1056, 78);
INSERT INTO `post_tag` VALUES (1056, 119);
INSERT INTO `post_tag` VALUES (1057, 5);
INSERT INTO `post_tag` VALUES (1057, 78);
INSERT INTO `post_tag` VALUES (1057, 119);
INSERT INTO `post_tag` VALUES (1058, 2);
INSERT INTO `post_tag` VALUES (1058, 88);
INSERT INTO `post_tag` VALUES (1058, 120);
INSERT INTO `post_tag` VALUES (1059, 74);
INSERT INTO `post_tag` VALUES (1059, 121);
INSERT INTO `post_tag` VALUES (1059, 122);
INSERT INTO `post_tag` VALUES (1060, 74);
INSERT INTO `post_tag` VALUES (1060, 121);
INSERT INTO `post_tag` VALUES (1060, 122);
INSERT INTO `post_tag` VALUES (1061, 19);
INSERT INTO `post_tag` VALUES (1061, 123);
INSERT INTO `post_tag` VALUES (1061, 124);

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '标签ID',
  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '名称',
  `url` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '静态URL',
  `remark` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '说明',
  `num` int(11) NOT NULL DEFAULT 0 COMMENT '文章数',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 125 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES (1, 'Git', 'git', '流行的代码管理工具', 2);
INSERT INTO `tag` VALUES (2, '对象', 'object', '编程语言常用操作主体', 2);
INSERT INTO `tag` VALUES (3, '实例化', 'smake', '创建或产生一个对象行为', 1);
INSERT INTO `tag` VALUES (4, '构造', 'gnew', '构建产生对象的方式', 1);
INSERT INTO `tag` VALUES (5, '工厂', 'factory', '一种对象管理设计模式', 3);
INSERT INTO `tag` VALUES (6, '序列化', 'seris', '内存对象与物理存储互转', 1);
INSERT INTO `tag` VALUES (7, '自动化', 'autodo', '快速进行覆盖测试的方式', 1);
INSERT INTO `tag` VALUES (8, '脚本', 'scripts', '手工命令的执行聚合体', 3);
INSERT INTO `tag` VALUES (9, 'expect', 'expect', 'expect脚本', 1);
INSERT INTO `tag` VALUES (10, '批量', 'batch', '一次性大量数据统一处理', 1);
INSERT INTO `tag` VALUES (11, 'JQuery', 'jquery', '经典前端工具库', 6);
INSERT INTO `tag` VALUES (12, '方法', 'method', '编程世界中的逻辑集合体', 4);
INSERT INTO `tag` VALUES (13, '原生', 'bofm', '天然自身的属性或方法', 1);
INSERT INTO `tag` VALUES (14, '磁盘', 'disk', '电子存储物理容器', 2);
INSERT INTO `tag` VALUES (15, '挂载', 'imgz', 'Linux内核磁盘绑定操作', 1);
INSERT INTO `tag` VALUES (16, '任务', 'tasks', '具有目标的执行安排', 1);
INSERT INTO `tag` VALUES (17, 'Cron', 'cron', '配置定时任务的表达式', 1);
INSERT INTO `tag` VALUES (18, '定时', 'timtt', '指定时间或循环的方式', 1);
INSERT INTO `tag` VALUES (19, 'CSS', 'css', '网页样式文本', 6);
INSERT INTO `tag` VALUES (20, '渐变', 'grade', '多种颜色线性转化效果', 1);
INSERT INTO `tag` VALUES (21, '试用', 'tryuse', '一种商业软件推广方式', 1);
INSERT INTO `tag` VALUES (22, '收费', 'ncash', '顾名思义，收费', 1);
INSERT INTO `tag` VALUES (23, '对比', 'byto', '不同内容之间双向比较', 1);
INSERT INTO `tag` VALUES (24, 'servlet', 'servlet', 'JavaWeb服务容器', 1);
INSERT INTO `tag` VALUES (25, '生命周期', 'lifed', '初始化存活到销毁周期', 1);
INSERT INTO `tag` VALUES (26, '容器', 'iocxs', '存放和维护对象的场所', 1);
INSERT INTO `tag` VALUES (27, '加载', 'load', '读取相关资源的过程', 2);
INSERT INTO `tag` VALUES (28, '加速', 'speeds', '提升资源或服务的访问速度', 1);
INSERT INTO `tag` VALUES (29, '预加载', 'preload', '在执行具体事项前提前读取', 1);
INSERT INTO `tag` VALUES (30, '环境', 'env', '服务器或应用运行的支撑', 1);
INSERT INTO `tag` VALUES (31, '配置', 'confx', '辅助进行设置的内容', 3);
INSERT INTO `tag` VALUES (32, '资源', 'rsous', '一般代指内存或存储', 1);
INSERT INTO `tag` VALUES (33, 'IDE', 'ide', '开发辅助工具', 1);
INSERT INTO `tag` VALUES (34, '插件', 'plugin', '优化补充增强的辅助', 1);
INSERT INTO `tag` VALUES (35, '密码', 'password', '秘密的编码？哈？', 2);
INSERT INTO `tag` VALUES (36, '信任', 'xstrs', '可以被放行的操作', 1);
INSERT INTO `tag` VALUES (37, '关系', 'gxrel', '事物之间存在一定联系', 1);
INSERT INTO `tag` VALUES (38, 'Oracle', 'oracle', '甲骨文旗下商用数据库', 4);
INSERT INTO `tag` VALUES (39, '命令', 'scrml', 'DOS交互形式的控制手段', 1);
INSERT INTO `tag` VALUES (40, 'SQL', 'sql', '一种数据库交互语句', 3);
INSERT INTO `tag` VALUES (41, '伪静态', 'rewjt', '一种伪装静态地址的手段', 1);
INSERT INTO `tag` VALUES (42, '重写', 'rewrite', '无感知的变化调用形式', 1);
INSERT INTO `tag` VALUES (43, 'Nginx', 'nginx', '高并发Web服务容器', 1);
INSERT INTO `tag` VALUES (44, 'uni-app', 'uniapp', '国产混合开发框架', 1);
INSERT INTO `tag` VALUES (45, 'WebView', 'webview', 'APP应用访问网络页面载体', 1);
INSERT INTO `tag` VALUES (46, '导航', 'header', '网站的快捷访问聚合处', 2);
INSERT INTO `tag` VALUES (47, 'MySql', 'mysql', '经典的开源关系型数据库', 1);
INSERT INTO `tag` VALUES (48, '变量', 'strbs', '服务于配置的引用对象', 1);
INSERT INTO `tag` VALUES (49, 'MyBatis', 'mybatis', '灵活的数据库操作框架', 1);
INSERT INTO `tag` VALUES (50, '泛型', 'fxins', 'Spring的优秀特性之一', 1);
INSERT INTO `tag` VALUES (51, '脚手架', 'usefot', '即开即用的整合型项目', 1);
INSERT INTO `tag` VALUES (52, 'Chrome', 'chrome', '谷歌浏览器', 1);
INSERT INTO `tag` VALUES (53, '日志', 'log', '系统或应用运行的记录文件', 2);
INSERT INTO `tag` VALUES (54, '数据', 'datas', '代指任何形式的内容', 2);
INSERT INTO `tag` VALUES (55, '多线程', 'mthread', '并发执行的一种方式', 1);
INSERT INTO `tag` VALUES (56, '创建', 'crete', '有无到有的过程', 2);
INSERT INTO `tag` VALUES (57, 'Docker', 'docker', '虚拟容器化技术', 1);
INSERT INTO `tag` VALUES (58, 'SSH', 'ssh', '一种常见的通信方式', 1);
INSERT INTO `tag` VALUES (59, '连接', 'conn', '一种通信的状态', 3);
INSERT INTO `tag` VALUES (60, '仓库', 'reck', '代码工程项目的代称', 1);
INSERT INTO `tag` VALUES (61, '缓存', 'cache', '提升数据访问速度的手段', 1);
INSERT INTO `tag` VALUES (62, '分布式', 'fmore', '多个服务共同组成系统的方式', 1);
INSERT INTO `tag` VALUES (63, '高并发', 'morff', '大量的同时的请求', 1);
INSERT INTO `tag` VALUES (64, 'Maven', 'maven', 'JAVA工程依赖管理大师', 2);
INSERT INTO `tag` VALUES (65, '依赖', 'depyl', '工程对其他Jar包的需求', 1);
INSERT INTO `tag` VALUES (66, '管理', 'manage', '保证可持续的手段', 1);
INSERT INTO `tag` VALUES (67, '条件', 'ift', '分支的判定依据', 2);
INSERT INTO `tag` VALUES (68, '语法', 'uyfa', '命令或代码的使用规则', 1);
INSERT INTO `tag` VALUES (69, 'Redis', 'redis', '高性能缓存中间件', 1);
INSERT INTO `tag` VALUES (70, 'Windows', 'windows', '最常见的视窗操作系统', 3);
INSERT INTO `tag` VALUES (71, '版本', 'vers', '软件或应用的标识号', 1);
INSERT INTO `tag` VALUES (72, 'Spring', 'spring', '经典容器管理框架', 3);
INSERT INTO `tag` VALUES (73, 'SpringMVC', 'springmvc', '经典MVC开发框架', 2);
INSERT INTO `tag` VALUES (74, 'SpringBoot', 'springboot', '优秀的快速开发脚手架', 3);
INSERT INTO `tag` VALUES (75, 'Android', 'android', '流行的智能手机操作系统', 1);
INSERT INTO `tag` VALUES (76, '代理', 'vpns', '网络中转处理服务', 1);
INSERT INTO `tag` VALUES (77, 'Android Studio', 'astudo', '安卓的开发IDE工具', 1);
INSERT INTO `tag` VALUES (78, '设计', 'dismod', '系统应用设计的方式', 4);
INSERT INTO `tag` VALUES (79, 'MVC', 'mvc', '一种模型数据视图涉及模式', 3);
INSERT INTO `tag` VALUES (80, 'pom', 'pomsx', 'maven的依赖配置文件', 1);
INSERT INTO `tag` VALUES (81, 'Struts', 'struts', '一款经典的WEB框架', 2);
INSERT INTO `tag` VALUES (82, '校验', 'valisd', '对数据或请求进行检查', 1);
INSERT INTO `tag` VALUES (83, '动画', 'animo', '动态变化的效果', 1);
INSERT INTO `tag` VALUES (84, 'Xshell', 'xsjell', '优秀的商业化运维工具', 1);
INSERT INTO `tag` VALUES (85, 'Xftp', 'xftp', '优秀的商业化运维工具', 1);
INSERT INTO `tag` VALUES (86, '体验', 'usedy', '标识使用的感受', 1);
INSERT INTO `tag` VALUES (87, 'Bean', 'bean', '代指对象（Spring名词）', 1);
INSERT INTO `tag` VALUES (88, '获取', 'geth', '通过某种方式取得', 2);
INSERT INTO `tag` VALUES (89, '点击', 'cick', 'WEB交互最常见行为', 1);
INSERT INTO `tag` VALUES (90, '误操作', 'wrongdo', '意外的错误操作行为', 1);
INSERT INTO `tag` VALUES (91, '攻击', 'atckgg', '恶意的操作或访问行为', 1);
INSERT INTO `tag` VALUES (92, '系统', 'system', '闭环完整的应用服务集', 1);
INSERT INTO `tag` VALUES (93, '内存', 'pyrunc', '用于存放运行数据的空间', 2);
INSERT INTO `tag` VALUES (94, '删除', 'dell', '清理或移除数据的行为', 2);
INSERT INTO `tag` VALUES (95, '效率', 'runxx', '速度和效果的综合词', 1);
INSERT INTO `tag` VALUES (96, 'fpm', 'fpm', 'PHP FastCGI 进程管理器', 1);
INSERT INTO `tag` VALUES (97, '进程', 'cthred', '系统运行的任务载体', 1);
INSERT INTO `tag` VALUES (98, '字符串', 'str', '最常见的程序数据格式', 2);
INSERT INTO `tag` VALUES (99, '乱码', 'lucode', '那种看都看不懂的内容', 2);
INSERT INTO `tag` VALUES (100, '截取', 'suncut', '从数据中取出任意一部分', 1);
INSERT INTO `tag` VALUES (101, '失效', 'lostx', '没有达成预期的效果', 1);
INSERT INTO `tag` VALUES (102, '自适应', 'aumobi', '多终端访问网页方案', 1);
INSERT INTO `tag` VALUES (103, '覆写', 'fuwri', '覆盖写入或覆盖生效', 1);
INSERT INTO `tag` VALUES (104, '过滤器', 'filter', '过滤请求的中间层', 1);
INSERT INTO `tag` VALUES (105, '处理', 'docl', '依照要求执行操作', 1);
INSERT INTO `tag` VALUES (106, '请求', 'request', '常见的互联网交互名词', 3);
INSERT INTO `tag` VALUES (107, '插入', 'insert', '常见的数据库新增数据操作', 1);
INSERT INTO `tag` VALUES (108, 'Shell', 'shell', 'Linux系统的执行脚本', 1);
INSERT INTO `tag` VALUES (109, '绑定', 'bind', '一种方法与事件关联形式', 2);
INSERT INTO `tag` VALUES (110, '事件', 'event', '操作行为的载体', 1);
INSERT INTO `tag` VALUES (111, '节点', 'nodes', '代指多层元素的任意一层', 1);
INSERT INTO `tag` VALUES (112, 'HTTP', 'http', '常见的互联网交互协议', 1);
INSERT INTO `tag` VALUES (113, '服务端', 'serverd', '通常我们称之为后台', 1);
INSERT INTO `tag` VALUES (114, 'DOS', 'dos', '常见的操作系统交互命令', 1);
INSERT INTO `tag` VALUES (115, '参数', 'parms', '数据的属性或内容', 1);
INSERT INTO `tag` VALUES (116, ' 运算', 'mathys', '运行计算取得结果', 1);
INSERT INTO `tag` VALUES (117, '精度', 'fljds', '数据的精准程度', 1);
INSERT INTO `tag` VALUES (118, '浮点型', 'float', '一般代指数学中的小数', 1);
INSERT INTO `tag` VALUES (119, '模式', 'model', '特定的运作形式', 2);
INSERT INTO `tag` VALUES (120, '反射', 'ftrs', '对象编程一种常见特质', 1);
INSERT INTO `tag` VALUES (121, 'Vue', 'vue', '流行的前端开发框架', 2);
INSERT INTO `tag` VALUES (122, '权限', 'primisson', '安全管理的手段', 2);
INSERT INTO `tag` VALUES (123, '博客', 'blog', '用于发布文章的平台', 0);
INSERT INTO `tag` VALUES (124, 'HTML', 'html', 'Web网页的编码语言', 0);

-- ----------------------------
-- Table structure for urls
-- ----------------------------
DROP TABLE IF EXISTS `urls`;
CREATE TABLE `urls`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '配置ID',
  `type` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'banner/img',
  `img` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '显示图片',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '指向链接',
  `sorts` smallint(2) NULL DEFAULT NULL COMMENT '排序',
  `status` smallint(1) NOT NULL COMMENT '启用 0 不启用 1启用',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of urls
-- ----------------------------
INSERT INTO `urls` VALUES (1, 'banner', '/static/upload/urls/1643264826117.jpg', '/page/about.html', 1, 1);
INSERT INTO `urls` VALUES (2, 'smaller', '/static/upload/urls/1643264859337.png', '/category/open_1.html', 1, 1);
INSERT INTO `urls` VALUES (3, 'smaller', '/static/upload/urls/1643264883629.jpg', '/page/msg.html', 2, 1);
INSERT INTO `urls` VALUES (4, 'smaller', '/static/upload/urls/1643264902496.jpg', '/page/link.html', 3, 1);
INSERT INTO `urls` VALUES (5, 'smaller', '/static/upload/urls/1643264913873.jpg', '/page/map.html', 4, 1);
INSERT INTO `urls` VALUES (6, 'banner', '/static/upload/urls/1646382838335.jpg', '/post/mebugs.html', 2, 1);

SET FOREIGN_KEY_CHECKS = 1;
